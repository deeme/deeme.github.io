[{"categories":["调试"],"content":"安装插件 前置需要安装NvChad ","date":"2023-04-05","objectID":"/posts/technology/nvim_debug_mixed_cpp_python/:1:0","tags":null,"title":"nvim下混合编译调试Dreamplace源码","uri":"/posts/technology/nvim_debug_mixed_cpp_python/"},{"categories":["调试"],"content":"引入插件 { lazy = false, \"rcarriga/nvim-dap-ui\", dependencies = { { \"mfussenegger/nvim-dap\", config = function() return require(\"custom.configs.dap.init\")  Annotations specify that at most 0 return value(s) are required, found 1 to 2 returned here instead. end, }, }, }, ","date":"2023-04-05","objectID":"/posts/technology/nvim_debug_mixed_cpp_python/:1:1","tags":null,"title":"nvim下混合编译调试Dreamplace源码","uri":"/posts/technology/nvim_debug_mixed_cpp_python/"},{"categories":["调试"],"content":"配置插件 C++调试配置 -- c++配置 -- file:dap/cppdbg.lua local dap = require(\"dap\") local function isempty(s) return s == nil or s == \"\" end dap.adapters.cppdbg = { id = 'cppdbg', type = 'executable', command = '~/.local/share/nvim/mason/bin/OpenDebugAD7', } dap.configurations.cpp = { { name = \"Launch file\", type = \"cppdbg\", request = \"launch\", program = function() return vim.fn.input('Path to executable: ', vim.fn.getcwd() .. '/', 'file') end, cwd = '${workspaceFolder}', stopAtEntry = true, }, { name = 'Attach to gdbserver :1234', type = 'cppdbg', request = 'launch', MIMode = 'gdb', miDebuggerServerAddress = 'localhost:1234', miDebuggerPath = '/usr/bin/gdb', cwd = '${workspaceFolder}', args = function() return {vim.fn.input('Parameters to executable: ', vim.fn.getcwd() .. '/', 'file')} end, program = function() return vim.fn.input('Path to executable: ', vim.fn.getcwd() .. '/', 'file') end, }, } 调试初始化 -- c++配置 -- file:dap/init.lua local dap, dapui = require(\"dap\"), require(\"dapui\") dapui.setup() dap.listeners.after.event_initialized[\"dapui_config\"] = function() dapui.open() end dap.listeners.before.event_terminated[\"dapui_config\"] = function() dapui.close() end dap.listeners.before.event_exited[\"dapui_config\"] = function() dapui.close() end require(\"custom.configs.dap.cppdbg\") 调试快捷键配置 M.Debug = { n = { [\"\u003cF5\u003e\"] = { ':lua require(\"dap\").continue()\u003cCR\u003e', \"debug: run/continue\" }, [\"\u003cF7\u003e\"] = { ':lua require(\"dap\").toggle_breakpoint()\u003cCR\u003e', \"debug: toggle breakpoint\" }, [\"\u003cF8\u003e\"] = { ':lua require(\"dap\").terminate() require(\"dapui\").close()\u003cCR\u003e', \"debug: stop\" }, [\"\u003cF9\u003e\"] = { ':lua require(\"dap\").step_into()\u003cCR\u003e', \"debug: step into\" }, [\"\u003cF10\u003e\"] = { ':lua require(\"dap\").step_out()\u003cCR\u003e', \"debug: step out\" }, [\"\u003cF11\u003e\"] = { ':lua require(\"dap\").step_over()\u003cCR\u003e', \"debug: step out\" }, [\"\u003cleader\u003edb\"]= { ':lua require(\"dap\").set_breakpoint(vim.fn.input(\"Breakpoint condition: \"))\u003cCR\u003e', \"debug: Set breakpoint with condition\" }, [\"\u003cleader\u003edc\"]= { ':lua require(\"dap\").run_to_cursor()\u003cCR\u003e', \"debug: run to cursor\" }, [\"\u003cleader\u003edl\"]= { ':lua require(\"dap\").run_last()\u003cCR\u003e', \"debug: run last\" }, [\"\u003cleader\u003edo\"]= { ':lua require(\"dap\").repl.open()\u003cCR\u003e', \"debug: open REPL\" }, }, } ","date":"2023-04-05","objectID":"/posts/technology/nvim_debug_mixed_cpp_python/:1:2","tags":null,"title":"nvim下混合编译调试Dreamplace源码","uri":"/posts/technology/nvim_debug_mixed_cpp_python/"},{"categories":["调试"],"content":"调试源码 ","date":"2023-04-05","objectID":"/posts/technology/nvim_debug_mixed_cpp_python/:2:0","tags":null,"title":"nvim下混合编译调试Dreamplace源码","uri":"/posts/technology/nvim_debug_mixed_cpp_python/"},{"categories":["调试"],"content":"启动GDBServer gdbserver localhost:1234 ~/anaconda3/bin/python unittest/ops/lpabs_wirelength_unittest.py ","date":"2023-04-05","objectID":"/posts/technology/nvim_debug_mixed_cpp_python/:2:1","tags":null,"title":"nvim下混合编译调试Dreamplace源码","uri":"/posts/technology/nvim_debug_mixed_cpp_python/"},{"categories":["调试"],"content":"Neovim连接GDBServer 按F5进入调试运行模式，选2回车 输入运行参数回车 输入对应的python路径回车 ","date":"2023-04-05","objectID":"/posts/technology/nvim_debug_mixed_cpp_python/:2:2","tags":null,"title":"nvim下混合编译调试Dreamplace源码","uri":"/posts/technology/nvim_debug_mixed_cpp_python/"},{"categories":["调试"],"content":"调试界面 显示如下则成功进入调试模式： ","date":"2023-04-05","objectID":"/posts/technology/nvim_debug_mixed_cpp_python/:2:3","tags":null,"title":"nvim下混合编译调试Dreamplace源码","uri":"/posts/technology/nvim_debug_mixed_cpp_python/"},{"categories":null,"content":"Step1 （安装GNOME桌面） sudo apt-get update sudo apt-get install gnome-session-flashback sudo apt-get install ubuntu-desktop gnome-panel gnome-settings-daemon metacity nautilus gnome-terminal -y ","date":"2023-03-28","objectID":"/posts/technology/vnc_server/:0:1","tags":null,"title":"Ubuntu安装VNCServer","uri":"/posts/technology/vnc_server/"},{"categories":null,"content":"Step2 sudo apt-get -y install xfonts-100dpi xfonts-100dpi-transcoded xfonts-75dpi xfonts-75dpi-transcoded xfonts-base ","date":"2023-03-28","objectID":"/posts/technology/vnc_server/:0:2","tags":null,"title":"Ubuntu安装VNCServer","uri":"/posts/technology/vnc_server/"},{"categories":null,"content":"Step3 sudo apt install tigervnc-standalone-server ","date":"2023-03-28","objectID":"/posts/technology/vnc_server/:0:3","tags":null,"title":"Ubuntu安装VNCServer","uri":"/posts/technology/vnc_server/"},{"categories":null,"content":"Step4：配置密码 vncpasswd ","date":"2023-03-28","objectID":"/posts/technology/vnc_server/:0:4","tags":null,"title":"Ubuntu安装VNCServer","uri":"/posts/technology/vnc_server/"},{"categories":null,"content":"Step5：配置XStartup vim ~/.vnc/xstartup 内容如下： #!/bin/sh # Start Gnome 3 Desktop [ -x /etc/vnc/xstartup ] \u0026\u0026 exec /etc/vnc/xstartup [ -r $HOME/.Xresources ] \u0026\u0026 xrdb $HOME/.Xresources vncconfig -iconic \u0026 dbus-launch --exit-with-session gnome-session \u0026 ","date":"2023-03-28","objectID":"/posts/technology/vnc_server/:0:5","tags":null,"title":"Ubuntu安装VNCServer","uri":"/posts/technology/vnc_server/"},{"categories":null,"content":"Step6:重启TigerVNC tightvncserver -kill :1 vncserver -depth 24 -name mydesktop -localhost no :1 ","date":"2023-03-28","objectID":"/posts/technology/vnc_server/:0:6","tags":null,"title":"Ubuntu安装VNCServer","uri":"/posts/technology/vnc_server/"},{"categories":["笔记"],"content":"基本概念 ","date":"2023-03-27","objectID":"/posts/research/eplace/:1:0","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"布局的定义 布局问题可以描述为一个超图问题，可以定义为如下： $$G = (V,E,R)$$ 其中$V$表示元器件（顶点）集合，$E$表示网表（超边）集合，$R$表示布局区域。在$V$中$V_m$表示可移动器件的集合，$V_f$表示固定块集合。令$n=|V_m|$表示可移动布局对象的个数。 一个合法的布局解决方案应该要满足下面三个要求： 在布局区域中使用足够的空闲位置容纳每个器件 每个元器件在水平方向上要和布局行的边界对齐 元器件和宏组件不能有重合 基于上述的合法性限制，布局的目标就是最小化网表的总$HPWL$，假定$\\mathbf{v}=(\\mathbf{x},\\mathbf{y})$表示一个布局的方案，其中$\\mathbf{x}={x_i|i \\in V_m}$表示所有元器件的水平坐标，$\\mathbf{y}={y_i|i \\in V_m}$表示元器件的垂直坐标，则对于每个网表$e(e \\in E)$，其半周线长的定义如下： $$HPWL_e(\\mathbf{v}) = \\max_{i,j \\in e}|x_i-x_j|+\\max_{i,j \\in e}|y_i-y_j| \\tag 1$$ 则总半周线长定义为： $$HPWL(\\mathbf{v}) = \\sum_{e \\in E} HPWL_e(\\mathbf{v})$$ 布局问题定义为如下： $$\\min_\\mathbf{v}HPWL(\\mathbf{v})，使得\\mathbf{v}是一个合法的布局方案 \\tag 2$$ ","date":"2023-03-27","objectID":"/posts/research/eplace/:1:1","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"全局布局的定义 把布局区域$R$按$m\\times m$划分成一个一个的格子（称作bin），这些格子的集合是B，其中$\\rho_b(\\mathbf{v})$表示每个b的密度，其定义如下： $$\\rho_b(\\mathbf{v}) = \\sum_{i \\in V} l_x(b,i)l_y(b,i) \\tag 3$$ 其中$l_x(b,i)$和$l_y(b,i)$分别表示元器件i和格子b之间的水平和垂直重合，全局布局的定义如下： $$\\min_\\mathbf{v}HPWL(\\mathbf{v})\\ s.t.\\rho_b(\\mathbf{v})\\leq \\rho_t, \\forall b \\in B \\tag 4$$ ","date":"2023-03-27","objectID":"/posts/research/eplace/:1:2","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"线长平滑化 每一个网表$e={(x_1,y_1),(x_2,y_2),\\cdots,(x_n,y_n)}$有n个引脚 ,对数和指数（LSE）在水平轴x方向的线长平滑公式如下： $$W_e(\\mathbf{v}) =\\gamma \\begin{pmatrix} ln\\sum_{i \\in e} exp(\\frac{x_i}{\\gamma})+ln\\sum_{i \\in e} exp(\\frac{-x_i}{\\gamma}) \\end{pmatrix} \\tag{5}$$ 其中${\\gamma}$是平滑参数，不能随意设置的足够小。 权重平均（WA）在水平轴x方向的线长平滑公式如下： $$W_e(\\mathbf{v}) = \\begin{pmatrix} \\frac{\\sum_{i \\in e} x_iexp(\\frac{x_i}{\\gamma})}{\\sum_{i \\in e} exp(\\frac{x_i}{\\gamma})}-\\frac{\\sum_{i \\in e} x_iexp(-\\frac{x_i}{\\gamma})}{\\sum_{i \\in e} exp(-\\frac{x_i}{\\gamma})} \\end{pmatrix} \\tag{6}$$ ","date":"2023-03-27","objectID":"/posts/research/eplace/:1:3","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"密度惩罚 在实际的布局当中，$|B|$个格子的密度都需要满足限制，我们把这些限制用一个惩罚项$N(\\mathbf{v})$来表示，当惩罚项$N(\\mathbf{v})=0$时所有的密度都满足，其定义如下： $$\\rho_b(\\mathbf{v})\\leq \\rho_t, \\forall b \\in B \\iff N(\\mathbf{v})=0 \\tag 7$$ 用二次惩罚项来表示如下： $$N(\\mathbf{v})=\\sum_{b \\in B }(\\widetilde \\rho_{b}(\\mathbf{v})- \\rho_t)^2 \\tag 8$$ 其中$\\widetilde \\rho_{b}$表示在Naylor et al. 2001中定义的铃状的平滑密度函数，密度惩罚$N(\\mathbf{v})$也用来表示系统的势能。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:1:4","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"非线性布局优化方程 利用惩罚因子$\\lambda$目标函数$f(\\mathbf{v})$的定义： $$\\min_\\mathbf{v} f(\\mathbf{v}) = W(\\mathbf{v})+\\lambda N(\\mathbf{v}) \\tag 9$$ 也可以用拉格郎日乘子法写成下面的形式： $$\\min_\\mathbf{v} f(\\mathbf{v}) = W(\\mathbf{v})+\\sum_{b \\in B}\\lambda_b|\\widetilde \\rho_{b}(\\mathbf{v})- \\rho_t| \\tag{10}$$ 其中$\\lambda_b$表示每个格子b的密度限制参数乘子 ","date":"2023-03-27","objectID":"/posts/research/eplace/:1:5","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"静电系统建模（eDensity） 电势和电场分布由系统中的所有元素决定，在网表中的每个节点（元器件或者宏块）带正电苛的粒子i。粒子的带电量$q_i$表示为节点的面积$A_i$，根据洛仁力量定律(Lorentz force law)定义的电力$F_i=q_i \\xi_i$，会引起可移动的节点i的运动，$\\xi_i$表示节点i的布局电场。同样的$N_i=q_i \\psi_i$表示节点的势能，$\\psi_i$表示器件i的电势大小。根据库仑定律，器件i的电场和电势是系统中剩余器件共同作用的叠加。 整个布局的电苛密度分布表示为$\\rho(x,y)$，$\\xi_x(x,y)$表示水平电场的分布函数，表示$\\psi(x,y)$电势分布函数。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:2:0","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"静电平衡系统建模 布局系统和静电系统的建模图： 根据建模规则，把均匀分布的全局布局约束同静电平衡的系统状态联系起来，电力会指引电苛（元器件）向着平衡状态的方向移动。根据高斯法则，电场等于电势的负梯度，如下定义： $$\\xi(x,y)=(\\xi_x,\\xi_y)=-\\nabla\\psi(x,y)= \\begin{pmatrix} -\\frac{\\partial \\psi(x,y)}{\\partial x},-\\frac{\\partial \\psi(x,y)}{\\partial y} \\end{pmatrix} \\tag{11}$$ 电苛的密度函数等于电场函数的散度 $$\\rho(x,y)=\\nabla \\cdot \\xi(x,y)=-\\nabla \\cdot \\nabla\\psi(x,y)=- \\begin{pmatrix} \\frac{\\partial ^2\\psi(x,y)}{\\partial x^2}+\\frac{\\partial ^2\\psi(x,y)}{\\partial y^2} \\end{pmatrix} \\tag{12}$$ 静电系统如果只有正电苛那么只会产生排斥力，相应的静电平衡状态会把所有的器件沿着边界进行分布，因为在边界上可以违反布局约束。因此需要从密度分布当中移除直流组件（即0频率组件）去产生负电苛，从而整个布局区域的密度函数整体变为0。 具体一点说，因为密度函数把所有的对象转化成了正电苛，因此就产生了一个正电苛密度分布。然后就是当直流电移除后，需要填充的区域的电量会比原来有直流电的时候的电量更小，因此就变成了负电苛。同时过于填充的区域依然是正电苛（但是电量比原来小了）。正电苛多的地方会向着负电苛区域移动，相互中和，从而达到一个静电平衡的状态。使得整个系统在布局区域内达到电苛密度为0并且电势也降到0。 这样就把布局的密度惩罚和梯度建模为了势能和电场。‘ ","date":"2023-03-27","objectID":"/posts/research/eplace/:2:1","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"密度惩罚和梯度 势能的总和等于新的元器件集合$V^{’}$中所有带电元素的势能之和，这些元素包含了来自$V$中的可移动节点、固定宏节点，也包含了下一步要讨论的填充节点和暗节点。 填充节点插入 上图中的黑色长方形表示宏元器件，红点表示标准元器件，蓝点表示填充节点，随着填充节点充斥在空白区域，有了更小的总线长，同时器件也挤压在了一起，相互离的更近。 $A_m$表示可移动节点的总面积，$A_{ws}$表示空白空间的总面积。如果目标密度是$\\rho_t \\geq \\frac{A_m}{A_{ws}}$，均匀密度分布会过度的把器件平铺，引起了不必要的线长增加。填充节点（filler cell）都是等尺寸（距形）的，可以移动和并且是断连（0引脚）。$A_{fc}$表示填充节点的总面积，定义如下： $$A_{fc} = \\rho_tA_{ws}-A_m \\tag{13}$$ 每个填充节点$i$的面积是$A_i$，这个是由可移动器件的面积分布所决定的。每个填充节点的尺寸是可移动器件的中间80%的平均尺寸。填充节点的插入会增加额外的密度力，这会使得元器件和他的连接器件之间的距离更小，同时也会满足密度约束。全局布局结束以后，所有的填充节点都会删除。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:2:2","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"暗节点插入 用一个均匀的网格$R(m\\times m)$铺在所有的布局区域上，$R$里面不属于任何布局区域的所有空间都会被划分成一个包含很多长方形格子的集合，每一个格子就是一个暗节点， 对于暗节点的处理方式和固定器件的处理方式一致。$V_d$表示所有的暗节点集合，$A_d$表示所有的节点的总面积。当可移动节点到达布局的边界上时，可移动节点会因为受到暗节点的排斥力而停止。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:2:3","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"密度缩放 填充节点插入后，目标密度就变成了$\\rho_t = \\frac{A_m+A_{fc}}{A_{ws}}$。为了去维持全局等效的密度分布，每一个固定节点或者暗节点$i$的面积$A_i$都需要通过$\\rho_t$进行缩放，否则密度力会变得比填充物的密度力更大，并把器件排斥开，固定结点周围的空白区域会被置空，也会增加下图所示的线长开销。 上图中(a)和(b)在没有密度缩放的情况下，在大组件上网格的密度会高于目标密度，从而密度力会把器件从大组件周围推开，从而引起了宏组件周围更多待填充的空白区域和线长开销。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:2:4","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"势能计算 $V^{’}=V_m \\bigcup V_f \\bigcup V_{fc} \\bigcup V_d$表示系统中所有元素的集合，对于每一个节点$i \\in V^{’}$，$\\rho_i$、$\\xi_i$和$\\psi_i$分别表示该节点的电密度、电场和电势。给定一个可移动器件集合$V_m$和填充节点集合$V_{fc}$的布局方案$\\mathbf{v}$，其总的势能如下表示： $$N(\\mathbf{v})=\\frac{1}{2}\\sum_{i \\in V^{’} }N_i=\\frac{1}{2}\\sum_{i \\in V^{’} }q_i\\psi_i \\tag{14}$$ 因为系统的势能会等于所有的电苛的相互作用之和，所以每个单节点需要乘以$\\frac{1}{2}$，把重多网格密度约束问题转化成了一个0势能系统的单一势能约束$N(\\mathbf{v})=0$。通过引入惩罚因子$\\lambda$，一个不受约束的优化问题如下： $$\\min_\\mathbf{v} f = W(\\mathbf{v})+\\lambda N(\\mathbf{v}) \\tag{15}$$ 其中$W(\\mathbf{v})$是来自方程6，$f(\\mathbf{v})$表示的是最小化的代价函数。因为$W(\\mathbf{v})$和$N(\\mathbf{v})$都是平滑的，我们可以通过求微分得到如下的梯度向量$\\nabla f(\\mathbf{v})$： $$\\nabla f(\\mathbf{v}) = \\nabla W(\\mathbf{v})+\\lambda\\nabla N(\\mathbf{v})= \\begin{pmatrix} \\frac{\\partial W}{\\partial x_1},\\frac{\\partial W}{\\partial y_1},\\cdots \\end{pmatrix}^T - \\lambda(q_1{\\xi_1}_x,q_1{\\xi_1}_y,\\cdots)^T \\tag{16}$$ ","date":"2023-03-27","objectID":"/posts/research/eplace/:2:5","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"泊松方程和数值计算 根据在3里面定义的eDensity（电密度）公式，使用泊松方程去解决带电势和电场的电苛密度问题。诺伊曼边界条件（the Neumann boundary condition）是用来去合法化全局布局方案。泊松方程是可以数值求解的，其用到了谱方法，有着高精确度并且简单。因此，我们提出该技术在离散网格上局部平滑化电密度。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:3:0","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"明确定义的泊松方程 根据高斯准则，电势分布$\\psi(x,y)$可以借助泊松方程使用电密度函数$\\rho(x,y)$来求解，方程如下所示： $$\\nabla \\cdot \\nabla\\psi(x,y)=-\\rho(x,y),(x,y) \\in R\\tag{17}$$ 令$\\mathbf{\\hat n}$是布局区域的外法向量，$\\partial R$是边界。当器件向布局区域的边界上移动时，为了阻止元器件向边界外移动，会停止或者减慢器件的继续向外运动。当器件到达密度函数值域的边界时电密度力会减少到0。因此借助诺伊曼边界条件，边界上就需要定义一个0梯度。 $$\\mathbf{\\hat n} \\cdot \\nabla\\psi(x,y)=0,(x,y) \\in \\partial R\\tag{18}$$ 此外，在整个布局区域R上电势函数$\\psi(x,y)$和密度函数$\\rho(x,y)$的积分都需要为0，如下所示 $$\\iint_{R} \\rho(x,y)=\\iint_R\\psi(x,y)=0\\tag{19}$$ 因此，所有来自电场和电势密度的不定积分所引入的常量因子都是0。方程19也保证了方程17中的偏微分方程有唯一解。克服了定义了在Eisenmann and Johannes [1998]中因定义不清晰的偏微分方程所引起的问题。 基于先前的定义和讨论，整个泊松方程的构建如下： $$\\begin{cases} \\nabla \\cdot \\nabla\\psi(x,y)=-\\rho(x,y) \\ \\mathbf{\\hat n} \\cdot \\nabla\\psi(x,y)=0,(x,y) \\in \\partial R \\ \\iint_{R} \\rho(x,y)=\\iint_R\\psi(x,y)=0 \\ \\end{cases} \\tag{20}$$ 不同于以往的基于偏微分方程的布局方法，该论文是基于一个完整的系统模型。密度惩罚是被正式的定义为系统势能。泊松方程是用来去求解电场，它和电量一起共同作用决定了密度梯度，该梯度遵从洛仁力量定律。通过设置电势的积分为0，该偏微分方程的唯一解得到了保证。计算简单且没有额外的线性项。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:3:1","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"使用谱方法快速数值求解法 谱方法表示的是把某些偏微分求解看成是基函数（例如是正余弦波）的总和，并且在求和的时候选择系数去满足偏微分方程的边界条件。正弦函数是一个奇函数，同时也是一个周期函数。在每一个周期的边界上，函数值为0，这就很自然的满足了伊曼边界条件。因此我们使用正弦函数作为基函数去表示电场。 因为电密度和电势分别是电场的导数和积分，我们使用余弦函数作为基函数去表示电密度和电势。 基于这样一种在频域中的分解，使用谱方法可以求解泊松方程。通过使用离散余弦变换（DCT, discrete cosine transformation）,把原始的密度函数$\\rho(x,y)$修改成一个奇且周期的函数形式$\\rho _{DCT}(x,y)$。所以新的函数可以分解成一组不同频率上的余弦波振荡，且可以通过DCT来构建。电场函数和电势函数则可以用相似的方法用离散正弦变换（DST）来构建。 对于密度函数具体的修改方式如下： 假定布局区域R被均匀的划分成一个个$m\\times m$的的小格子，因此密度口中函数$\\rho(x,y)$的定义域为$[0,m-1]\\times[0,m-1]$，把密度波映射到负半边则函数的定义域扩展到品了$[-m,m-1]\\times[-m,m-1]$，则密度函数变成了偶函数。然后周期是性的把函数的定义域扩展到$[-\\infty,+\\infty]\\times[-\\infty,+\\infty]$，基于上述的这两个修改，新的密度函数$\\rho_{DCT}(x,y)$可以使用DCT来表示。 假定$u$和$v$是0到m-1的整数下标，频率分量分别定义为$w_u=2\\pi \\frac{u}{m}$和$w_v=2\\pi \\frac{v}{m}$，同时我们使用$a_{u,v}$表示每个DCT基波函数的系数。由定义可知，所有的$m\\times m$系数可以由二维网格上的基波函数乘以密口度函数的积分得到，公式如下所示： $$a_{u,v}= \\frac 1m \\sum_{x=0}^{m-1}\\sum_{y=0}^{m-1}\\rho(x,y)\\cos(w_ux)\\cos(w_vy) \\tag{21}$$ 则所有的先验系数都可以通过快速傅立叶变换一次性求得。使用余弦系数，新的密度函数$\\rho_{DCT}(x,y)$可以通过余弦波的和如下表示： $$\\rho_{DCT}(x,y)= \\sum_{u=0}^{m-1}\\sum_{v=0}^{m-1}a_{u,v}\\cos(w_ux)\\cos(w_vy) \\tag{22}$$ 上述方程可以通过调用FFT库快速求解，基于通过方程17和19和在方程22上的余弦表达式，有了如下的势能函数$\\psi_{DCT}(x,y)$方程： $$\\psi_{DCT}(x,y)= \\sum_{u=0}^{m-1}\\sum_{v=0}^{m-1} \\frac {a_{u,v}}{w_u^2+w_v^2} \\cos(w_ux)\\cos(w_vy) \\tag{23}$$ 根据高斯法则，电场向量是方程11当中势能函数的负梯度，基于方程23定义的势能函数，可以用DCT和DST的形式得到电场的函数表达式$\\xi(x,y)=(\\xi_{X_{DSCT}},\\xi_{Y_{DCST}})$，如下所示： $$\\begin{cases} \\xi_{X_{DSCT}}= \\sum_u\\sum_v \\frac {a_{u,v}w_u}{w_u^2+w_v^2} \\sin(w_ux)\\cos(w_vy) \\ \\xi_{Y_{DCST}}= \\sum_u\\sum_v \\frac {a_{u,v}w_v}{w_u^2+w_v^2} \\cos(w_ux)\\sin(w_vy) \\end{cases} \\tag{24}$$ 其中水平分量$\\xi_{X_{DSCT}}$是由水平电场的正弦波所构建的，x值在周期结束的时候，也就是在到达布局的边界上的时候，其值为0。垂直分量$\\xi_{Y_{DCST}}$同理。这两个分量可以通过FFT库直接求解。 本方法中使用了DCT和DST谱方法去给偏微分方程求解，在这个方法里面密度惩罚建模为系统势能，密度梯度建模为电苛力。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:3:2","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"行为和复杂度分析 下图表示了一个二维平面的离散密度的电场分布，随着迭代的进行密度的分布也会发生变化，电场的分布也会改变，因此电场会动态的指引器件向欠填充区域流动。从下图当中我们也发现到，在布局区域的边界上，电场变为0。这样的行为就满足了边界条件和全局布局的要求。下图当中的灰点是密度分布，红箭头是电场方向。 假定布局区域上总的有$n^{’}$个器件（$n^{’}=|V_m|+|V_{fc}|$）和一个$m\\times m$的网格。本方法的总的复杂度主要来自两个方面， 一是密度计算，二是势能和电场的计算。 密度计算。每个迭代中，密度函数是由下面两步完成： （1）遍历B中所有的元素去清空器件密度和器件面积到0 （2）遍历所有的可移动器件和填充器件，对于有重叠的相应网格需要计算每个器件对于相应网格的面积贡献 第一步的时间复杂度是$O(m^2)$，第二步的复杂度是$O(n^{’})$，所以每个迭代产生密度分布的总时间复杂度为$O(m^2+n^{’})$。 势能电场计算。每个迭代会调用四次FFT库去解决方程21、23和24。每个2维的FFT库的复杂度为$O(m^2\\log m^2)=O(2m^2\\log m)=O(m^2\\log m)$，因此总的复杂度为$O(m^2\\log m)$ 一般来说，我们的数值方法每个布局迭代的时间复杂度为$O(n^{’}+m^2 \\log m)$。因为网格的数量规模通常和器件是同一个数级规模（可以确保离散后的准确性），所以有$O(n^{’})=O(m^2)$，并且总的时间复杂度为$O(m^2\\log m)$或$O(n^{’}\\log n^{’})$。填充器件的加入会增加一些计算时间，但是不会改变整体的计算量级。所有的填充器件和标准器件的平均尺寸一样大，如果效率低的话标准器件会被放大到网格的尺寸，使得填充物的总数量不会超过$O(m^2)$。而且因为填充器件的个数规模和可移动器件的规模是一样的，会有$n=O(n^{’})$，因此总的时间复杂度为$O(n\\log n)$，$n$为可移动器件的个数。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:3:3","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"离散网格上的局部平滑 电密度的全局平滑可以通过方程11和方程12得到。因为每个单元网格的大小通常会比器件的尺寸要大，所以单元网格内部的局部运动是不能在密度函数上反应出来的，从而使平滑性变差。因此我们提出了一种局部平滑技术使得方程14中的密度函数可以反应出每个单元网格内部的任何细微的运动。如下图表示的是一个一维的例子，其中$w_i$表示的是器件的宽度，$w_b$表示的是单元格的宽度；然后，$c_i$表示的是器件中心的坐标，$c_b$单元格中心的坐标。 $l_x(i,b)$表示的是原始的器件和单元格在水平方向上的重叠，$\\hat l_x(i,b)$表示的是平滑后的水平方向上的重叠。则有如下： $$\\hat l_x(i,b)=\\begin{cases} (1.0-\\frac {c_i-c_b}{w_b})\\times w_i:c_i \\in [c_b-w_b,c_b+w_b]\\ 0:c_i \\in [-\\infty,c_b-w_b]\\cup[c_b+w_b,+\\infty] \\end{cases} \\tag{25}$$ 随着器件向右移动，器件对单元格$b’$的密度贡献线性减少，对单元格$b’’$贡献线性增加。当器件在两个单元格坐标$c_{b’}$和$c_{b’’}$的中间的时候，也就是$c_i$在$[c_{b’},c_{b’’}]$上的时候，器件$i$对于两个单元格的总贡献是不变的，且贡献为$w_i$。这种平滑的效果是等价于器件的拉伸和器件密度降低的组合，保持了目标代价函数的可解析。对于每一个器件$i$，局部平滑化进行如下操作： 如果$w_i\u003c w_b$，把器件的宽度从$w_i$拉长到$w_b$，并且把器件密度从1.0减少到$w_i/w_b$ 如果$w_i\\ge w_b$，保持原来的细胞宽度和密度 这种平滑技术在不同的粒度和器件尺寸上都是一样的，在每个迭代更新密度图的时候都会用到这种平滑技术。因为对于每个器件来说只有有限个邻近的单元格会被该器件影响到，所以其时间复杂度是恒定不变的，因此计算复杂度并未发生变化。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:3:4","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"非线性优化 布局问题是NP完全问题。如方程9中所示，目标函数由一个凸线长函数和一个非凸密度函数组成，非凸函数加大了现代凸规划方法求解的难度。本部分先介绍先前非线性布局当中使用到的共轭梯度方法，讨论线搜索的效率瓶颈。这篇论文是首次在全局布局优化中使用Nesterov’s方法和Lipschitz常数预测。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:4:0","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"共轭梯度法 下图为第k个迭代的时候的算法，其中第4行是线搜索算法，存在较多的问题。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:4:1","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"使用Lipschitz常数预测的Nesterov’s方法 和CG法类似，但是Nesterov法只需要一阶导数和线性的内存开销。Nesterov法旨在解决Hilbert空间$H$里的凸规划问题。和大多数和凸规划方法不同，Nesterov法构建了一个不松弛的最小化的点序列${\\mathbf{u}_k}_0^\\infty$。算法2如下所示，表示了第k次迭代的处理算法，这次迭代主要聚焦在$\\min{f(\\mathbf{u})|\\mathbf{u} \\in H}$这个问题上，该问题有非空的最小值集合$U^*$。算法2如下所示： 上述算法中，$\\mathbf{u}$是凸规划问题的解，$\\mathbf{v}$是用来计算步长的参考解，$a$是优化参数，$\\alpha$是步长。迭代开始时($k=0$)，该方法会初始化$\\mathbf{v}_0 \\in H,a_0=1,\\alpha_0=\\frac{||\\nabla f(\\mathbf{v}_0)-\\nabla f(\\mathbf{z})||}{||\\mathbf{v}_0-\\mathbf{z}||}$。其中$\\mathbf{z}$是$H$中的任意一个点且$\\mathbf{z}\\neq\\mathbf{v}_0$。Nesterov法的收敛率是$O(1/k^2)$，上述算法的第2行主要就是加速收敛，如果要达到预期的收敛率，则步长$\\alpha_k$在每一个迭代中都要满足下列方程： $$f(\\mathbf v_k)-f(\\mathbf v_k-\\alpha_k\\nabla f(\\mathbf v_k))\\geq0.5\\alpha_k||\\nabla f(\\mathbf v_k)||^2 \\tag{26}$$ Nesterov法的上界错误率方程27所示。 定理 5.1。假定$f(\\mathbf u)$是一个在$C^{1,1}(H)$和$U^* \\neq \\varnothing$上的凸函数，其中$C^{1,1}(H)$表示梯度函数$\\nabla f(\\mathbf u)$是Lipschitz连续的。现有$\\mathbf u\\in U^＊$，并且$L$是梯度函数$\\nabla f(\\mathbf u)$的Lipschitz常数。则由上述算法2输出的$\\mathbf{u}_k$会存在以下公式： $$f(\\mathbf u_k)-f(\\mathbf u^*) \\geq \\frac{4L||\\mathbf v_0-\\mathbf u^＊||^2}{(k+2)^2} \\tag{27}$$ 定义 5.2。给定一个函数$f \\in C^{1,1}(H)$，并且$L$是梯度函数$\\nabla f(\\mathbf u)$的Lipschitz常数，则对于任意的$\\mathbf u,\\mathbf v \\in H$有 $$||\\nabla f(\\mathbf u)-\\nabla f(\\mathbf v)||\\leq L||\\mathbf v-\\mathbf u||, \\tag{28}$$ 并且$\\nabla f(\\mathbf u)$是Lipschitz连续的。因为Nesterov法使用了二分查找法去计算最大步长所以，在每一个迭代中目标函数都需要评估$O(\\log L)$次，则时间复杂度增加到了$O(n\\log n\\log L)$。相反，我们使用步长预测去加速我们的布局算法。正如在论文Nesterov [1983]中讨论的，如果梯度函数的Lipschitz常数已知，我们可以设置步长为Lipschitz常数的倒数去满足方程26，不会引起任何开销。但是预测准确全局布局梯度函数的Lipschitz常数往往会比较困难，因为有如下原因： 因为密度函数的加入，使得目标函数非凸，因此定理5.1不满足。 因为要动态的调整平滑系数（方程6），线长函数会随着迭代而改变。 因为要在运行的时候做力平衡，所以在密度函数上方程15中的惩罚因子$\\lambda$会随着迭代而变化。 因为上述特性，全局布局函数是非凸且动态变化的，所以需要一个随着迭代去动态估计Lipschitz常数为$\\widetilde L$。基于方程28，分别设定函数$\\mathbf x$和$\\mathbf y$的值为当前参考值$\\mathbf y_k$和上一次迭代的参考值$\\mathbf y_{k-1}$，则$\\nabla f(\\mathbf y_k)$Lipschitz常数可以用如下公式逼近： $$\\widetilde L_k = \\frac {||\\nabla f(\\mathbf y_k)-\\nabla f(\\mathbf y_{k-1})||} {||\\mathbf y_k-\\mathbf y_{k-1}||} \\tag{29}$$ 则根据上述讨论可以知道步长为： $$\\alpha_k=\\frac{1}{\\widetilde L_k}$$ 上述的方法是高效的，因为： （1）都是已知的，没有额外的计算。 （2）相比较于随机的选择$\\mathbf x$和$\\mathbf y$，前后迭代的$\\mathbf y_k$和$\\mathbf y_{k-1}$的值比较接近，则$||\\mathbf y_k-\\mathbf y_{k-1}||$值相对较小，可以防止对Lipschitz常数的估计精度过低，并且防止过度估计步长$\\alpha_k$。 在实验当中也证实了，这种估计法有效的加速了计算过程。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:4:2","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"预处理 预处理减少了问题的条件数，使得原本的问题更加适合数值求解法求解。传统的预处理方法是计算并且反转目标函数$f$的海森矩阵$H_f$。因为密度函数是非凸的所以在非线性布局上还没人使用预处理。预处理梯度向量$\\nabla f_{pre}=H^{-1}\\nabla f$可以平滑化数值优化，加速函数的收敛。 因为全局布局的目标函数是高度非线性并随迭代变化，再者问题的规模往往是百万级别，这就使得每次迭代的时候计算海深矩阵的代价就太高了，且不实际。为了可以在实际中计算海森矩阵，我们使用只使用海森矩阵对角项的雅格比预处理来近似求解，如下所示： $$\\mathbf H_{\\mathbf f_{\\mathbf x,\\mathbf x}}= \\begin{Bmatrix} \\frac {\\partial^2 f} {\\partial x^2_1} \u0026 \\frac {\\partial^2 f} {\\partial x_1\\partial x_2} \u0026\\cdots \u0026\\frac {\\partial^2 f} {\\partial x_1\\partial x_n} \\\\ \\frac {\\partial^2 f} {\\partial x_2\\partial x_1} \u0026 \\frac {\\partial^2 f} {\\partial x^2_2} \u0026\\cdots \u0026\\frac {\\partial^2 f} {\\partial x_2\\partial x_n} \\\\ \\vdots \u0026 \\vdots \u0026\\ddots \u0026\\vdots\\\\ \\frac {\\partial^2 f} {\\partial x_n\\partial x_1} \u0026 \\frac {\\partial^2 f} {\\partial x_n\\partial x_2} \u0026\\cdots \u0026\\frac {\\partial^2 f} {\\partial x^2_n} \\\\ \\end{Bmatrix} \\approx\\begin{Bmatrix} \\frac {\\partial^2 f} {\\partial x^2_1} \u0026 0 \u0026\\cdots \u00260 \\\\ 0 \u0026 \\frac {\\partial^2 f} {\\partial x^2_2} \u0026\\cdots \u00260 \\\\ \\vdots \u0026 \\vdots \u0026\\ddots \u0026\\vdots \\\\ 0 \u0026 0 \u0026\\cdots \u0026\\frac {\\partial^2 f} {\\partial x^2_n} \\\\ \\end{Bmatrix}=\\widetilde H_{\\mathbf f_{\\mathbf x,\\mathbf x}}\\tag{30}$$ 根据上述近似，同理可以计算$\\mathbf H_{\\mathbf f_{\\mathbf y,\\mathbf y}}$，因此可以计算出$\\mathbf H_{\\mathbf f}$。通过方程15则有$\\frac {\\partial^2 f(\\mathbf v)} {\\partial x^2_i}=\\frac {\\partial^2 W(\\mathbf v)} {\\partial x^2_i}+\\lambda\\frac {\\partial^2 N(\\mathbf v)} {\\partial x^2_i}$，我们可以精准的估计出$\\frac {\\partial^2 W(\\mathbf v)} {\\partial x^2_i}和\\frac {\\partial^2 N(\\mathbf v)} {\\partial x^2_i}$的值，保证预处理的可行性。方程6中对线长函数微分的代价会比较高，所以我们使用器件$i$的顶点度来计算，如下： $$\\frac {\\partial^2 W(\\mathbf v)} {\\partial x^2_i}=\\sum_{e\\in E_i}\\frac {\\partial^2 W_e(\\mathbf v)} {\\partial x^2_i}\\implies |E_i|，\\tag{31}$$ 其中$E_i$表示和器件i相关的网表子集。方程14中所表示的密度函数是非凸的，就使得传统的预处理方法不能够得到预期的性能。方程32使用了二阶微分： $$\\frac {\\partial^2 N(\\mathbf v)} {\\partial x^2_i}=q_i\\frac {\\partial^2 \\psi(\\mathbf v)} {\\partial x^2_i}=q_i\\frac {-\\partial \\xi_{i_x}(\\mathbf v)} {\\partial x_i}= q_i。\\tag{32}$$ 所以使用线性项$q_i$作为密度预处理，使用上述的近似来表示$\\widetilde H_{\\mathbf f_{\\mathbf x,\\mathbf x}}$会有如下方程： $$\\widetilde H_{\\mathbf f_{\\mathbf x,\\mathbf x}}=\\begin{Bmatrix} |E_1|+\\lambda q_1 \u0026 0 \u0026\\cdots \u00260 \\\\ 0 \u0026 |E_2|+\\lambda q_2 \u0026\\cdots \u00260 \\\\ \\vdots \u0026 \\vdots \u0026\\ddots \u0026\\vdots \\\\ 0 \u0026 0 \u0026\\cdots \u0026|E_n|+\\lambda q_n \\\\ \\end{Bmatrix} \\tag{33}$$ 因此可以计算出预处理的梯度为$\\nabla f_{pre}=\\widetilde {\\mathbf H}_{\\mathbf f}^{-1}\\nabla f$ ","date":"2023-03-27","objectID":"/posts/research/eplace/:4:3","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"全局布局算法 如下图8所示表示的是，ePlace的整个布局流程： 其中分为三个阶段： （1）初始布局 ：使用B2B网络模型最小化二次项线长函数，得到初始布局的输出结果$\\mathbf v_{ip}$。 （2）全局布局：根据电势理论优化器件的位置 （3）细节布局：全局布局完成后，移除所有的填充器件，并使用FastDP进行合法化和离散优化。 从上面的讨论中我们知道，CG法和Nesterov法都是用来解决方程15中不受限的优化问题，为了去改善优化结果和收敛率，我们使用了一种自适应参数调整法。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:5:0","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"自适应参数调整法 网格的尺寸 在整个全局布局阶段，网格的大小都是固定的。这是在粒度和效率之间的平衡。越大的尺寸往往代表的是高效低准确率，越小的尺寸则相反。比较大的尺寸也会带来一些额外的问题，更多的器件会有相同的密度力。这些器件糅合在一起，有相同的运动轨迹，也就是说这些器件会在相邻区域间发生密度震荡，阻止器件的扩散。 这篇论文中风格的尺寸大小是基于器件和填充器件的个数来计算，把网格的尺寸设定为$m=\\min(\\lceil \\log_2\\sqrt{n{’}} \\rceil, 1024)$，设定最大为1024的原因是出于效率考虑。 步长 在Nesterov法中根据方程29可以估计出步长为Lipschitz常数估计的倒数，即$\\alpha_k=\\frac{1}{\\widetilde L_k}$。在CG法中，步长由线搜索来决定的，在搜索间隔中，沿着共轭梯度的方向线搜索会找到局部最优，搜索的间隔$\\alpha_k^{\\max}$是动态的调整的。初始的间隔$\\alpha_0^{\\max}$和单元格的大小成线性关系$\\alpha_0^{\\max}=kw_b$，其中$w_b$是单元格宽度。实际设置$k=0.044$可以得到较好的布局质量，并且$\\alpha_k^{\\max}$需要基于当前最优步长$\\alpha_{k-1}$进行更新，如下所示： $$\\alpha_k^{\\max}=\\max(\\alpha_0^{\\max},2\\alpha_{k-1})，\\alpha_k^{\\min}=0.01\\alpha_k^{\\max} \\tag{34}$$ 通过方程34，如算法1的第4行所示，GSS可以计算出第k次迭代的步长$\\alpha_k$。线搜索会在间隔缩小到$\\alpha_k^{\\min}$时停止，所以得到的步长$\\alpha_k$不一定是局部最优。 惩罚因子 为了去平衡密度和线长的力，在方程35中设定惩罚因子的初始值为： $$\\lambda_0=\\frac {\\sum_{i \\in V_m^{’}}\\mid W_{x_i} \\mid+\\mid W_{y_i} \\mid} {\\sum_{i \\in V_m^{’}}q_i(\\mid \\xi_{x_i} \\mid+\\mid \\xi_{y_i} \\mid)} \\tag{35}$$ 其中$W_{x_i}=\\frac{\\partial W}{\\partial x_i}，W_{y_i}=\\frac{\\partial W}{\\partial y_i}$，$\\xi_{x_i}$是节点i的水平电场，$\\xi_{y_i}$是节点i的垂直电场。 因为线长和密度都是随着迭代变化的，为了去适应这种实时的变化，惩罚因子也需要时间更新，我们通过如下的式子去更新因子： $$\\lambda_k=u_k\\lambda_{k-1}$$ 令$\\Delta HPWL_k=HPWL(\\mathbf v_k)-HPWL(\\mathbf v_{k-1})$，则$u_k$的定义如下： $$u_k=u_{0}^{-\\frac{\\Delta HPWL_k}{\\Delta HPWL_{ref}}+1.0}(u_0=1.1,\\Delta HPWL_{ref}=3.5\\times10^5) \\tag{36}$$ 如下图所示，不管是在CG法和Nesterov法上，随着迭代的进行因子的值在增加。 密度溢出 全局布局当重叠足够小的时候会结束，接下来就是要处理合法化和细节布局了。使用如下的密度溢出值$\\tau$，公式如下： $$\\tau=\\frac {\\sum_{b \\in B}\\max(\\rho_b^{’}-\\rho_t,0) A_{b}} {\\sum_{i \\in V_m}A_i} \\tag{37}$$ 其中，$A_{b}$是单元格面积，$A_{i}$是可移动器件面积。$\\rho_b^{’}$是只和可移动器件相关的单元格$b$的密度。当密度溢出的值$\\tau\\leq\\tau_{min}$时，全局布局停止。 线长系数 实验中显示，收敛结果和布局结果对于平滑参数$\\gamma$的变化比较敏感。为了在全局上让更多的的器件逃离高密度区域，本论文中的方法在迭代早期放松平滑参数。在后期阶段，当局部调整占主导的时候，参数值变小使得平滑的线长接近HPWL。 同时较小尺寸的单元格密度对于器件的运动会更加敏感，相反越的尺寸就越不敏感。因此设置平滑参数$\\gamma$为密度溢出和单元格宽度的函数。通过减少平滑参数的值，为了去减少剩余的重叠，只需要允许可以局部移动的HPWL不敏感的器件运动。我们所提到的这些HPWL不敏感的器件，指的是它们的运动不会改变器件相关网表的HPWL值，也可以理解成这些器件离网表的边界相对而言比较远。对于 迭代的后期，为了使得线长平滑的收敛，只允许在布局平面上有较小的扰动。所以，因为我们的目的是增加线长建模的准确性，对应的线长力会变得更强去只允许有小规模的运动，也就是较小的平面扰动。如下图所示，最终平滑的HPWL收敛到了HPWL： 在本论文的实验中显示，如下公式建模平滑系数会有比较好的布局结果，公式如下： $$\\gamma(\\tau)=8.0w_b\\times10^{k\\tau+b} \\tag{38}$$ 密度溢出通过在开始为100%，结束的时候为10%（终止条件），根据经验调整有$\\gamma(\\tau=1.0)=80w_b$，有$\\gamma(\\tau=0.1)=0.8w_b$，则可以计算出$k=\\frac{20}{9}，b=-\\frac{11}{9}$。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:5:1","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["笔记"],"content":"全局布局 下图为ePlace全局布局算法的整体流程： 对算法的详细解释如下： 输入参数： $\\mathbf v_0=\\mathbf v_{ip}$表示的是初始布局中的输出结果，标准器件是放置在区域中间，填充器件是随机的分布在整个布局区域$R$上。 $m\\times m$网格拆分规模 最小的密度溢出$\\tau^{\\min}$ 最大的迭代次数为3000 第1行把布局区域R拆分成$m\\times m$的网格 第2行初始化密度惩罚因子 第3行初始化最大间隔（这个在调用CG算法的时候会用到，如果是Nesterov法的话不会用到） 第5行定义了目标函数$f_k$ 第6行计算线长梯度和密度分布 第7行使用FFT库去计算场和势能 第8行计算密度梯度 第9行计算目标函数的总梯度 第10行调用非线性方法（Nesterov法或者CG法）求解新的布局结果 第11行更新非线性方法需要的参数 第12行去判定是不是满足终止条件 最后返回全局布局的结果。 随着迭代的运行，标准器件会从过填充的区域分散到待填充的区域，密度力会把无连接的填充器件推向布局的边界。最后所有的标准器件会收敛到一个稳定状态，此时系统和势能和线长处于可以接受的状态。 ","date":"2023-03-27","objectID":"/posts/research/eplace/:5:2","tags":["电势"],"title":"基于电势的解析布局","uri":"/posts/research/eplace/"},{"categories":["索引"],"content":"教程 Hugo博客官方教程 Markdown 官方教程 ","date":"2022-12-10","objectID":"/posts/misc/collection/:1:0","tags":["收藏","传送门"],"title":"好物收藏","uri":"/posts/misc/collection/"},{"categories":["索引"],"content":"工具 图片上传 | PicX 图床神器 (xpoet.cn) ","date":"2022-12-10","objectID":"/posts/misc/collection/:2:0","tags":["收藏","传送门"],"title":"好物收藏","uri":"/posts/misc/collection/"},{"categories":["建站"],"content":" 本人原来使用的博客是vuepress + vdoing，后来在使用的过程中发现这个博客非常的笨重，没有多少的文章编译下来就需要一会时间。 以前使用过wordpress，这个用来建站是很不错的选择用来做博客的话需要有自己的服务器，并且对于Markdown文档的支持不是很好，现在的博客基本上是使用markdown来写，所以不考虑wordpress。 然后了解到Hugo的出现，看了他的优势，打包速度快，几乎不受文件多少的影响。为了更好专注在写文章，同时可以不用每次繁琐的命令行操作和发布，本教程实现了快捷键操作的一键发布。 文章内容所见即所得。写完文章后快捷键 Crtl + U快速发布文章，然后等待GitHub Action部署完成，刷新页面就可以看到新文章，如下为展示的效果： 快速开始 现在已经把整套流程打通了，直接参考下面的步骤，可以实现Obsidian写博客+自动发布和部署。 下载(Obsidian)并安装 下载安装Git-Bash 配置Git - 生成 SSH 公钥 (git-scm.com) 创建github新项目为：你的用户名.github.io，如SivanLaai.github.io，其中SivanLaai为我的用户名 克隆本项目并切换分支 git clone --recursive git@github.com:SivanLaai/blog.git 进入blog目录，修改git远程仓库为你的github静态博客项目地址 git remote set-url origin git@github.com:SivanLaai/SivanLaai.github.io.git (可选) - 添加Github项目环境变量WEB_SITE为你自己的域名如```www.sivanlaai.laais.cn 利用obsidian打开blog文件夹，开始写博客 快捷键 Crtl + U快速发布文章（利用Obsidian Shell Command插件实现快速发布） 打开你的网址，如sivanlaai.github.io 其他玩法 ","date":"2022-12-09","objectID":"/posts/technology/auto_deploy_with_obsidian/:0:0","tags":["博客搭建","自动部署","hugo"],"title":"Obsidian写hugo博客，github自动部署","uri":"/posts/technology/auto_deploy_with_obsidian/"},{"categories":["建站"],"content":"评论功能（可选） **建议新手根据自己的时间来衡量是否加入，不然折腾起来也挺费劲，容易遇到这种问题。确实有时间的可以尝试 本教程中使用的hugo主题是Loveit，同时加入了评论功能，使用的是Waline评论系统，比较推荐使用这个评论系统，支持自建后端也可以使用免费的后端云服务，有评论管理功能，安全，支持登录和匿名模式，爆吹。 对于Waline的详细使用请看官方教程，根据官方教程配置好Waline后端好，在config.yml里面如下： waline: serverUrl: \"WALINE_SERVER_URL\" 把WALINE_SERVER_URL替换成你的Waline服务地址就可以。 ","date":"2022-12-09","objectID":"/posts/technology/auto_deploy_with_obsidian/:1:0","tags":["博客搭建","自动部署","hugo"],"title":"Obsidian写hugo博客，github自动部署","uri":"/posts/technology/auto_deploy_with_obsidian/"},{"categories":["建站"],"content":"站点统计 针对原版的不算子的统计功能，感觉有点鸡肋，可以尝试加入了其他的站点统计功能 umami（开源比较推荐） 百度统计——一站式智能数据分析与应用平台 (baidu.com) ","date":"2022-12-09","objectID":"/posts/technology/auto_deploy_with_obsidian/:2:0","tags":["博客搭建","自动部署","hugo"],"title":"Obsidian写hugo博客，github自动部署","uri":"/posts/technology/auto_deploy_with_obsidian/"},{"categories":["建站"],"content":"自有主机，docker安装Umami网站统计和Waline评论系统 1.创建文件夹 mkdir website \u0026\u0026 cd website 创建如下文件运行docker-compose up -d version: \"3\" services: db: image: mysql restart: always environment: - MYSQL_ROOT_PASSWORD=PASSWORD - MYSQL_PASSWORD=PASSWORD - MYSQL_DATABASE=umami - MYSQL_USER=user command: --default-authentication-plugin=mysql_native_password --transaction-isolation=READ-COMMITTED --binlog-format=ROW #解决外部无法访问 volumes: - ./conf:/etc/mysql/conf.d - ./data:/var/lib/mysql network_mode: \"host\" unami: image: ghcr.io/umami-software/umami:mysql-latest network_mode: \"host\" environment: DATABASE_URL: mysql://user:PASSWORD@localhost:3306/umami DATABASE_TYPE: mysql HASH_SALT: replace-me-with-a-random-string restart: always waline: container_name: waline image: lizheming/waline:latest restart: always network_mode: \"host\" volumes: - ${PWD}/data:/app/data environment: TZ: 'Asia/Shanghai' MYSQL_HOST: localhost MYSQL_DB: waline MYSQL_USER: user MYSQL_PASSWORD: PASSWORD SITE_NAME: \"SivanLaai's Blog\" SITE_URL: 'http://www.laais.cn' SECURE_DOMAINS: 'www.laais.cn' AUTHOR_EMAIL: 'eamil@163.com' SMTP_PASS: SMTP_PASSWORD SMTP_USER: qqid@qq.com SMTP_SERVICE: QQ 3 初始化waline数据库 /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */; /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */; /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */; /*!40101 SET NAMES utf8 */; SET NAMES utf8mb4; /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */; /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */; /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */; # Dump of table wl_Comment # ------------------------------------------------------------ CREATE TABLE `wl_Comment` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `user_id` int(11) DEFAULT NULL, `comment` text, `insertedAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `ip` varchar(100) DEFAULT '', `link` varchar(255) DEFAULT NULL, `mail` varchar(255) DEFAULT NULL, `nick` varchar(255) DEFAULT NULL, `pid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, `sticky` boolean DEFAULT NULL, `status` varchar(50) NOT NULL DEFAULT '', `like` int(11) DEFAULT NULL, `ua` text, `url` varchar(255) DEFAULT NULL, `createdAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `updatedAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; # Dump of table wl_Counter # ------------------------------------------------------------ CREATE TABLE `wl_Counter` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `time` int(11) DEFAULT NULL, `reaction0` int(11) DEFAULT NULL, `reaction1` int(11) DEFAULT NULL, `reaction2` int(11) DEFAULT NULL, `reaction3` int(11) DEFAULT NULL, `reaction4` int(11) DEFAULT NULL, `reaction5` int(11) DEFAULT NULL, `reaction6` int(11) DEFAULT NULL, `reaction7` int(11) DEFAULT NULL, `reaction8` int(11) DEFAULT NULL, `url` varchar(255) NOT NULL DEFAULT '', `createdAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `updatedAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; # Dump of table wl_Users # ------------------------------------------------------------ CREATE TABLE `wl_Users` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `display_name` varchar(255) NOT NULL DEFAULT '', `email` varchar(255) NOT NULL DEFAULT '', `password` varchar(255) NOT NULL DEFAULT '', `type` varchar(50) NOT NULL DEFAULT '', `label` varchar(255) DEFAULT NULL, `url` varchar(255) DEFAULT NULL, `avatar` varchar(255) DEFAULT NULL, `github` varchar(255) DEFAULT NULL, `twitter` varchar(255) DEFAULT NULL, `facebook` varchar(255) DEFAULT NULL, `google` varchar(255) DEFAULT NULL, `weibo` varchar(255) DEFAULT NULL, `qq` varchar(255) DEFAULT NULL, `2fa` varchar(32) DEFAULT NULL, `createdAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP, `updatedAt` timestamp NULL DEFAULT CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */; /*!401","date":"2022-12-09","objectID":"/posts/technology/auto_deploy_with_obsidian/:2:1","tags":["博客搭建","自动部署","hugo"],"title":"Obsidian写hugo博客，github自动部署","uri":"/posts/technology/auto_deploy_with_obsidian/"},{"categories":["教程"],"content":"nextcloud网盘相关问题 ","date":"2022-07-28","objectID":"/posts/technology/nextcloud/:1:0","tags":["nextcloud","apache","aria2"],"title":"nextcloud配置","uri":"/posts/technology/nextcloud/"},{"categories":["教程"],"content":"网盘配置 （1）配置环境 Linux + Apache2 + Mysql + Php(LAMP) Example installation on Ubuntu 20.04 LTS — Nextcloud latest Administration Manual latest documentation 配置Linux + Nginx + Mysql + Php(LNMP)环境 sudo apt update \u0026\u0026 sudo apt upgrade sudo apt install mariadb-server nginx php-gd php-mysql php-fpm \\ php-curl php-mbstring php-intl php-gmp php-bcmath php-xml php-imagick php-zip （2）安装nextcloud Installation on Linux — Nextcloud latest Administration Manual latest documentation （3）Nginx配置解析php Nginx配置上传大小 # /etc/nginx/nginx.conf http { client_max_body_size 20480M; client_body_buffer_size 10M; } 修改配置 # /etc/nginx/conf.d/nextcloud.conf ## # You should look at the following URL's in order to grasp a solid understanding # of Nginx configuration files in order to fully unleash the power of Nginx. # https://www.nginx.com/resources/wiki/start/ # https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/ # https://wiki.debian.org/Nginx/DirectoryStructure # # In most cases, administrators will remove this file from sites-enabled/ and # leave it as reference inside of sites-available where it will continue to be # updated by the nginx packaging team. # # This file will automatically load configuration files provided by other # applications, such as Drupal or Wordpress. These applications will be made # available underneath a path with that package name, such as /drupal8. # # Please see /usr/share/doc/nginx-doc/examples/ for more detailed examples. ## # Default server configuration # upstream php-handler { #server 127.0.0.1:9000; server unix:/run/php/php8.1-fpm.sock; } server { listen 80; listen [::]:80; server_name nextcloud.laais.cn; # Path to the root of your installation root /var/www/nextcloud; # Enable gzip but do not remove ETag headers gzip on; gzip_vary on; gzip_comp_level 4; gzip_min_length 256; gzip_proxied expired no-cache no-store private no_last_modified no_etag auth; gzip_types application/atom+xml application/javascript application/json application/ld+json application/manifest+json application/rss+xml application/vnd.geo+json application/vnd.ms-fontobject application/wasm application/x-font-ttf application/x-web-app-manifest+json application/xhtml+xml application/xml font/opentype image/bmp image/svg+xml image/x-icon text/cache-manifest text/css text/plain text/vcard text/vnd.rim.location.xloc text/vtt text/x-component text/x-cross-domain-policy; # Pagespeed is not supported by Nextcloud, so if your server is built # with the `ngx_pagespeed` module, uncomment this line to disable it. #pagespeed off; # HTTP response headers borrowed from Nextcloud `.htaccess` add_header Referrer-Policy \"no-referrer\" always; add_header X-Content-Type-Options \"nosniff\" always; add_header X-Download-Options \"noopen\" always; add_header X-Frame-Options \"SAMEORIGIN\" always; add_header X-Permitted-Cross-Domain-Policies \"none\" always; add_header X-Robots-Tag \"none\" always; add_header X-XSS-Protection \"1; mode=block\" always; # Remove X-Powered-By, which is an information leak fastcgi_hide_header X-Powered-By; # Specify how to handle directories -- specifying `/index.php$request_uri` # here as the fallback means that Nginx always exhibits the desired behaviour # when a client requests a path that corresponds to a directory that exists # on the server. In particular, if that directory contains an index.php file, # that file is correctly served; if it doesn't, then the request is passed to # the front-end controller. This consistent behaviour means that we don't need # to specify custom rules for certain paths (e.g. images and other assets, # `/updater`, `/ocm-provider`, `/ocs-provider`), and thus # `try_files $uri $uri/ /index.php$request_uri` # always provides the desired behaviour. index index.php index.html /index.php$request_uri; # Rule borrowed from `.htaccess` to handle Microsoft DAV clients location = / { if ( $http_user_agent ~ ^DavClnt ) { return 302 /remote.php/webdav/$is_args$args; } } location = /robots.txt { allow all; log_not_found o","date":"2022-07-28","objectID":"/posts/technology/nextcloud/:1:1","tags":["nextcloud","apache","aria2"],"title":"nextcloud配置","uri":"/posts/technology/nextcloud/"},{"categories":["教程"],"content":"请更改权限为 0770 以避免其他用户查看目录 config.php . 'check_data_directory_permissions' =\u003e false, ... ","date":"2022-07-28","objectID":"/posts/technology/nextcloud/:1:2","tags":["nextcloud","apache","aria2"],"title":"nextcloud配置","uri":"/posts/technology/nextcloud/"},{"categories":["教程"],"content":"安装配置启动aria2 安装aria2 sudo apt install aria2 cd /etc/ \u0026\u0026 mkdir aria2 \u0026\u0026 cd aria2 \u0026\u0026 touch aria2c.conf \u0026\u0026 touch aria2.session 创建配置文件 #aria2c.conf ## 文件保存相关 ## # 文件保存目录 dir=/var/www/nextcloud/data/nextcloud/files/Video # 启用磁盘缓存, 0为禁用缓存, 需1.16以上版本, 默认:16M disk-cache=32M # 断点续传 continue=true # 文件预分配方式, 能有效降低磁盘碎片, 默认:prealloc # 预分配所需时间: none \u003c falloc ? trunc \u003c prealloc # falloc和trunc则需要文件系统和内核支持 # NTFS建议使用falloc, EXT3/4建议trunc, MAC 下需要注释此项 file-allocation=trunc ## 下载连接相关 ## # 最大同时下载任务数, 运行时可修改, 默认:5 #max-concurrent-downloads=10 # 同一服务器连接数, 添加时可指定, 默认:1 # 官方的aria2最高设置为16, 如果需要设置任意数值请重新编译aria2 max-connection-per-server=16 # 整体下载速度限制, 运行时可修改, 默认:0（不限制） #max-overall-download-limit=0 # 单个任务下载速度限制, 默认:0（不限制） #max-download-limit=0 # 整体上传速度限制, 运行时可修改, 默认:0（不限制） #max-overall-upload-limit=0 # 单个任务上传速度限制, 默认:0（不限制） #max-upload-limit=0 # 禁用IPv6, 默认:false # disable-ipv6=true # 最小文件分片大小, 添加时可指定, 取值范围1M -1024M, 默认:20M # 假定size=10M, 文件为20MiB 则使用两个来源下载; 文件为15MiB 则使用一个来源下载 min-split-size=10M # 单个任务最大线程数, 添加时可指定, 默认:5 # 建议同max-connection-per-server设置为相同值 split=16 ## 进度保存相关 ## # 从会话文件中读取下载任务 input-file=/etc/aria2/aria2.session # 在Aria2退出时保存错误的、未完成的下载任务到会话文件 save-session=/etc/aria2/aria2.session # 定时保存会话, 0为退出时才保存, 需1.16.1以上版本, 默认:0 save-session-interval=60 ## RPC相关设置 ## # 启用RPC, 默认:false enable-rpc=true # 允许所有来源, 默认:false rpc-allow-origin-all=true # 允许外部访问, 默认:false rpc-listen-all=true # RPC端口, 仅当默认端口被占用时修改 # rpc-listen-port=6800 # 设置的RPC授权令牌, v1.18.4新增功能, 取代 --rpc-user 和 --rpc-passwd 选项 rpc-secret=passwd #在访问的时候要使用到的密码 # 启动SSL #rpc-secure=true # 证书文件, 如果启用SSL则需要配置证书文件, 例如用https连接aria2 #rpc-certificate=/var/snap/nextcloud/current/certs/live/fullchain.pem #rpc-private-key=/var/snap/nextcloud/current/certs/live/privkey.pem ## BT/PT下载相关 ## # 当下载的是一个种子(以.torrent结尾)时, 自动开始BT任务, 默认:true follow-torrent=true # 客户端伪装, PT需要 peer-id-prefix=-TR2770- user-agent=Transmission/2.77 # 强制保存会话, 即使任务已经完成, 默认:false # 较新的版本开启后会在任务完成后依然保留.aria2文件 #force-save=false # 继续之前的BT任务时, 无需再次校验, 默认:false bt-seed-unverified=true # 保存磁力链接元数据为种子文件(.torrent文件), 默认:false # bt-save-metadata=true # 单个种子最大连接数, 默认:55 0表示不限制 bt-max-peers=0 # 最小做种时间, 单位:分 seed-time = 1 # 分离做种任务 bt-detach-seed-only=true on-download-complete=/home/filesscan.sh 启动aria2 nohup aria2c --conf-path=/etc/aria2/aria2.conf \u003e /home/linux/aria2.log 2\u003e\u00261 \u0026 配置aria2 自动更新bt tracker # startaria.sh while(true) do sudo kill -9 $(ps -ef|grep aria2|gawk '$0 !~/grep/ {print $2}' |tr -s '\\n' ' ') list=`wget -qO- https://raw.githubusercontent.com/ngosang/trackerslist/master/trackers_best.txt|awk NF|sed \":a;N;s/\\n/,/g;ta\"` echo $list if [ -z \"`grep \"bt-tracker\" /etc/aria2/aria2.conf`\" ]; then sudo sed -i '$a bt-tracker='${list} /etc/aria2/aria2.conf echo add...... else sudo sed -i \"s@bt-tracker.*@bt-tracker=$list@g\" /etc/aria2/aria2.conf echo update...... fi sudo aria2c --conf-path=/etc/aria2/aria2.conf sleep 24h #sleep 10 done 配置nextcloud启动脚本 # startserver.sh sudo service apache2 stop sudo service apache2 start sudo /etc/init.d/mysql start # 运行aria2脚本更新bt trackers sudo nohup bash startaria.sh \u003e /home/linux/log/aria2.log 2\u003e\u00261 \u0026 # 监控文件变化 while(true) do sudo -u www-data php /var/www/nextcloud/occ files:scan --all sleep 60 done # runserver.sh # 删除aria相关的程序 sudo kill -9 $(ps -ef|grep startserver|gawk '$0 !~/grep/ {print $2}' |tr -s '\\n' ' ') sudo kill -9 $(ps -ef|grep startaria|gawk '$0 !~/grep/ {print $2}' |tr -s '\\n' ' ') sudo kill -9 $(ps -ef|grep aria2|gawk '$0 !~/grep/ {print $2}' |tr -s '\\n' ' ') sudo nohup bash startserver.sh \u003e /home/linux/log/nextcloud.log 2\u003e\u00261 \u0026 配置aria2NG # 下载aria2ng cd /var/www/ wget https://github.com/mayswind/AriaNg/releases/download/1.2.3/AriaNg-1.2.3.zip mkdir ariang unzip AriaNg-1.2.3.zip 配置apache2网页 # 创建/etc/apache2/sites-available/ariang.conf Alias /ariang \"/var/www/ariang/\" \u003cDirectory /var/www/ariang/\"\u003e Require all granted AllowOverride All Options FollowSymLinks MultiViews \u003cIfModule mod_dav.c\u003e Dav off \u003c/IfModule\u003e \u003c/Directory\u003e # 访问http://host.example.com/ariang ","date":"2022-07-28","objectID":"/posts/technology/nextcloud/:1:3","tags":["nextcloud","apache","aria2"],"title":"nextcloud配置","uri":"/posts/technology/nextcloud/"},{"categories":["教程"],"content":"Nextcloud镜像安装 创建文件夹nextcloud mkdir nextcloud 创建文件docker-compose.yml --- version: '2' volumes: nextcloud: db: services: db: image: mariadb restart: always command: --transaction-isolation=READ-COMMITTED --binlog-format=ROW volumes: - db:/var/lib/mysql environment: - MYSQL_ROOT_PASSWORD=root - MYSQL_PASSWORD=passwd - MYSQL_DATABASE=nextcloud - MYSQL_USER=nextcloud app: image: nextcloud restart: always ports: - 8080:80 links: - db volumes: - nextcloud:/var/www/html environment: - MYSQL_PASSWORD=passwd - MYSQL_DATABASE=nextcloud - MYSQL_USER=nextcloud - MYSQL_HOST=db 启动镜像 sudo docker-compose up -d 常见问题 ","date":"2022-07-28","objectID":"/posts/technology/nextcloud/:1:4","tags":["nextcloud","apache","aria2"],"title":"nextcloud配置","uri":"/posts/technology/nextcloud/"},{"categories":["教程"],"content":"apache2解析失败php 重新安装php sudo apt-get purge php8.* sudo apt install php ","date":"2022-07-28","objectID":"/posts/technology/nextcloud/:1:5","tags":["nextcloud","apache","aria2"],"title":"nextcloud配置","uri":"/posts/technology/nextcloud/"},{"categories":["教程"],"content":"apache2提示找不到apache.conf 重新安装apache2 sudo dpkg -P apache2 apt-get remove apache2 apt-get install apache2 ","date":"2022-07-28","objectID":"/posts/technology/nextcloud/:1:6","tags":["nextcloud","apache","aria2"],"title":"nextcloud配置","uri":"/posts/technology/nextcloud/"},{"categories":["问题总结"],"content":"wordpress permainlink 不生效 1.打开apache2默认配置文件 sudo vim /etc/apache2/sites-available/000-default.conf 2.修改内容为如下 LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_http_module modules/mod_proxy_http.so \u003cVirtualHost *:80\u003e # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com ServerAdmin webmaster@localhost DocumentRoot /var/www/html \u003cDirectory /var/www/html\u003e AllowOverride All Require all granted \u003c/Directory\u003e # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with \"a2disconf\". #Include conf-available/serve-cgi-bin.conf \u003c/VirtualHost\u003e 3.在/wp-admin/options-permalink.php页面选择-\u003ePermalink structure -\u003e Post name保存生成.hatcess ","date":"2022-05-19","objectID":"/posts/technology/wordpress/:1:0","tags":["wordpress"],"title":"wordpress安装和问题","uri":"/posts/technology/wordpress/"},{"categories":["教程"],"content":"软件编译和安装 ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:0:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"qbittorrent编译安装 安装依赖 apt-get install build-essential pkg-config automake libtool git apt-get install libboost-dev libboost-system-dev libboost-chrono-dev libboost-random-dev libssl-dev libgeoip-dev 安装libtorrent git clone https://github.com/arvidn/libtorrent.git #之前系统版本可直接下载源码使用，18.04需修改include/libtorrent/export.hpp替换boost/config/为boost/config/detail/ #https://github.com/arvidn/libtorrent/releases/download/libtorrent-1_0_11/libtorrent-rasterbar-1.0.11.tar.gz cd libtorrent git checkout origin/RC_1_2 ./autotool.sh ./configure CXXFLAGS=-std=c++14 make clean \u0026\u0026 make -j$(nproc) make install 安装qbittorrent apt-get install qtbase5-dev qttools5-dev-tools libqt5svg5-dev zlib1g-dev wget https://github.com/qbittorrent/qBittorrent/archive/release-4.2.5 tar zxvf release-4.1.3.tar.gz cd qBittorrent-release-4.1.3/ ./configure --disable-gui make clean \u0026\u0026 make -j$(nproc) make install ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:1:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"LAMP php7.4安装 Ubuntu 18 安装 apt-get install software-properties-common 添加第三方源 add-apt-repository ppa:ondrej/php apt-get update 安装LAMP环境 sudo apt update sudo apt install apache2 mariadb-server libapache2-mod-php7.4 sudo apt install php7.4-gd php7.4-mysql php7.4-curl php7.4-mbstring php7.4-intl sudo apt install php7.4-gmp php7.4-bcmath php-imagick php7.4-xml php7.4-zip ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:2:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"LAMP php安装 Ubuntu 22 安装 apt-get install software-properties-common 添加第三方源 add-apt-repository ppa:ondrej/php apt-get update 安装LAMP环境 sudo apt update \u0026\u0026 sudo apt upgrade sudo apt install mariadb-server php-gd php-mysql php-fpm \\ php-curl php-mbstring php-intl php-gmp php-bcmath php-xml php-imagick php-zip ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:3:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"Neovim 安装 Ubuntu PPA安装 安装依赖软件 sudo apt-get install software-properties-common ## older ubuntu version sudo apt-get install python-software-properties 安装发布版本neovim sudo add-apt-repository ppa:neovim-ppa/stable sudo apt-get update sudo apt-get install neovim 编译安装 安装编译依赖 sudo apt-get install ninja-build gettext libtool libtool-bin autoconf automake cmake g++ pkg-config unzip curl doxygen 获取源代码 git clone https://github.com/neovim/neovim 编译安装neovim cd neovim make sudo make install 让neovim支持python和python3 sudo apt-get install python3 python3-pip python-pip -y pip install neovim pip3 install neovim ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:4:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"tmux 安装 Ubuntu 编译安装 获取源代码 wget https://github.com/tmux/tmux/releases/download/3.3-rc/tmux-3.3-rc.tar.gz 编译neovim tar -zxvf tmux-3.3-rc.tar.gz cd tmux-3.3-rc make sudo make install ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:5:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"transmission 安装 镜像安装 创建文件夹nextcloud mkdir transmission 创建文件docker-compose.yml --- version: \"2.1\" services: transmission: image: lscr.io/linuxserver/transmission container_name: transmission environment: - PUID=1000 - PGID=1000 - TZ=Europe/London - TRANSMISSION_WEB_HOME=/combustion-release/ #optional - USER=transmission #optional - PASS=passwd #optional #- WHITELIST=iplist #optional #- PEERPORT=peerport #optional #- HOST_WHITELIST=dnsnane list #optional volumes: - ./config:/config - ./downloads:/downloads - ./watch:/watch ports: - 9091:9091 - 51413:51413 - 51413:51413/udp restart: unless-stopped 启动镜像 sudo docker-compose up -d apt安装 安装 sudo apt update install transmission-daemon 修改配置文件 ... \"rpc-whitelist\": \"*\", \"rpc-whitelist-enabled\": true, ... web-ui安装 安装 wget https://github.com/ronggang/transmission-web-control/raw/master/release/install-tr-control-cn.sh bash install-tr-control-cn.sh ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:6:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"Selenium配置 [Webdriver驱动列表](Install browser drivers | Selenium) Windows 下载驱动 [Edge Webdriver](Microsoft Edge WebDriver - Microsoft Edge Developer) Chrome Webdriver 解压驱动到程序目录 mkdir selenium_test cd selenium_test 启动镜像 sudo docker-compose up -d ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:7:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"Jellyfin 安装 并启用硬件加速 apt安装 所有的Ubuntu发行版本 https://repo.jellyfin.org/releases/server/ubuntu/versions 查看当前的GPU设备 lspci -k | grep -A 2 -i \"VGA\" 禁用nouveau sudo vim /etc/modprobe.d/blacklist_nouveau.conf # 添加 blacklist nouveau options nouveau modeset=0 sudo reboot 搜索Nvidia显卡驱动 sudo ubuntu-drivers devices # 安装推荐的驱动 modalias : pci:v000010DEd00000FC2sv00001462sd0000275Cbc03sc00i00 vendor : NVIDIA Corporation model : GK107 [GeForce GT 630 OEM] driver : nvidia-driver-450-server - distro non-free #server版本的驱动 driver : nvidia-driver-470-server - distro non-free driver : nvidia-340 - distro non-free driver : nvidia-driver-418-server - distro non-free driver : nvidia-driver-470 - distro non-free recommended #gui版本的驱动 driver : nvidia-driver-390 - distro non-free driver : xserver-xorg-video-nouveau - distro free builtin 安装驱动 sudo apt install nvidia-driver-470-server #重启然后在jellyfin中设置Nvidia解码 镜像安装 创建文件夹jellyfin mkdir jellyfin 创建文件docker-compose.yml --- version: \"3.5\" services: jellyfin: image: nyanmisaka/jellyfin:latest container_name: jellyfin user: 1000:1000 network_mode: \"host\" volumes: - ./config:/config - ./cache:/cache - ./media:/media - /path/to/media2:/media2:ro restart: \"unless-stopped\" 启动镜像 sudo docker-compose up -d # 这种版本可能会导致apache2在转发端口的时候web存在不能访问服务器 ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:8:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"Nvidia驱动安装 Ubuntu 查看驱动 sudo dpkg --list | grep nvidia-* 卸载驱动 sudo /usr/bin/nvidia-uninstall sudo apt-get --purge remove nvidia-* sudo apt-get purge nvidia* sudo apt-get purge libnvidia* 检查驱动是否卸载 sudo dpkg --list | grep nvidia-* # 无任何输出 安装驱动 sudo ubuntu-drivers devices sudo apt install nvidia-driver-470-server ","date":"2022-05-19","objectID":"/posts/technology/compile_and_install/:9:0","tags":["软件编译","软件安装"],"title":"软件编译和安装","uri":"/posts/technology/compile_and_install/"},{"categories":["教程"],"content":"apache常见问题 ","date":"2022-05-03","objectID":"/posts/technology/apache2_and_nginx/:0:0","tags":["反向代理","网站证书"],"title":"web容器的使用和反向代理","uri":"/posts/technology/apache2_and_nginx/"},{"categories":["教程"],"content":"配置apache2文件简单服务器 打开配置文件 sudo vim /etc/apache2/sites-available/000-default.conf 修改内容为 Alias /e6ecni3_Sivan \"/var/www/html/\" \u003cDirectory /var/www/html/\"\u003e Require all granted AllowOverride All Options FollowSymLinks MultiViews \u003c/Directory\u003e 删除/var/www/html sudo rm -rf /var/www/html #软链html为你的共享文件目录 ","date":"2022-05-03","objectID":"/posts/technology/apache2_and_nginx/:0:1","tags":["反向代理","网站证书"],"title":"web容器的使用和反向代理","uri":"/posts/technology/apache2_and_nginx/"},{"categories":["教程"],"content":"访问apache2服务器默认指向index.php 删除浏览器的访问记录就可以 ","date":"2022-05-03","objectID":"/posts/technology/apache2_and_nginx/:0:2","tags":["反向代理","网站证书"],"title":"web容器的使用和反向代理","uri":"/posts/technology/apache2_and_nginx/"},{"categories":["教程"],"content":"在apache2中配置反向代理 反向代理服务器位于用户与目标服务器之间，但是对于用户而言，反向代理服务器就相当于目标服务器，即用户直接访问反向代理服务器就可以获得目标服务器的资源。同时，用户不需要知道目标服务器的地址，也无须在用户端作任何设定。反向代理服务器通常可用来作为Web加速，即使用反向代理作为Web服务器的前置机来降低网络和服务器的负载，提高访问效率。 其作用如下表示： 开启模块支持 sudo a2enmod rewrite sudo a2enmod lbmethod_byrequests sudo a2enmod proxy_balancer sudo a2enmod proxy_http sudo a2enmod proxy 添加反向代理设置 #sites-available/example.conf LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_http_module modules/mod_proxy_http.so \u003cVirtualHost *:80\u003e # The ServerName directive sets the request scheme, hostname and port that # the server uses to identify itself. This is used when creating # redirection URLs. In the context of virtual hosts, the ServerName # specifies what hostname must appear in the request's Host: header to # match this virtual host. For the default virtual host (this file) this # value is not decisive as it is used as a last resort host regardless. # However, you must set it for any further virtual host explicitly. #ServerName www.example.com ServerAdmin sivan@localhost # Para qbittorrent RewriteEngine on RewriteRule ^/torrent$ \"/torrent/$1\" [R] ProxyPass /torrent/ http://127.0.0.1:8080/ ProxyPassReverse /torrent/ http://127.0.0.1:8080/ # Available loglevels: trace8, ..., trace1, debug, info, notice, warn, # error, crit, alert, emerg. # It is also possible to configure the loglevel for particular # modules, e.g. #LogLevel info ssl:warn ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined # For most configuration files from conf-available/, which are # enabled or disabled at a global level, it is possible to # include a line for only one particular virtual host. For example the # following line enables the CGI configuration for this host only # after it has been globally disabled with \"a2disconf\". #Include conf-available/serve-cgi-bin.conf \u003c/VirtualHost\u003e # vim: syntax=apache ts=4 sw=4 sts=4 sr noet 启动服务 sudo a2ensite example.conf sudo service apache2 restart ","date":"2022-05-03","objectID":"/posts/technology/apache2_and_nginx/:0:3","tags":["反向代理","网站证书"],"title":"web容器的使用和反向代理","uri":"/posts/technology/apache2_and_nginx/"},{"categories":["教程"],"content":"apache 添加ssl证书并反向代理 开启ssl模块 sudo a2enmod ssl 配置证书site.conf LoadModule proxy_module modules/mod_proxy.so \u003cIfModule mod_ssl.c\u003e \u003cVirtualHost _default_:443\u003e ServerAdmin webmaster@localhost RewriteEngine on ProxyPass / http://127.0.0.1:8360/ ProxyPassReverse / http://127.0.0.1:8360/ ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined SSLEngine on SSLCertificateFile /etc/apache2/ssl/cloud.laais.cn.pem SSLCertificateKeyFile /etc/apache2/ssl/cloud.laais.cn.key SSLCertificateChainFile /etc/apache2/ssl/cloud.laais.cn.crt SSLCACertificatePath /etc/apache2/ssl SSLCACertificateFile /etc/apache2/ssl.crt/root_bundle.crt \u003c/VirtualHost\u003e \u003c/IfModule\u003e # vim: syntax=apache ts=4 sw=4 sts=4 sr noet ","date":"2022-05-03","objectID":"/posts/technology/apache2_and_nginx/:1:0","tags":["反向代理","网站证书"],"title":"web容器的使用和反向代理","uri":"/posts/technology/apache2_and_nginx/"},{"categories":["教程"],"content":"apache 配置websocket代理 LoadModule proxy_module modules/mod_proxy.so LoadModule proxy_http_module modules/mod_proxy_http.so \u003cVirtualHost *:80\u003e ServerName www.hfsurrogacy.com ServerAdmin webmaster@hfsurrogacy.com DocumentRoot /var/www/html \u003cDirectory /var/www/html\u003e AllowOverride All Require all granted \u003c/Directory\u003e ErrorLog ${APACHE_LOG_DIR}/error.log CustomLog ${APACHE_LOG_DIR}/access.log combined \u003cLocationMatch \"/web\"\u003e ProxyPass http://127.0.0.1:10086/web upgrade=WebSocket ProxyAddHeaders Off ProxyPreserveHost On RequestHeader set Host %{HTTP_HOST}s RequestHeader set X-Forwarded-For %{REMOTE_ADDR}s \u003c/LocationMatch\u003e \u003c/VirtualHost\u003e ","date":"2022-05-03","objectID":"/posts/technology/apache2_and_nginx/:2:0","tags":["反向代理","网站证书"],"title":"web容器的使用和反向代理","uri":"/posts/technology/apache2_and_nginx/"},{"categories":["教程"],"content":"阿里云ssl证书安装错误 根据阿里云的教程在Apache服务器上安装SSL证书 (aliyun.com) 1.在服务器上更新证书apache2会报错 （1）错误1：AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 127.0.1.1. Set the 'ServerName' directive globa 在apache.conf最后添加如下： ... # vim: syntax=apache ts=4 sw=4 sts=4 sr noet ServerName 127.0.0.1 （2）错误2：Action 'start' failed. 看日志提示SSL Library Error: error:0A0000B1:SSL routines::no certificate assigned 解决方案 下载这两处的文件然后把其他文件里面的pem文件更新到site.conf中 Nginx常见问题 ","date":"2022-05-03","objectID":"/posts/technology/apache2_and_nginx/:3:0","tags":["反向代理","网站证书"],"title":"web容器的使用和反向代理","uri":"/posts/technology/apache2_and_nginx/"},{"categories":["教程"],"content":"配置nginx反向代理和重定向 打开配置文件 sudo vim /etc/nginx/conf.d/jellyfin.conf 添加如下内容（访问http://host/video/.html 可反向代理重定向到http://host:8096/.html）： set $jellyfin 127.0.0.1; location /video { # Proxy main Jellyfin traffic rewrite ^/video/(.*)$ /$1 break; proxy_pass http://$jellyfin:8096; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Protocol $scheme; proxy_set_header X-Forwarded-Host $http_host; # Disable buffering when the nginx proxy gets very resource heavy upon streaming proxy_buffering off; } # location block for /web - This is purely for aesthetics so /web/#!/ works instead of having to go to /web/index.html/#!/ location = /video/web/ { # Proxy main Jellyfin traffic proxy_pass http://$jellyfin:8096/web/index.html; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_set_header X-Forwarded-Protocol $scheme; proxy_set_header X-Forwarded-Host $http_host; } ","date":"2022-05-03","objectID":"/posts/technology/apache2_and_nginx/:3:1","tags":["反向代理","网站证书"],"title":"web容器的使用和反向代理","uri":"/posts/technology/apache2_and_nginx/"},{"categories":["教程"],"content":"配置wordpress支持 打开配置文件 sudo vim /etc/nginx/sites-available/default 添加如下内容（支持.htaccess和php）： server { listen 80 default_server; listen [::]:80 default_server; # SSL configuration # # listen 443 ssl default_server; # listen [::]:443 ssl default_server; # # Note: You should disable gzip for SSL traffic. # See: https://bugs.debian.org/773332 # # Read up on ssl_ciphers to ensure a secure configuration. # See: https://bugs.debian.org/765782 # # Self signed certs generated by the ssl-cert package # Don't use them in a production server! # # include snippets/snakeoil.conf; root /var/www/html; # Add index.php to the list if you are using PHP index index.php index.html index.htm index.nginx-debian.html; server_name _; location / { # First attempt to serve request as file, then # as directory, then fall back to displaying a 404. try_files $uri $uri/ =404; # support .htaccess if (-f $request_filename/index.html){ rewrite (.*) $1/index.html break; } if (-f $request_filename/index.php){ rewrite (.*) $1/index.php; } if (!-f $request_filename){ rewrite (.*) /index.php; } } location /login { proxy_redirect off; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; set $is_v2ray 0; if ($http_upgrade = \"websocket\") { set $is_v2ray 1; } if ($is_v2ray = 1) { # 仅当请求为 WebSocket 时才反代到 V2Ray proxy_pass http://127.0.0.1:10086; } if ($is_v2ray = 0) { # 否则显示正常网页 rewrite ^/(.*)$ /mask-page last; } } # pass PHP scripts to FastCGI server # location ~ \\.php$ { include snippets/fastcgi-php.conf; # With php-fpm (or other unix sockets): fastcgi_pass unix:/run/php/php7.4-fpm.sock; } } ","date":"2022-05-03","objectID":"/posts/technology/apache2_and_nginx/:3:2","tags":["反向代理","网站证书"],"title":"web容器的使用和反向代理","uri":"/posts/technology/apache2_and_nginx/"},{"categories":["项目"],"content":"添加功能： ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:0","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"1.文件管理：插件NerdTree 打开文件管理：Crtl + N 退出文件管理：Crtl + C ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:1","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"2.跳转功能：Ctags\\pygments\\gtags 跳转到定义：Crtl + ] 后退：Crtl + T Ctrl+\\ c Find functions calling this function Ctrl+\\ d Find functions called by this function Ctrl+\\ e Find this egrep pattern Ctrl+\\ f Find this file Ctrl+\\ g Find this definition Ctrl+\\ i Find files #including this file Ctrl+\\ s Find this C symbol Ctrl+\\ t Find this text string ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:2","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"3.任意跳转功能，主要是和前一个功能进行补充；JumpAny 跳转到定义：cursor移动到关键词 , + j ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:3","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"4.搜索功能：LeaderF 打开搜索：, + f 结果上翻：Crtl + k 结果下翻：Crtl + j 打开：Enter 帮助：Tab ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:4","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"5.代码补全：Coc.nvim 打开搜索：在对应的关键词后面按tab会提示 结果下翻：提示后按Tab可以顺序下翻，或者用Crtl + n 结果上翻：提示后Crtl + p 选择：Enter ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:5","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"6.代码错误修正：Coc.nvim ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:6","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"7.单终端编译和写代码，不用Crtl-z切后台编译，直接借助tmux和vimux插件实现在一个界面写代码和编译 创建tmux：tmux session -t mytmux 分屏tmux：打开vim后输入, + v + p，输入相关的运行命令便可打开命令行 运行上一次的命令：需要先运行在, + v + p，然后在, + v + l便可以运行最后一次的命令 切换tmux：按Crtl + b 再按 hjkl 任意，例如向下切换则Crtl + b，然后按j，便可向下切换tmux ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:7","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"8.更加强大的终端zsh和on-my-zsh管理，支持主题和插件 ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:8","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"9.vim支持Latex保存自动编译，编译实时显示（Windows Vim Latex Live Preview） 编译latex：,lc 查看latex：,lv 删除latex相关缓存文件：,lr ","date":"2022-04-08","objectID":"/posts/projects/vim/:1:9","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"效果预览 Vim or Neovim ","date":"2022-04-08","objectID":"/posts/projects/vim/:2:0","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"Ubuntu安装方式 # 可在内部选择对应的版本 git clone https://github.com/SivanLaai/vimrc.git cd vimrc ./install.sh #TODO: 安装完成记得进入vim更新插件 vim-gui ","date":"2022-04-08","objectID":"/posts/projects/vim/:3:0","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"windows 1.下载安装vim-gui gVim 下载python编译版本gvim Neovim 下载python编译版本neovim 配置路径D:\\Program Files\\Neovim\\bin为系统环境变量 2.安装对应版本的Python GVim查看对应版本的Python 查看相关版本的python下载安装： 下载Python 3.安装字体 下载字体 DejaVu Sans Mono for Powerline 4.安装universal-ctags/pygments 和 gtags （1）universal-ctags 下载universal-ctags 将ctags拷贝到安装路径，如D:\\Program Files\\ctags 配置路径D:\\Program Files\\ctags为系统环境变量 （2）pygments（主要作用是配合ctags来查找引用） pip install pygments （3）gtags 下载gtags 将gtags拷贝到安装路径，如D:\\Program Files\\gtags 配置路径D:\\Program Files\\gtags为系统环境变量 5.安装ripgrep 下载ripgrep 将ripgrep程序拷贝到安装路径，如D:\\Program Files\\ripgrep 配置路径D:\\Program Files\\ripgrep为系统环境变量 6.安装Latex 下载miktex 安装mitex并更新 7.安装Okular 下载Okular 将Okular程序安装到路径，如D:\\Program Files\\Okular 配置路径D:\\Program Files\\Okular为系统环境变量 8.安装MSYS2 下载MSYS2 将MSYS2程序安装到路径，如D:\\Program Files\\MSYS2 配置路径D:\\Program Files\\MSYS2\\usr\\bin为系统环境变量 配置路径D:\\Program Files\\MSYS2\\clang4\\bin为系统环境变量 安装clang64 # 更新软件库 pacman -Syu # 更新核心软件 pacman -Su # 安装Clang64编译环境 pacman -S --needed base-devel mingw-w64-clang-x86_64-toolchain 下载git 将git程序安装到路径，如D:\\Program Files\\git 配置路径D:\\Program Files\\git\\bin为系统环境变量 git中文显示错误修正 git config --global core.quotepath false 想卸载某个包的话 pacman -Rs mingw-w64-clang-x86_64-toolchain 9.配置vim-format依赖 #C++ 通过Clang64已经成功支持 #Python pip install --upgrade autopep8 #html\\css\\js npm install -g js-beautify 10.复制配置文件 gVim cp -rf gvim/_vimrc $vim/_vimrc cp -rf gvim/autoload vimfile - NeoVim-qt cp -rf neovim-qt/* ~/AppData/Local/nvim # Solarized Dark 主题复制 cp -rf gvim/colors vimfile 11.配置vim-gui :PlugInstall #待安装完成 ","date":"2022-04-08","objectID":"/posts/projects/vim/:4:0","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"Xshell 护眼主题 Eyes Protection ","date":"2022-04-08","objectID":"/posts/projects/vim/:5:0","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"安装方式 在Xshell 配色方案里导入 本项目中的xcs文件 ","date":"2022-04-08","objectID":"/posts/projects/vim/:5:1","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["项目"],"content":"界面预览 Solarized Dark Solarized Light ","date":"2022-04-08","objectID":"/posts/projects/vim/:5:2","tags":["vim","tmux"],"title":"Vim/Neovim-Tmux 一键安装轻量级工作站","uri":"/posts/projects/vim/"},{"categories":["教程"],"content":"docker教程 ","date":"2022-04-02","objectID":"/posts/technology/docker/:0:0","tags":["docker"],"title":"docker教程","uri":"/posts/technology/docker/"},{"categories":["教程"],"content":"docker安装 卸载老版本docker sudo apt-get remove docker docker-engine docker.io containerd runc 设置apt仓库 1.更新apt包索引并且安装相关依赖允许apt使用https更新 sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 2.增加Docker官方GPG Key curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg 3.设置apt docker稳定仓库设置 echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 安装Docker引擎 1.更新apt包索引并且安装Docker引擎 sudo apt-get update sudo apt-get install docker-ce docker-ce-cli containerd.io 2.验证docker是否成功安装 sudo docker run hello-world 3.设置apt docker稳定仓库设置 echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 参考文档 Install Docker Engine on Ubuntu | Docker Documentation ","date":"2022-04-02","objectID":"/posts/technology/docker/:1:0","tags":["docker"],"title":"docker教程","uri":"/posts/technology/docker/"},{"categories":["教程"],"content":"Docker Compose安装 ","date":"2022-04-02","objectID":"/posts/technology/docker/:2:0","tags":["docker"],"title":"docker教程","uri":"/posts/technology/docker/"},{"categories":["教程"],"content":"Linux 安装Docker Compose 1.下载docker compose可执行文件 sudo curl -L \"https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 2.设置可执行权限 sudo chmod +x /usr/local/bin/docker-compose ","date":"2022-04-02","objectID":"/posts/technology/docker/:2:1","tags":["docker"],"title":"docker教程","uri":"/posts/technology/docker/"},{"categories":["教程"],"content":"qBittorrent Docker运行 ","date":"2022-04-02","objectID":"/posts/technology/docker/:3:0","tags":["docker"],"title":"docker教程","uri":"/posts/technology/docker/"},{"categories":["教程"],"content":"Docker Compose 配置qBittorrent 新建项目 1.进入home目录，新建项目qBittorrent cd ~ mkdir qBittorrent cd qBittorrent 2.进入项目文件目录，新建配置文件docker-compose.yml，配置下载端口，qBittorrent相关目录 version: \"3\" services: qbittorrent: image: emmercm/qbittorrent:latest restart: unless-stopped ports: - 8080:8080 - 5463:5463/tcp - 5463:5463/udp volumes: - ./config:/config - ./data:/data - ./downloads:/downloads - ./incomplete:/incomplete 运行项目 1.下载并创建镜像 docker-compose up 2.运行镜像 docker-compose start ","date":"2022-04-02","objectID":"/posts/technology/docker/:3:1","tags":["docker"],"title":"docker教程","uri":"/posts/technology/docker/"},{"categories":["学习"],"content":"2021秋作业2-动态规划 ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/:0:0","tags":["算法学习","卜东坡-算法设计与分析","动态规划"],"title":"卜东坡算法-2021秋作业2-动态规划","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/"},{"categories":["学习"],"content":"1. Money robbing A robber is planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. What if all houses are arranged in a circle? 解法： class Solution { public: int robMaxMoney(vector\u003cint\u003e\u0026 a) { int start = 0; int end = a.size() - 1; vector\u003cint\u003e dp(end, 0); //初始化dp全部为0，dp表示前i+1个房子抢劫的最大金钱数 dp[0] = a[0]; dp[1] = max(a[0], a[1]); for (int i = 2; i \u003c= end; ++i) { dp[i] = max(dp[i - 1], dp[i - 2] + a[i]); } return dp[end]; } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/:1:0","tags":["算法学习","卜东坡-算法设计与分析","动态规划"],"title":"卜东坡算法-2021秋作业2-动态规划","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/"},{"categories":["学习"],"content":"2. Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si , Sj ) of elements in this subset satisfies: Si%Sj = 0 or Sj%Si = 0. Please return the largest size of the subset. Note: Si%Sj = 0 means that Si is divisible by Sj . 解法： class Solution { public: int getLargestDivisibleSum(vector\u003cint\u003e\u0026 nums) { quickSort(nums); //先使用快速排序对数组从小到大进行排序 int size = nums.size(); vector\u003cint\u003e dp(size, 1); //初始化dp全部为1，dp表示前i个数元素最多的可整除子集长度 for (int i = 2; i \u003c= size; ++i) { for (int j = 1; j \u003c i; ++j) { if (nums[i] % nums[j] == 0) { dp[i] = max(dp[i], dp[j] + 1); } } } } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/:2:0","tags":["算法学习","卜东坡-算法设计与分析","动态规划"],"title":"卜东坡算法-2021秋作业2-动态规划","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/"},{"categories":["学习"],"content":"3. Unique Binary Search Trees Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? Explanation: Given n = 3, there are a total of 5 unique BST’s: class Solution { public: int getBSTSum(const int\u0026 n) { vector\u003cint\u003e dp(n, 0); dp[0] = dp[1] = 1; for (int i=2; i \u003c= n; ++i) { for (int j=0; j \u003c i; ++j) { dp[i] += dp[j] * dp[i - j - 1]; } } } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/:3:0","tags":["算法学习","卜东坡-算法设计与分析","动态规划"],"title":"卜东坡算法-2021秋作业2-动态规划","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/"},{"categories":["学习"],"content":"4. Word Break Given a string S and a dictionary of words, determine if the string S can be segmented into a space-separated sequence of one or more dictionary words. Note: Each word in the dictionary may be reused multiple times in the segmentation. You can return TRUE if the string S is empty. class Solution { public: bool wordBreak(string s, vector\u003cstring\u003e\u0026 wordDict) { int n = s.size(); vector\u003cbool\u003e dp(n, false); dp[0] = true; for (int i = 1; i \u003c= n; ++i) { for (auto str: wordDict) { int str_len = str.size(); if (i \u003e= str_len) { dp[i] = (dp[i - str_len] // 表示前 i - str_len个字符是否由wordDict单词组成 \u0026\u0026 s.substr(i - str_len, str_len) == str) // i - str_len到i是否组成一个单词 || dp[i]; // dp[i]表示前s的前i个字符是否由wordDict的单词组成，只要找到一个dp[i]满足，则dp[i]就是 } } } return dp[n]; } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/:4:0","tags":["算法学习","卜东坡-算法设计与分析","动态规划"],"title":"卜东坡算法-2021秋作业2-动态规划","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/"},{"categories":["学习"],"content":"5. Distinct Sequences Given two strings S and T, return the number of distinct subsequences of S which equals T. A string’s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters’ relative positions. (i.e., ”ACE” is a subsequence of ”ABCDE” while ”AEC” is not). Example 1: Input: s = \"rabbbit\", t = \"rabbit\" Output: 3 Explanation: As shown below, there are 3 ways you can generate \"rabbit\" from S. rabbbit rabbbit rabbbit Example 2: Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. babgbag babgbag babgbag babgbag babgbag class Solution { public: int numDistinct(string s, string t) { int n = s.size(); int m = t.size(); vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(m + 1, 0)); for (int i=0; i\u003c=n; ++i) dp[i][0] = 1; for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= m; ++j) { if (s[i] == t[j]) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];// 两种情况之和 } else { dp[i][j] = dp[i - 1][j];// 如果当前字符不相等，则说明s的前i个字符和t的前j个字符的字集个数会 等于 s的前i-1个字符和t的前j个字符的个数 } } } return dp[n][m]; } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/:5:0","tags":["算法学习","卜东坡-算法设计与分析","动态规划"],"title":"卜东坡算法-2021秋作业2-动态规划","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/"},{"categories":["学习"],"content":"6. Triangle Description Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i +1on the next row. Input Line1: The height of the triangle, and 1 \u003c= triangle.height \u003c= 2001\u003c=triangl**e.heigh**t\u003c=200. Line2: All the elements in the triangle, and split by some spaces(for each element,-10^4\u003c= triangle[i][j] \u003c=10^4). We are sure that the number of the elements satisfy: Output Print the minimum path sum from top to bottom. Sample Input 1 4 2 3 4 6 5 7 4 1 8 3 Sample Output 1 11 Sample Input 2 1 -10 Sample Output 2 -10 Hint Input: 4 2 3 4 6 5 7 4 1 8 3 Output: 11 Explanation: The triangle looks like: 2 34 657 4183 The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (bolded above) class Solution { public: int miniPathSum(const vector\u003cvector\u003cint\u003e\u003e\u0026 triangles) { int n = triangles.size(); vector\u003cint\u003e dp(n + 1, 0); for (int i=n; i\u003e=1; --i) { for (int j=1; j\u003c=i; ++j) { dp[j - 1] = min(dp[j - 1], dp[j]) + triangles[i][j]; } } return dp[0]; } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/:6:0","tags":["算法学习","卜东坡-算法设计与分析","动态规划"],"title":"卜东坡算法-2021秋作业2-动态规划","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/"},{"categories":["学习"],"content":"7. Maximum Alternating Subsequence Sum Description The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices. For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4. Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence). A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements’ relative order.For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not. Input Anarray. 1 \u003c= nums.length \u003c= 10^51\u003c=num**s.lengt**h\u003c=105 1 \u003c= nums[i] \u003c= 10^51\u003c=num**s[i]\u003c=105 Output Maximum alternating sum. Sample Input 1 5 6 7 8 Sample Output 1 8 Explanation: It is optimal to choose the subsequence [8] with alternating sum 8. Sample Input 2 6 2 1 2 4 5 Sample Output 2 10 Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10. Sample Input 3 4 2 5 3 Sample Output 3 7 Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7. class Solution { public: int maxAlternatingSum(const vector\u003cint\u003e\u0026 nums) { int n = nums.size(); vector\u003cvector\u003cint\u003e\u003e dp(n + 1, 0); // dp[i][0] 表示前i个数组成的子序列末位为偶数的最大交替和，dp[i][1]表示子序列末位为奇数的最大交替和。 dp[1][1] = nums[0]; // 前i个数末位为奇数的时候最大和 for (int i=1; i\u003c=n; ++i) { dp[i][0] = max(dp[i-1][0], dp[i-1][1] - nums[i-1]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]); // 前i个数交替和最大末位是奇数的情况，所以要考虑前i-1个数分别为奇和偶的情况。 } return max(dp[n][0], dp[n][1]); } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/:7:0","tags":["算法学习","卜东坡-算法设计与分析","动态规划"],"title":"卜东坡算法-2021秋作业2-动态规划","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/dynamic_programing/"},{"categories":["学习"],"content":"2021秋作业2-动态规划 ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/:0:0","tags":["算法学习","卜东坡-算法设计与分析","贪心"],"title":"卜东坡算法-2021秋作业3-贪心","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/"},{"categories":["学习"],"content":"1. Money robbing A robber is planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security system connected and it will automatically contact the police if two adjacent houses were broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. What if all houses are arranged in a circle? 解法： class Solution { public: int robMaxMoney(vector\u003cint\u003e\u0026 a) { int start = 0; int end = a.size() - 1; vector\u003cint\u003e dp(end, 0); //初始化dp全部为0，dp表示前i+1个房子抢劫的最大金钱数 dp[0] = a[0]; dp[1] = max(a[0], a[1]); for (int i = 2; i \u003c= end; ++i) { dp[i] = max(dp[i - 1], dp[i - 2] + a[i]); } return dp[end]; } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/:1:0","tags":["算法学习","卜东坡-算法设计与分析","贪心"],"title":"卜东坡算法-2021秋作业3-贪心","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/"},{"categories":["学习"],"content":"2. Largest Divisible Subset Given a set of distinct positive integers, find the largest subset such that every pair (Si , Sj ) of elements in this subset satisfies: Si%Sj = 0 or Sj%Si = 0. Please return the largest size of the subset. Note: Si%Sj = 0 means that Si is divisible by Sj . 解法： class Solution { public: int getLargestDivisibleSum(vector\u003cint\u003e\u0026 nums) { quickSort(nums); //先使用快速排序对数组从小到大进行排序 int size = nums.size(); vector\u003cint\u003e dp(size, 1); //初始化dp全部为1，dp表示前i个数元素最多的可整除子集长度 for (int i = 2; i \u003c= size; ++i) { for (int j = 1; j \u003c i; ++j) { if (nums[i] % nums[j] == 0) { dp[i] = max(dp[i], dp[j] + 1); } } } } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/:2:0","tags":["算法学习","卜东坡-算法设计与分析","贪心"],"title":"卜东坡算法-2021秋作业3-贪心","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/"},{"categories":["学习"],"content":"3. Unique Binary Search Trees Given n, how many structurally unique BST’s (binary search trees) that store values 1…n? Explanation: Given n = 3, there are a total of 5 unique BST’s: class Solution { public: int getBSTSum(const int\u0026 n) { vector\u003cint\u003e dp(n, 0); dp[0] = dp[1] = 1; for (int i=2; i \u003c= n; ++i) { for (int j=0; j \u003c i; ++j) { dp[i] += dp[j] * dp[i - j - 1]; } } } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/:3:0","tags":["算法学习","卜东坡-算法设计与分析","贪心"],"title":"卜东坡算法-2021秋作业3-贪心","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/"},{"categories":["学习"],"content":"4. Word Break Given a string S and a dictionary of words, determine if the string S can be segmented into a space-separated sequence of one or more dictionary words. Note: Each word in the dictionary may be reused multiple times in the segmentation. You can return TRUE if the string S is empty. class Solution { public: bool wordBreak(string s, vector\u003cstring\u003e\u0026 wordDict) { int n = s.size(); vector\u003cbool\u003e dp(n, false); dp[0] = true; for (int i = 1; i \u003c= n; ++i) { for (auto str: wordDict) { int str_len = str.size(); if (i \u003e= str_len) { dp[i] = (dp[i - str_len] // 表示前 i - str_len个字符是否由wordDict单词组成 \u0026\u0026 s.substr(i - str_len, str_len) == str) // i - str_len到i是否组成一个单词 || dp[i]; // dp[i]表示前s的前i个字符是否由wordDict的单词组成，只要找到一个dp[i]满足，则dp[i]就是 } } } return dp[n]; } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/:4:0","tags":["算法学习","卜东坡-算法设计与分析","贪心"],"title":"卜东坡算法-2021秋作业3-贪心","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/"},{"categories":["学习"],"content":"5. Distinct Sequences Given two strings S and T, return the number of distinct subsequences of S which equals T. A string’s subsequence is a new string formed from the original string by deleting some (can be none) of the characters without disturbing the remaining characters’ relative positions. (i.e., ”ACE” is a subsequence of ”ABCDE” while ”AEC” is not). Example 1: Input: s = \"rabbbit\", t = \"rabbit\" Output: 3 Explanation: As shown below, there are 3 ways you can generate \"rabbit\" from S. rabbbit rabbbit rabbbit Example 2: Input: s = \"babgbag\", t = \"bag\" Output: 5 Explanation: As shown below, there are 5 ways you can generate \"bag\" from S. babgbag babgbag babgbag babgbag babgbag class Solution { public: int numDistinct(string s, string t) { int n = s.size(); int m = t.size(); vector\u003cvector\u003cint\u003e\u003e dp(n + 1, vector\u003cint\u003e(m + 1, 0)); for (int i=0; i\u003c=n; ++i) dp[i][0] = 1; for (int i = 1; i \u003c= n; ++i) { for (int j = 1; j \u003c= m; ++j) { if (s[i] == t[j]) { dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];// 两种情况之和 } else { dp[i][j] = dp[i - 1][j];// 如果当前字符不相等，则说明s的前i个字符和t的前j个字符的字集个数会 等于 s的前i-1个字符和t的前j个字符的个数 } } } return dp[n][m]; } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/:5:0","tags":["算法学习","卜东坡-算法设计与分析","贪心"],"title":"卜东坡算法-2021秋作业3-贪心","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/"},{"categories":["学习"],"content":"6. Triangle Description Given a triangle array, return the minimum path sum from top to bottom. For each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i +1on the next row. Input Line1: The height of the triangle, and 1 \u003c= triangle.height \u003c= 2001\u003c=triangl**e.heigh**t\u003c=200. Line2: All the elements in the triangle, and split by some spaces(for each element,-10^4\u003c= triangle[i][j] \u003c=10^4). We are sure that the number of the elements satisfy: Output Print the minimum path sum from top to bottom. Sample Input 1 4 2 3 4 6 5 7 4 1 8 3 Sample Output 1 11 Sample Input 2 1 -10 Sample Output 2 -10 Hint Input: 4 2 3 4 6 5 7 4 1 8 3 Output: 11 Explanation: The triangle looks like: 2 34 657 4183 The minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (bolded above) class Solution { public: int miniPathSum(const vector\u003cvector\u003cint\u003e\u003e\u0026 triangles) { int n = triangles.size(); vector\u003cint\u003e dp(n + 1, 0); for (int i=n; i\u003e=1; --i) { for (int j=1; j\u003c=i; ++j) { dp[j - 1] = min(dp[j - 1], dp[j]) + triangles[i][j]; } } return dp[0]; } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/:6:0","tags":["算法学习","卜东坡-算法设计与分析","贪心"],"title":"卜东坡算法-2021秋作业3-贪心","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/"},{"categories":["学习"],"content":"7. Maximum Alternating Subsequence Sum Description The alternating sum of a 0-indexed array is defined as the sum of the elements at even indices minus the sum of the elements at odd indices. For example, the alternating sum of [4,2,5,3] is (4 + 5) - (2 + 3) = 4. Given an array nums, return the maximum alternating sum of any subsequence of nums (after reindexing the elements of the subsequence). A subsequence of an array is a new array generated from the original array by deleting some elements (possibly none) without changing the remaining elements’ relative order.For example, [2,7,4] is a subsequence of [4,2,3,7,2,1,4] (the underlined elements), while [2,4,2] is not. Input Anarray. 1 \u003c= nums.length \u003c= 10^51\u003c=num**s.lengt**h\u003c=105 1 \u003c= nums[i] \u003c= 10^51\u003c=num**s[i]\u003c=105 Output Maximum alternating sum. Sample Input 1 5 6 7 8 Sample Output 1 8 Explanation: It is optimal to choose the subsequence [8] with alternating sum 8. Sample Input 2 6 2 1 2 4 5 Sample Output 2 10 Explanation: It is optimal to choose the subsequence [6,1,5] with alternating sum (6 + 5) - 1 = 10. Sample Input 3 4 2 5 3 Sample Output 3 7 Explanation: It is optimal to choose the subsequence [4,2,5] with alternating sum (4 + 5) - 2 = 7. class Solution { public: int maxAlternatingSum(const vector\u003cint\u003e\u0026 nums) { int n = nums.size(); vector\u003cvector\u003cint\u003e\u003e dp(n + 1, 0); // dp[i][0] 表示前i个数组成的子序列末位为偶数的最大交替和，dp[i][1]表示子序列末位为奇数的最大交替和。 dp[1][1] = nums[0]; // 前i个数末位为奇数的时候最大和 for (int i=1; i\u003c=n; ++i) { dp[i][0] = max(dp[i-1][0], dp[i-1][1] - nums[i-1]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] + nums[i-1]); // 前i个数交替和最大末位是奇数的情况，所以要考虑前i-1个数分别为奇和偶的情况。 } return max(dp[n][0], dp[n][1]); } }; ","date":"2022-03-02","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/:7:0","tags":["算法学习","卜东坡-算法设计与分析","贪心"],"title":"卜东坡算法-2021秋作业3-贪心","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/greedy/"},{"categories":["教程"],"content":"mysql数据库 ","date":"2022-02-25","objectID":"/posts/technology/mysql/:1:0","tags":["mysql","数据库"],"title":"数据库配置","uri":"/posts/technology/mysql/"},{"categories":["教程"],"content":"mysql忘记密码 （1）修改配置文件免密 sudo vim /etc/mysql/my.cnf [mysqld] skip-grant-tables （2）重启mysql sudo service mysql restart （3）修改初始密码 mysql -u root use mysql; update user set password=password(\"test@123\") where user=\"root\"; ","date":"2022-02-25","objectID":"/posts/technology/mysql/:1:1","tags":["mysql","数据库"],"title":"数据库配置","uri":"/posts/technology/mysql/"},{"categories":["教程"],"content":"mysql root帐号不能登录 （1）修改配置文件免密 看mysql忘记密码的第一步 （2）更新ip访问权限 flush privileges; alter user 'root'@'localhost' identified by 'test@123'; flush privileges; commit; ","date":"2022-02-25","objectID":"/posts/technology/mysql/:1:2","tags":["mysql","数据库"],"title":"数据库配置","uri":"/posts/technology/mysql/"},{"categories":["教程"],"content":"mysql 创建数据库 CREATE DATABASE IF NOT EXISTS nextcloud CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; ","date":"2022-02-25","objectID":"/posts/technology/mysql/:1:3","tags":["mysql","数据库"],"title":"数据库配置","uri":"/posts/technology/mysql/"},{"categories":["教程"],"content":"mysql 创建用户开启外网权限 打开配置文件 sudo vim /etc/mysql/my.cnf 修改绑定ip [mysqld] bind-address=0.0.0.0 具体命令 CREATE USER 'username'@'%' IDENTIFIED BY 'password'; # 所有的数据库都可以在外网访问 GRANT ALL PRIVILEGES ON *.* TO 'username'@'%'; FLUSH PRIVILEGES; ","date":"2022-02-25","objectID":"/posts/technology/mysql/:1:4","tags":["mysql","数据库"],"title":"数据库配置","uri":"/posts/technology/mysql/"},{"categories":["学习"],"content":"2021秋作业1-分治 ","date":"2021-12-17","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/:0:0","tags":["算法学习","卜东坡-算法设计与分析","分治"],"title":"卜东坡算法-2021秋作业1-分治","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/"},{"categories":["学习"],"content":"1. 找出整数数组中第K大的数 215.Kth Largest Element in an Array (Medium) Given an integer array nums and an integer k, please return the k-th largest element in the array. Your algorithm’s runtime complexity must be in the order of O(n), prove the correctnes-sand analyze the complexity.(k is much smaller than n, n is the length of the array.) Example 1: Input: nums = [3,2,1,5,6,4], k = 2 Output: 5 Example 2: Input: nums = [3,2,3,1,2,4,5,5,6], k = 4 Output: 4 Constraints: 1 \u003c= k \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 Solution: class Solution { public: int findKthLargest(vector\u003cint\u003e\u0026 nums, int k) { int idx = 0; vector\u003cint\u003e numL; vector\u003cint\u003e numR; for (int i = idx + 1; i \u003c nums.size(); i++) { if (nums[i] \u003e nums[idx]) { numR.push_back(nums[i]); } else { numL.push_back(nums[i]); } } if (numR.size() == k - 1) { return nums[idx]; } else if (numR.size() \u003e k - 1) { return findKthLargest(numR, k); } else { return findKthLargest(numL, k - numR.size() - 1); } } }; （Page55）Complexity: 如果子实例处在$[n(\\frac 34) ^{j + 1} + 1, n(\\frac 34) ^{j}]$则说明 算法运行在第$j$期，$X$表示算法整体的元素比较次数，$X_j$表示运行过程处于第j期时的比较次数，则有： ​ $$X = X_0 + X_1 + X_2 + \\dots$$ 选择中间区域的概率为$\\frac 12$，选择一个中间区域的元素作为中心元后，实例规模减少$\\frac 1 4$，因为每一期递归调用期望是两次，则在第$j$期的时候算法期望比较次数为$2n(\\frac{3}{4})^j$，则整体的期望比较次数为： ​ $$E(X)=E[X_0 +X_1+X_2+\\dots] \\leq \\sum_j 2cn (\\frac 34)^j \\leq 8cn$$ 则时间复杂度为$O(n)$。 ","date":"2021-12-17","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/:1:0","tags":["算法学习","卜东坡-算法设计与分析","分治"],"title":"卜东坡算法-2021秋作业1-分治","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/"},{"categories":["学习"],"content":"2. 二叉树邻域最小值 Consider an $n$-node complete binary tree $T$, where $n = 2^d − 1$ for some $d$. Each node $v$ of $T$ is labeled with a real number $x_v$. You may assume that the real numbers labeling the nodes are all distinct. A node $v$ of $T$ is a local minimum if the label $x_v$ is less than the label $x_w$ for all nodes $w$ that are joined to v by an edge. You are given such a complete binary tree T, but the labeling is only specified in the following: implicit way: for each node v, you can determine the value xv by probing the node v. Show how to find a local minimum of T using only O(logn) probes to the nodes of T. 解法： ","date":"2021-12-17","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/:2:0","tags":["算法学习","卜东坡-算法设计与分析","分治"],"title":"卜东坡算法-2021秋作业1-分治","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/"},{"categories":["学习"],"content":"3. 数组子数组最大和 1800.Maximum Ascending Subarray Sum (Easy) Given an integer array, one or more consecutive integers in the array form a sub-array. Find the maximum value of the sum of all subarrays. Please give an algorithm with O(nlogn) complexity class Solution { public: int findLargestSubArraySum(vector\u003cint\u003e\u0026 nums, int start, int end) { if (start == end) { return nums[start]; } else if (start \u003e end) { return -1; } int mid = (start + end) / 2; int subStart = mid; int subSum = nums[mid]; while (subStart \u003e start \u0026\u0026 nums[subStart] - 1 == nums[subStart - 1]) { subStart--; subSum += nums[subStart]; } int subEnd = mid; while (subEnd \u003c end \u0026\u0026 nums[subEnd] + 1 == nums[subEnd + 1]) { subEnd++; subSum += nums[subEnd]; } int subLSum = findLargestSubArraySum(nums, start, subStart - 1); int subRSum = findLargestSubArraySum(nums, subEnd + 1, end); return max(max(subSum, subLSum), subRSum); } }; ","date":"2021-12-17","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/:3:0","tags":["算法学习","卜东坡-算法设计与分析","分治"],"title":"卜东坡算法-2021秋作业1-分治","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/"},{"categories":["学习"],"content":"4. 查找有序数组指定元素的区间 34.find-first-and-last-position-of-element-in-sorted-array (Medium) Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value. If target is not found in the array, return [-1, -1]. You must write an algorithm with O(log n) runtime complexity. Example 1: Input: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2: Input: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Example 3: Input: nums = [], target = 0 Output: [-1,-1] class Solution { public: vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) { int l = findFisrt(nums, target); int h = findFisrt(nums, target + 1); if (l == nums.size() || nums[l] != target) { return vector\u003cint\u003e {-1, -1}; } return vector\u003cint\u003e {l, h - 1}; } int findFisrt(vector\u003cint\u003e\u0026 nums, int target) { int l = 0; int h = nums.size(); while (l \u003c h) { int mid = (l + h) / 2; if (nums[mid] \u003e= target) { h = mid; } else { l = mid + 1; } } return l; } }; ","date":"2021-12-17","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/:4:0","tags":["算法学习","卜东坡-算法设计与分析","分治"],"title":"卜东坡算法-2021秋作业1-分治","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/"},{"categories":["学习"],"content":"5. 求N多边形可以被切割成多少个三角形 Given a convex polygon with n vertices, we can divide it into several separated pieces, such that every piece is a triangle. When n = 4, there are two different ways to divide the polygon; When n = 5, there are five different ways. Give an algorithm that decides how many ways we can divide a convex polygon with n vertices into triangles. ","date":"2021-12-17","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/:5:0","tags":["算法学习","卜东坡-算法设计与分析","分治"],"title":"卜东坡算法-2021秋作业1-分治","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/"},{"categories":["学习"],"content":"6. 归并K个长度为N的有序链表 Given an array of k linked-lists lists, each linked-list is sorted in ascending order. Given an O(knlogk) algorithm to merge all the linked-lists into one sorted linked-list. (Note that the length of a linked-lists is n) class Solution { public: ListNode* mergeKLists(vector\u003cListNode*\u003e\u0026 lists) { return helpMergeKLists(lists, 0, lists.size() - 1); } ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { ListNode* head = new ListNode(-1); ListNode* p = head; while (l1 != NULL || l2 != NULL) { if (l1 == NULL \u0026\u0026 l2 != NULL) { p-\u003enext = l2; l2 = l2-\u003enext; } if (l1 != NULL \u0026\u0026 l2 == NULL) { p-\u003enext = l1; l1 = l1-\u003enext; } if (l1 != NULL \u0026\u0026 l2 != NULL) { p-\u003enext = l1-\u003eval \u003e l2-\u003eval ? l2 : l1; l1-\u003eval \u003e l2-\u003eval ? l2 = l2-\u003enext : l1 = l1-\u003enext; } p = p-\u003enext; } return head-\u003enext; } ListNode* helpMergeKLists(vector\u003cListNode*\u003e\u0026 lists, const int\u0026 start, const int\u0026 end) { if (start \u003e end) { return NULL; } else if (start == end) { return lists[start]; } int mid = (start + end) / 2; ListNode* l1 = helpMergeKLists(lists, start, mid); ListNode* l2 = helpMergeKLists(lists, mid + 1, end); return mergeTwoLists(l1, l2); } }; ","date":"2021-12-17","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/:6:0","tags":["算法学习","卜东坡-算法设计与分析","分治"],"title":"卜东坡算法-2021秋作业1-分治","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/"},{"categories":["学习"],"content":"7.Fast Mod Exponentiation Description Bob has encountered a difficult problem, and hope you design an algorithm to calculate pow(a,b) mod 1337, where a is a positive integer, b is a very large positive integer and will be given in the form of an array. For example, pow(2,3) mod 1337 is 8. 1 \\le a \\le 2^{31} - 1,1≤a≤231−1, 1 \\le b.length \\le 2000,1≤b.lengt**h≤2000, 0 \\le b[i] \\le 90≤b[i]≤9 bb doesn’t contain leading zeros. Please give an algorithm with O(\\log n)O(logn) complexity. Input Line 1: integers Line 2: an array Output One integer Sample Input 1 2 [3] Sample Output 1 8 Sample Input 2 4 [3,5] Sample Output 2 709 Sample Input 3 222222222 [4,0,0] Sample Output 3 1171 #include \u003cstdio.h\u003e #define MOD_VALUE 1337 int size = 0; int start = 0; int count = 0; int array[2000]; void arrayHalfDivide() { array[size - 1] = array[size - 1] / 2; int i = size - 2; while (i \u003e= start) { int curr = array[i] * 5; array[i] = curr / 10; array[i + 1] += curr % 10; --i; } if (array[start] == 0 \u0026\u0026 count \u003e 1) { count--; start++; } } int clacFastModExponentation(int base) { if (count == 1 \u0026\u0026 array[size - 1] == 0) { return 1; } if (count == 1 \u0026\u0026 array[size - 1] == 1) { return base % MOD_VALUE; } int sumMod = 1; if (array[size - 1] % 2 != 0) { array[size - 1] = array[size - 1] - 1; sumMod *= (base % MOD_VALUE); } arrayHalfDivide(); int currMod = clacFastModExponentation(base) % MOD_VALUE; sumMod *= (currMod * currMod) % MOD_VALUE; return sumMod % MOD_VALUE; } int main() { int base; scanf(\"%d\", \u0026base); char ch; while ((ch = getchar()) \u0026\u0026 ch != ']') { if (ch \u003e= '0' \u0026\u0026 ch \u003c= '9') { array[size++] = ch - '0'; count++; } } printf(\"%d\\n\", clacFastModExponentation(base)); return 0; } ","date":"2021-12-17","objectID":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/:7:0","tags":["算法学习","卜东坡-算法设计与分析","分治"],"title":"卜东坡算法-2021秋作业1-分治","uri":"/posts/learning/ucas_pu_2021_algorithm_assignment/conquer_divide/"},{"categories":["问题总结"],"content":"1.ModuleNotFoundError: No module named ‘_lzma’ ","date":"2021-10-05","objectID":"/posts/technology/pytorch/:1:0","tags":["pytorch"],"title":"pytorch使用问题","uri":"/posts/technology/pytorch/"},{"categories":["问题总结"],"content":"Ubuntu （1）安装依赖 apt-get install liblzma-dev -y pip install backports.lzma （2）打开lzma.py vim ~/a/b/python3.7/lzma.py （3）修改代码 #修改前 from _lzma import * from _lzma import _encode_filter_properties, _decode_filter_properties #修改后 try: from _lzma import * from _lzma import _encode_filter_properties, _decode_filter_properties except ImportError: from backports.lzma import * from backports.lzma import _encode_filter_properties, _decode_filter_properties ","date":"2021-10-05","objectID":"/posts/technology/pytorch/:1:1","tags":["pytorch"],"title":"pytorch使用问题","uri":"/posts/technology/pytorch/"},{"categories":["教程"],"content":"安装Latex ","date":"2021-10-05","objectID":"/posts/technology/latex/:1:0","tags":["latex"],"title":"安装latex","uri":"/posts/technology/latex/"},{"categories":["教程"],"content":"Windows WSL （1）安装WSL 配置WSL wsl --install 安装WSL-Ubuntu 18.04 wsl --install -d Ubuntu-18.04 #等待安装完成 启动Ubuntu wsl bash （2）安装TexLive 在线安装 sudo apt install texlive-full 装载Tex的ISO镜像安装 sudo mkdir /mnt/img sudo mount -t drvfs G: /mnt/img sudo mnt/img/install-tl （3）配置环境变量使得powershell上可以直接使用 sudo /usr/local/texlive/2020/bin/x86_64-linux/tlmgr path add （4）配置WSL使用windows字体 sudo apt install fontconfig 创建/etc/fonts/local.conf \u003c?xml version=\"1.0\"?\u003e \u003c!DOCTYPE fontconfig SYSTEM \"fonts.dtd\"\u003e \u003cfontconfig\u003e \u003cdir\u003e/mnt/c/Windows/Fonts\u003c/dir\u003e \u003c/fontconfig\u003e ","date":"2021-10-05","objectID":"/posts/technology/latex/:1:1","tags":["latex"],"title":"安装latex","uri":"/posts/technology/latex/"},{"categories":["教程"],"content":"Mongodb安装 （1）导入公匙 wget -qO - https://www.mongodb.org/static/pgp/server-5.0.asc | sudo apt-key add - （2）创建mongodb列表文件 echo \"deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu bionic/mongodb-org/5.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-5.0.list （3）重新加载包数据 sudo apt-get update （4）重新加载包数据 sudo apt-get install -y mongodb-org=5.0.2 mongodb-org-database=5.0.2 mongodb-org-server=5.0.2 mongodb-org-shell=5.0.2 mongodb-org-mongos=5.0.2 mongodb-org-tools=5.0.2 （5）服务启动 sudo systemctl start mongod Mongodb配置修改 （1）打开配置 sudo vim /etc/mongod.conf （2）修改配置 # mongod.conf # for documentation of all options, see: # http://docs.mongodb.org/manual/reference/configuration-options/ # Where and how to store data. storage: dbPath: /var/lib/mongodb journal: enabled: true # engine: # wiredTiger: # where to write logging data. systemLog: destination: file logAppend: true path: /var/log/mongodb/mongod.log # network interfaces net: port: 10095 bindIp: 0.0.0.0 # how the process runs processManagement: timeZoneInfo: /usr/share/zoneinfo # 登录是否需要密码 #security: # authorization: enabled #operationProfiling: #replication: #sharding: ## Enterprise-Only Options: Mongodb添加用户 （1）连接Mongodb mongo mongodb://127.0.0.1:10095 （2）创建普通用户 use Production db.createUser( { user: \"production\", pwd: \"production@123\", // passwordPrompt() Or \"\u003ccleartext password\u003e\" roles: [ \"readWrite\", \"dbAdmin\" ] } ) （3）创建超级用户 use admin db.createUser( { user: \"mongoAdmin\", pwd: passwordPrompt(), // passwordPrompt() Or \"\u003ccleartext password\u003e\" roles: [ \"readWriteAnyDatabase\", \"userAdminAnyDatabase\", \"dbAdminAnyDatabase\"] } ) （4）登录 db.auth(\"production\") Mongodb更新用户权限 （1）连接Mongodb mongo mongodb://127.0.0.1:10095 （2）更新用户权限 use Production # 更新用户权限 db.updateUser(\"production\",{roles : [{\"role\" : \"readWriteAnyDatabase\",\"db\" : \"Stock\"},{\"role\" : \"dbAdminAnyDatabase\",\"db\" : \"Stock\"}]}) readWriteAnyDatabase ","date":"2021-09-16","objectID":"/posts/technology/mongodb/:0:0","tags":["MongoDB"],"title":"Mongodb总结","uri":"/posts/technology/mongodb/"},{"categories":["问题总结"],"content":"7.apt重新配置 （1）修复Python 当前的系统python如果有错误了，也需要一起修复，这个版本的python不能随便的更改，需要从一个正常的linux系统下把python复制出来。 # 版本正常的python3.6 mkdir python3.6 cd python3.6 mkdir python3.6-lib mkdir python3-lib mkdir x86_64-linux-gnu cp -rf /usr/bin/python3.6* ~/python3.6 cp -rf /usr/lib/python3.6/* ~/python3.6/python3.6-lib cp -rf /usr/lib/python3/* ~/python3.6/python3-lib cp -rf /usr/lib/x86_64-linux-gnu/*apt* ~/x86_64-linux-gnu/ cd .. tar zcvf python3.6.tar.gz python3.6 scp python3.6.tar.gz user@localhost:~ # 待修复的linux主机 tar zxvf python3.6.tar.gz cd python3.6 sudo cp -rf python3.6 /usr/bin sudo cp -rf python3.6m /usr/bin sudo cp -rf python3.6-lib/* /usr/lib/python3.6 sudo cp -rf python3-lib/* /usr/lib/python3 （2）修复动态库 dpkg -l apt 其中版本是2.0.2ubuntu0.2，下载对应的安装包并安装： # 安装apt wget http://mirrors.edge.kernel.org/ubuntu/pool/main/a/apt/apt_2.0.2ubuntu0.2_amd64.deb sudo dpkg -i apt_2.0.2ubuntu0.2_amd64.deb # 有时候提示缺少libapt-pkg6.0.so # 安装apt-pkg依赖 wget http://mirrors.edge.kernel.org/ubuntu/pool/main/a/apt/libapt-pkg6.0_2.0.2ubuntu0.2_amd64.deb sudo dpkg -i libapt-pkg6.0_2.0.2ubuntu0.2_amd64.deb （3）测试apt sudo apt update ","date":"2021-09-16","objectID":"/posts/technology/apt/:1:0","tags":["踩坑"],"title":"apt重新安装配置","uri":"/posts/technology/apt/"},{"categories":["问题总结"],"content":"Python 相关问题 ","date":"2021-09-16","objectID":"/posts/technology/python/:1:0","tags":["踩坑","python"],"title":"python总结","uri":"/posts/technology/python/"},{"categories":["问题总结"],"content":"Python ImportError: No module named _bz2 sudo apt-get install libbz2-dev #重新编译Python ","date":"2021-09-16","objectID":"/posts/technology/python/:1:1","tags":["踩坑","python"],"title":"python总结","uri":"/posts/technology/python/"},{"categories":["问题总结"],"content":"ImportError: Missing optional dependency ‘openpyxl’ pip install openpyxl #重新编译Python ","date":"2021-09-16","objectID":"/posts/technology/python/:1:2","tags":["踩坑","python"],"title":"python总结","uri":"/posts/technology/python/"},{"categories":["问题总结"],"content":"重置linux的python unset PYTHONHOME unset PYTHONPATH ","date":"2021-09-16","objectID":"/posts/technology/python/:1:3","tags":["踩坑","python"],"title":"python总结","uri":"/posts/technology/python/"},{"categories":["问题总结"],"content":"安装pip 下载get-pip.py wget https://bootstrap.pypa.io/get-pip.py 安装pip python get-pip.py ","date":"2021-09-16","objectID":"/posts/technology/python/:1:4","tags":["踩坑","python"],"title":"python总结","uri":"/posts/technology/python/"},{"categories":["教程"],"content":"Linux ","date":"2021-09-16","objectID":"/posts/technology/system/:0:0","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"/usr/bin/dpkg returned an error code (1) ","date":"2021-09-16","objectID":"/posts/technology/system/:1:0","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"解决dpkg错误 cd /var/lib/dpkg sudo mv info info.baksudo mkdir info ","date":"2021-09-16","objectID":"/posts/technology/system/:1:1","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"添加用户名和添加sudo ","date":"2021-09-16","objectID":"/posts/technology/system/:2:0","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"添加用户名 sudo useradd -m -d /data/username -s /bin/zsh username ","date":"2021-09-16","objectID":"/posts/technology/system/:2:1","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"修改密码 sudo passwd username ","date":"2021-09-16","objectID":"/posts/technology/system/:2:2","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"添加sudoers vi /etc/sudoers #添加用户 username ALL=(ALL:ALL) ALL ","date":"2021-09-16","objectID":"/posts/technology/system/:2:3","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"Ubuntu安装Linux开发包 sudo apt-get install build-essential ","date":"2021-09-16","objectID":"/posts/technology/system/:3:0","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"根据关键字把进程杀掉 kill -9 $(ps -ef|grep keyword|gawk '$0 !~/grep/ {print $2}' |tr -s '\\n' ' ') ","date":"2021-09-16","objectID":"/posts/technology/system/:4:0","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"linux永久挂载硬盘 查看当前的硬盘状态，可以知道硬盘的分区 sudo fdisk -l 修改配置 sudo vim /etc/fstab # 添加如下信息挂载硬盘 /dev/sdb1 /mnt/data ntfs-3g defaults 0 0 挂载硬盘 mkdir -p /mnt/data sudo mount -a ","date":"2021-09-16","objectID":"/posts/technology/system/:5:0","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"linux开机自启动并服务化 ","date":"2021-09-16","objectID":"/posts/technology/system/:6:0","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"Ubuntu 开机启动 系统服务化（以qbittorrent服务化为例） 不要在后面添加#的注释，不然会导致未知错误 配置文件/lib/systemd/system/qbittorrent.service [Unit] Description=qbittorrent-nox service #服务描述 Documentation=man:qbittorrent-nox(1) [Service] User=username #用户 Group=usergroup #用户组 UMask=0000 #权限777 Type=simple #ExecStartPre=-cd /home/\u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e/ #启动前执行 #WorkingDirectory=/home/\u003cspan class=\"hljs-built_in\"\u003etest\u003c/span\u003e/ #工作目录 ExecStart=/usr/bin/qbittorrent-nox #启动时执行 ExecReload=/bin/kill -SIGHUP $MAINPID #重启时执行 ExecStop=/bin/kill -SIGINT $MAINPID #停止时执行 [Install] WantedBy=default.target 服务常用命令集合 # 开机启动 systemctl enable qbittorrent # 关闭开机启动 systemctl disable qbittorrent # 启动服务 systemctl start qbittorrent # 停止服务 systemctl stop qbittorrent # 重启服务 systemctl restart qbittorrent # 查看服务状态 systemctl status qbittorrent systemctl is-active sshd.service # 结束服务进程(服务无法停止时) systemctl kill qbittorrent 用户服务化（以v2ray服务化为例，不需要sudo也可以启动，在某个用户登录的时候启动） 不要在后面添加#的注释，不然会导致未知错误 配置文件~/.config/systemd/user/v2ray.service``` [Unit] Description=keep v2ray's servie alive [Service] Type=simple Restart=always WorkingDirectory=~/v2ray/ ExecStart=bash v2ray.sh SystemCallArchitectures=native MemoryDenyWriteExecute=true NoNewPrivileges=true [Install] WantedBy=default.target 启动服务在原来的基础上加--user ```bash # 开机启动 systemctl --user enable --now v2ray # 关闭开机启动 systemctl --user disable --now v2ray ","date":"2021-09-16","objectID":"/posts/technology/system/:6:1","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"linux安装常见中文字体 ","date":"2021-09-16","objectID":"/posts/technology/system/:7:0","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"Ubuntu 打包Windows字体 mkdir -p winfonts cp -rf C:/Windows/Fonts winfonts 压缩winfonts为winfonts.zip 上传到linux scp winfonts.zip username@host:~ 安装字体 unzip -n -d /usr/share/fonts winfonts.zip sudo mkfontscale sudo mkfontdir sudo fc-cache -f -v 检查中文字体 fc-list :lang=zh Windows ","date":"2021-09-16","objectID":"/posts/technology/system/:7:1","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["教程"],"content":"给Neovim添加右键文件夹、文件以及右键空白区域三种菜单 右键文件夹 添加如下值 计算机\\HKEY_CLASSES_ROOT\\Directory\\shell\\使用Neovim打开 添加Icon 在使用Neovim打开空白处添加字符串项Icon设置值为\"D:\\Program Files\\Neovim\\bin\\gnvim.exe\" 添加打开命令 在使用Neovim打开添加子项command，设置值为\"D:\\Program Files\\Neovim\\bin\\gnvim.exe\" -qwindowgeometry 1310x650+20+20 \"%1\" 右键文件 添加如下值 计算机\\HKEY_CLASSES_ROOT\\*\\shell\\使用Neovim打开 添加Icon 在使用Neovim打开空白处添加字符串项Icon设置值为\"D:\\Program Files\\Neovim\\bin\\gnvim.exe\" 添加打开命令 在使用Neovim打开添加子项command，设置值为\"D:\\Program Files\\Neovim\\bin\\gnvim.exe\" -qwindowgeometry 1310x650+20+20 \"%1\" 右键文件 添加如下值 计算机\\HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\使用Neovim打开 添加Icon 在使用Neovim打开空白处添加字符串项Icon设置值为\"D:\\Program Files\\Neovim\\bin\\gnvim.exe\" 添加打开命令 在使用Neovim打开添加子项command，设置值为\"D:\\Program Files\\Neovim\\bin\\gnvim.exe\" 参考文档 使用注册表编辑win10鼠标右键菜单，详细解释（右键文件夹、文件以及右键空白区域下三种情况）_鸾镜朱颜暗换的博客-CSDN博客_桌面右键菜单注册表 contextmenu - How add context menu item to Windows Explorer for folders - Stack Overflow ","date":"2021-09-16","objectID":"/posts/technology/system/:8:0","tags":["linux","windows"],"title":"系统配置和问题","uri":"/posts/technology/system/"},{"categories":["项目"],"content":"1.安装selenium ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:1:0","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"chrome安装 sudo apt-get install libxss1 libappindicator1 libindicator7 wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb sudo dpkg -i ./google-chrome*.deb sudo apt-get install -f ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:1:1","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"配置chromedriver （1）下载驱动 去官网下载：http://chromedriver.storage.googleapis.com/index.html 点击 （2）安装驱动 复制到对应的目录运行 ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:1:2","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"配置selenium pip install selenium ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:1:3","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"2.安装uwsgi ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:2:0","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"配置文件uwsgi.ini #uwsgi.ini [uwsgi] http = 0.0.0.0:8010 chdir = /home/jianli/resume_service/services pythonpath = /home/jianli/venv/bin/python wsgi-file = resume_parser.py buffer-size = 40960 callable = app processes = 1 stats = 127.0.0.1:9191 ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:2:1","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"安装和运行uwsgi pip install uwsgi uwsgi uwsgi.ini ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:2:2","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"3.安装supervisor ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:3:0","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"配置supervisor http://supervisord.org/installing.html pip install supervisor echo_supervisord_conf \u003e supervisord.conf supervisord -c supervisor.conf ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:3:1","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"启动停止supervisor supervisorctl update 重新加载配置 supervisorctl reload 重新启动所有程序 supervisorctl status 查看状态 ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:3:2","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"supervisor问题 1.supervisorctl出现http://localhost:9001 refused connection 设置serverurl： [supervisorctl] serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL for a unix socket ;serverurl=http://127.0.0.1:9001 ; use an http:// url to specify an inet socket ;username=chris ; should be same as http_username if set ;password=123 ; should be same as http_password if set ;prompt=mysupervisor ; cmd line prompt (default \"supervisor\") ;history_file=~/.sc_history ; use readline history if availabl 2.supervisord配置uwsgi后，调用接口会启动新的服务 重新设置uwsgi如下： [uwsgi] http = 0.0.0.0:8010 virtualenv = /home/jianli/venv wsgi-file = /home/jianli/resume_service/services/resume_parser.py buffer-size = 40960 callable = app processes = 1 thread = 1 ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:3:3","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"4.安装libreoffice ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:4:0","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"下载安装 wget https://mirrors.cloud.tencent.com/libreoffice/libreoffice/stable/7.1.5/deb/x86_64/LibreOffice_7.1.5_Linux_x86-64_deb.tar.gz (安装说明)[https://zh-cn.libreoffice.org/get-help/install-howto/] ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:4:1","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["项目"],"content":"字体安装 wget https://mirrors.tuna.tsinghua.edu.cn/adobe-fonts/source-han-serif/SubsetOTF/SourceHanSerifCN.zip wget https://mirrors.tuna.tsinghua.edu.cn/adobe-fonts/source-han-sans/SubsetOTF/CN/SourceHanSansCN-Bold.otf wget https://mirrors.tuna.tsinghua.edu.cn/adobe-fonts/source-han-sans/SubsetOTF/CN/SourceHanSansCN-ExtraLight.otf wget https://mirrors.tuna.tsinghua.edu.cn/adobe-fonts/source-han-sans/SubsetOTF/CN/SourceHanSansCN-Heavy.otf wget https://mirrors.tuna.tsinghua.edu.cn/adobe-fonts/source-han-sans/SubsetOTF/CN/SourceHanSansCN-Light.otf wget https://mirrors.tuna.tsinghua.edu.cn/adobe-fonts/source-han-sans/SubsetOTF/CN/SourceHanSansCN-Medium.otf wget https://mirrors.tuna.tsinghua.edu.cn/adobe-fonts/source-han-sans/SubsetOTF/CN/SourceHanSansCN-Normal.otf wget https://mirrors.tuna.tsinghua.edu.cn/adobe-fonts/source-han-sans/SubsetOTF/CN/SourceHanSansCN-Regular.otf unzip SourceHanSerifCN.zip mv SourceHanSerifCN SourceHan mv *.otf SourceHan sudo mv SourceHan /usr/share/fonts mkfontscale fc-cache -fv # 如果提示 fc-cache: command not found # 在Ubuntu下运行如下命令 # sudo apt-get install fontconfig # 在cent os下运行如下命令 # yum install fontconfig ","date":"2021-08-30","objectID":"/posts/projects/resume_parser/:4:2","tags":["简历解析"],"title":"简历解析软件安装","uri":"/posts/projects/resume_parser/"},{"categories":["教程"],"content":"Ubuntu UFW 配置 （1）查看ufw信息 sudo ufw status （2）激活ufw sudo ufw enable （3）阻止/允许IP # 允许IP sudo ufw allow from 203.0.113.101 # 阻止IP sudo ufw deny from 203.0.113.100 （3）阻止/允许port # 允许外部访问端口8080 sudo ufw allow 8080 # 允许某ip访问端口8080 sudo ufw allow from 203.0.113.101 to any port 8080 # 阻止外部访问端口8080 sudo ufw disable 8080 # 阻止某ip访问端口8080 sudo ufw deny from 203.0.113.101 to any port 8080 （4）阻止/允许ssh # 允许 sudo ufw allow OpenSSH # 阻止 sudo ufw disable OpenSSH （5）查看支持的APP，并阻止/允许 sudo ufw app list | grep Nginx #Output Nginx Full Nginx HTTP Nginx HTTPS 删除NginxFull #允许 sudo ufw allow \"Nginx Full\" #阻止 sudo ufw deny \"Nginx Full\" （6）删除规则 先查看规则 sudo ufw status 选择对应的规则删除，例如第二个规则 sudo ufw delete 2 直接根据规则来删除 sudo ufw allow from 203.0.113.101 to any port 8080 sudo ufw delete allow from 203.0.113.101 to any port 8080 ","date":"2021-08-30","objectID":"/posts/technology/ufw_config/:0:1","tags":["ufw","firewall"],"title":"配置ufw","uri":"/posts/technology/ufw_config/"},{"categories":null,"content":"📚Blog Hi，你好这是我的个人网站。 ","date":"2021-07-29","objectID":"/about/:1:0","tags":null,"title":"关于","uri":"/about/"},{"categories":["项目"],"content":"更新历史 2021-08-01 1.修复九宫拼音不支持简拼的情况，如输入xqw不显示结果。 2.四叶草拼音去除25258个重复的词组，只保留最高频次的词组 ./Clover四叶草拼音/clover.phrase.dict.yaml:成事在人 cheng shi zai ren 22846 ./Clover四叶草拼音/THUOCL_chengyu.dict.yaml:成事在人 cheng shi zai ren 21 如上所示，成事在人，在两个字典中都有频次，只保留clover.phrase.dict.yaml中22846频次的词组 3.更新四叶草拼音拼音错误，例如反弹拼音为fandan，错误修复来源@wisim，感谢@spphinslove的反馈 4.四叶草拼音-汉字帧-拼音错误修改，把帧错误拼音zheng相关的词组全部修改为帧zhen 修改费时费力，不易，请大家多多支持，点击支持。 2021-07-29 1.添加九宫格支持隐藏 2.添加常用功能说明 2021-06-27 1.更新同文3.2.0支持 2.修复小鹤双拼简繁转换问题 3.自然码支持简繁转换问题 注：简繁转换属于opencc的内容，和同文没有关系，odc2文件是opencc的生成结果。 2021-06-23 1.增加自然码双拼，没有辅助码 2021-06-03 1.修正郑码字典显示错误https://github.com/SivanLaai/rime_pure/issues/25 2.默认所有方案不显示字符和表情包 2021-02-07 1.增加qq五笔 2.增加笔画输入@HarryWang29 3.增加九宫格双拼 2020-12-17 1.修正拼音自定义添加造词的功能 2020-12-5（更新，增加徐码、郑码，支持拼音和五笔反查，增加全键盘的符号键盘） 1.优化小鹤双拼方案，双拼支持拼音“`”反查小鹤双拼编码 2.增加徐码 3.徐码支持五笔“`”反查编码 4.徐码支持拼音“`”反查编码 5.增加郑码 6.郑码支持拼音“`”反查编码 7.手机同文，全键盘的符号键盘，调整回车键大小，调整符号键大小，更符合手机端操作 2020-10-31 1.新增双拼输入方案支持-小鹤双拼 2.所有输入方案配置支持繁简转换、中英转换、字符输入、emoji表情、全半角转换 3.调整键盘布局，超大空格，减少误触 4.增加同文优化版皮肤 2020-10-27 1.新增讯飞皮肤 2.更新部分细节 3.增加小鹤九宫双拼 2020-10-25 1.去除了明月拼音，添加了以搜狗为基础的输入方案——🍀️四叶草简体拼音 2.以🍀️四叶草简体拼音为基础，添加了四叶草九宫输入方案，方便在手机端可以使用 3.同文手机端添加了两款机械键盘主题，cherry机械键盘/罗技 4.四叶草拼音输入法在手机端支持简繁转有一些问题，原因是没有正确配置opencc，修改后手机端支持简繁转换 5.极品五笔方案增加支持字符（输入平方可以选择²），emoji表情，繁简转换 6.支持五笔反查 ","date":"2021-07-29","objectID":"/posts/projects/rime/update_history/:1:0","tags":["rime"],"title":"Rime更新历史","uri":"/posts/projects/rime/update_history/"},{"categories":["rime","项目"],"content":"不看下面的繁索的安装直接去发布页面下载已编译版本 最新发布页面 ","date":"2021-07-29","objectID":"/posts/projects/rime/installation/:1:0","tags":["rime"],"title":"Rime安装说明","uri":"/posts/projects/rime/installation/"},{"categories":["rime","项目"],"content":"小狼毫（PC端） 0.备份小狼毫输入法安装目录的data文件夹，备份~\\AppData\\Rime文件夹，下载小狼毫安装包：https://rime.im/ 1.文件夹weasel\\data内所有文件复制到小狼毫输入法data目录覆盖 2.文件夹weasel\\Rime内所有文件复制到~\\AppData\\Rime目录覆盖 3.文件夹schemes\\基础文件内所有文件复制到~\\AppData\\Rime目录覆盖 4.方案安装（可选） 4.1 拼音方案安装 文件夹schemes\\Clover四叶草拼音内所有文件复制到~\\AppData\\Rime目录覆盖 4.2 五笔方案安装（五笔反查依赖拼音词库，需先安装4.1拼音方案） 文件夹schemes\\极点五笔内所有文件复制到~\\AppData\\Rime目录覆盖 4.3 双拼方案安装（双拼反查依赖拼音词库，需先安装4.1拼音方案） 文件夹schemes\\小鹤双拼内所有文件复制到~\\AppData\\Rime目录覆盖 4.4 郑码方案安装（反查依赖拼音词库，需先安装4.1拼音方案） 文件夹schemes\\郑码内所有文件复制到~\\AppData\\Rime目录覆盖 4.5 徐码方案安装（反查依赖拼音和五笔词库，需先安装4.1拼音方案和4.2五笔方案） 文件夹schemes\\徐码内所有文件复制到~\\AppData\\Rime目录覆盖 4.6 QQ五笔方案安装（反查依赖拼音词库，需先安装4.1拼音方案） 文件夹schemes\\QQ五笔内所有文件复制到~\\AppData\\Rime目录覆盖 4.7 自然码双拼方案安装（依赖拼音词库，需先安装4.1拼音方案） 文件夹schemes\\自然码双拼内所有文件复制到~\\AppData\\Rime目录覆盖 4.8 四叶草地球拼音方案安装（依赖拼音词库，需先安装4.1拼音方案） 文件夹schemes\\四叶草地球拼音内所有文件复制到~\\AppData\\Rime目录覆盖 5.重新部署 ","date":"2021-07-29","objectID":"/posts/projects/rime/installation/:2:0","tags":["rime"],"title":"Rime安装说明","uri":"/posts/projects/rime/installation/"},{"categories":["rime","项目"],"content":"同文（安卓端） 0.备份sdcard\\rime文件夹，下载同文apk：https://github.com/osfans/trime/releases 1.文件夹trime\\rime内所有文件复制到sdcard\\rime目录覆盖 2.文件夹schemes\\基础文件内所有文件复制到sdcard\\rime目录覆盖 3.方案安装（可选） 3.1 拼音方案安装 文件夹schemes\\Clover四叶草拼音内所有文件复制到sdcard\\rime目录覆盖 3.2 九宫拼音方案安装（依赖词库，必须先安装3.1，九宫不能显示，检查第一步是否正确安装） 文件夹schemes\\Clover四叶草九宫拼音内所有文件复制到sdcard\\rime目录覆盖 3.3 五笔方案安装（五笔反查依赖拼音词库，需先安装3.1拼音方案） 文件夹schemes\\极点五笔内所有文件复制到sdcard\\rime目录覆盖 3.4 双拼方案安装（双拼反查依赖拼音词库，需先安装3.1拼音方案） 文件夹schemes\\小鹤双拼内所有文件复制到sdcard\\rime目录覆盖 3.5 郑码方案安装（反查依赖拼音词库，需先安装3.1拼音方案） 文件夹schemes\\郑码内所有文件复制到sdcard\\rime目录覆盖 3.6 徐码方案安装（反查依赖拼音和五笔词库，需先安装3.1拼音方案和3.3五笔方案） 文件夹schemes\\徐码内所有文件复制到sdcard\\rime目录覆盖 3.7 QQ五笔方案安装（反查依赖拼音词库，需先安装3.1拼音方案） 文件夹schemes\\QQ五笔内所有文件复制到sdcard\\rime目录覆盖 3.8 自然码双拼方案安装（依赖拼音词库，需先安装3.1拼音方案） 文件夹schemes\\自然码双拼内所有文件复制到sdcard\\rime目录覆盖 3.9 四叶草地球拼音方案安装（依赖拼音词库，需先安装3.1拼音方案） 文件夹schemes\\四叶草地球拼音内所有文件复制到sdcard\\rime目录覆盖 4.重新部署 ","date":"2021-07-29","objectID":"/posts/projects/rime/installation/:3:0","tags":["rime"],"title":"Rime安装说明","uri":"/posts/projects/rime/installation/"},{"categories":["项目"],"content":"【rime 小狼毫\\trime 同文】手机/PC一站式配置【简约皮肤\\拼音搜狗词库\\原创trime同文 四叶草九宫格拼音\\四叶草拼音\\小鹤双拼\\极品五笔\\QQ五笔\\徐码\\郑码】 ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:1:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"说明 rime是一款支持多平台的开源输入法，开源所以不需要担心自己的输入数据被输入法所搜集。虽然优点这么多，但是要使得输入法好用起来门槛比较高了，主要是在词库配置优化，依赖的东西多而且复杂。本项目的目的在于安卓手机端和Win pc端都可以从本项目一站配置好rime输入法，达到省心好用的程度。鉴于PC端已经有很多大神有现成的设置，所以花的时间较少，主要是整理收集。 发现手机端的优化一直没有做的较好的优化，本次主要的工作量是在手机端，所以从资源收集、皮肤设计、全键盘按钮设计和九宫格按键设计的每一个过程很耗费时间，有很多细节需要调整不断的修改文件和部署，有些地方不是清楚配置的地方还需要去看源码，经过一周的优化和设置，手机端已经使用起来很顺畅了。 目前在手机端配置了基于四叶草拼音的九宫格输入法，为了表示对原作者的劳动致敬，遂命名为四叶草九宫方案，感觉已经和之前使用的百度或者讯飞输入法感觉相当。 enjoy it! 好用的话就点个赞。感谢你的使用，因为本人同时在安卓和windows端使用，所以会一直更新。 ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:2:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"QQ群 ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:3:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"包含输入方案 - 🍀️四叶草拼音九宫格（不再使用原来的词库，原来的词库有很多问题，现在只是保留名字。） - 四叶草地球拼音 - 极点五笔 - 小鹤双拼 - 🍀️四叶草简体拼音 - 大写数字 - 自然双拼 - QQ86五笔（提取自qq五笔输入法，词库较为合理，推荐使用也是本人在使用的方案） - 徐码 - 郑码 ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:4:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"实用功能： ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:5:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"同文端 隐藏输入法：全键盘状态下按键G向下滑，九宫格状态下按分词键向下滑 编辑功能：全键盘状态下长按G，九宫格状态下按编辑键，可实现复制粘贴拷贝等功能 清空文本：删除键向左滑会清空当前编辑文本 切换主题：全键盘状态进入设置切换，九宫格长按带❖的按键切换主题 切换输入法：长按带✎的按键切换输入方案 设置：全键盘状态下按?123键下滑，九宫格状态下按带设置符号⚙的按键，既可进入设置页面 表情\\符号功能板：全键盘状态下长按?123键，九宫格状态下按符键 剪切板：全键盘状态下长按V键，九宫格状态下长按符键 ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:5:1","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"预览： ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:6:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"同文输入法（安卓端） 表情\\剪切板\\符号功能板 历史记录栏 剪切板 表情包 🍀️四叶草九宫输入方案 手机端支持简繁转换 部分皮肤预览 同文风优化版[配色：SivanLaai，键盘布局：SivanLaai] 讯飞默认皮肤[配色：SivanLaai，键盘布局：SivanLaai] cherry机械键盘【小先生】 极致简约[配色：SivanLaai，键盘布局：SivanLaai] 五笔字根【佚名】 炫彩[键盘布局：SivanLaai] ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:6:1","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"小狼毫输入法（PC端） 简约现代蓝[配色：XNOM] 绿野仙踪绿[配色：佛振] Aqua[配色：佛振] 安卓[配色：Patricivs] 暗堂[配色：佛振] 孤寺[配色佛振] ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:6:2","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"安装方法 查看安装方法 ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:7:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"更新历史 2022-12-30 - 1.移除九宫模式下ascii模式的切换 - 2.优化九宫数字键盘布局 ![](https://cdn.staticaly.com/gh/SivanLaai/image-store-rep@master/note/ 20221230200634.png) 2022-11-4 - 1.优化四叶草拼音的基础词库为华宇输入法词库@warm-ice0x00（不再使用原来的词库，原来的词库有很多问题。） 2022-3-19 - 1.调整剪切板功能快捷方式 - 2.qq86五笔用户词添加不成功修复 2021-10-26 - 1.修复3.2.3所引入的键盘显示问题 - 2.调整键盘的符号页面，详情查看同文功能页面 - 3.调整数字页面为更加符合操作的九宫格数字页面 - 4.输入键盘快速跳转符号剪切栏 2021-10-20 - 1.四叶草拼音的权重调整为最大概率保留，同时是以词组进行切割的，例如弹出如果是分词的话就是tanchu，不会再出现danchu的拼音，如果弹出不是一个完整的分词那拼音可能是按单个字保留拼音的最大概率。主要改动在src/GenerateCloverData.py。 - 2.四叶草简体支持符号输入优化，/fh可以查看当前的符号，/jq可以查看所有的节气 - 3.四叶草简体支持笔画反查（`后输入hspnz分别表示一丨丿丶乙） 2021-10-17 - 1.修复同文端繁简转换opencc资源文件为最新的ocd2，小狼毫端暂时不支持ocd2。 2021-10-14 - 1.同步更新同文官方支持的剪切板功能，可以查看剪切板和最近表情包历史，使用更为灵活的符号菜单。 2021-09-01 - 1.前前后后、零零碎碎一共花了十来天地时间完成基于四叶草词库的地球拼音输入方案。 2021-08-30 - 1.四叶草支持多音字，最大程序的避免拼音错误，同时是以词组来分词的所以，不至于对所有的词组进行挨个多音字支持，而是优先词组。 例如弹出分词后还是弹出，所以只有tan chu的拼音，如果分词为弹\\出的话，则拼音会有tan chu 和 dan chu - 2.四叶草保留最大概率拼音词组，例如是不其中不为多音字，不的拼音有bu和fou，基于四叶草统计概率，bu的拼音概率更高，如果不是在词组的情况下，单字以bu为优先。 2021-08-18 - 1.写爬虫exact-pinyin-mark抓取百度汉语字典35W个组词数据用来精准匹配clover拼音数据。 - 2.使用luna拼音修复clover拼音数据。 - 3.使用phrase-pinyin-data修复clover拼音数据。 - 4.具有更高的基础词库，对于常见的拼音数据具有更高的识别率 2021-08-11 - 1.修复大字典中的的拼音错误。 - 2.基于python-pinyin对所有四叶草字典进行多音字修复，同时单字也支持多音字输入 ``` 例如朝拼chao zhao zhu输入 词频调整chao保留最高，依次递减10倍 例如chao为123，zhao为12，zhu为1 ``` 2021-08-01 - 1.修复九宫拼音不支持简拼的情况，如输入xqw不显示结果。 - 2.四叶草拼音去除25258个重复的词组，只保留最高频次的词组 ``` ./Clover四叶草拼音/clover.phrase.dict.yaml:成事在人 cheng shi zai ren 22846 ./Clover四叶草拼音/THUOCL_chengyu.dict.yaml:成事在人 cheng shi zai ren 21 如上所示，成事在人，在两个字典中都有频次，只保留clover.phrase.dict.yaml中22846频次的词组 ``` - 3.更新四叶草拼音错误，例如反弹拼音为fandan，错误修复来源@wisim，感谢@spphinslove的反馈 - 4.四叶草拼音-汉字帧-拼音错误修改，把帧错误拼音zheng相关的词组全部修改为帧zhen - 修改费时费力，不易，请大家多多支持，点击支持。 2021-07-29 - 1.添加九宫格支持隐藏 - 2.添加常用功能说明 2021-06-27 - 1.更新同文3.2.0支持 - 2.修复小鹤双拼简繁转换问题 - 3.自然码支持简繁转换问题 以往全部历史 ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:8:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"相关资源 - 小狼毫输入法：https://github.com/rime/weasel - 同文输入法：https://github.com/osfans/trime - 简繁转换opencc：https://github.com/BYVoid/OpenCC - 拼音爬虫exact-pinyin-mark：https://github.com/SivanLaai/exact-pinyin-mark - 部分配色均整理自互联网，配色包含作者信息。 ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:9:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"感谢 - 感谢@lotem - 感谢trime作者@osfans - 感谢四叶草拼音作者@fkxxyz - 感谢极品五笔作者@KyleBing - 感谢qq五笔@qq五笔 - 感谢opencc作者@BYVoid - 感谢@小鹤双拼 - 感谢@郑码 - 感谢@徐码 - 没有以上资源和各位的辛苦付出，也就没有这个项目 ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:10:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"💖支持这个项目 如果你正在使用这个项目并感觉良好，或只是想要支持我继续开发，你可以通过如下任意 方式支持我： Star 并 分享这个项目 🚀 通过以下二维码 一次性捐款。 一杯咖啡。🍵 谢谢！ ❤️ | 微信 | 支付宝 | | :—: | :—: | | | | ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:11:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["项目"],"content":"许可证 MIT Copyright (c) 2020-present SivanLaai ","date":"2021-07-29","objectID":"/posts/projects/rime/info/:12:0","tags":["rime","输入法"],"title":"Rime输入法介绍","uri":"/posts/projects/rime/info/"},{"categories":["技术"],"content":"2020 年的第一篇博文竟然是讲虚拟砖混结构建筑物逾越技术的，感觉有点微妙。 年终总结啊，在写了在写了，明年就发。 因为嫌麻烦，我这几年基本用的都是现成的代理服务（俗称机场）。这样虽然不用担心自己机器 IP 被墙、速度方面基本有保障、节点也多，不过俗话说不要把鸡蛋放在一个篮子里，自建一个代理服务器备用还是很有必要的。 这几年翻墙技术似乎也发展了不少（是吗？），这次我选择的方法是 V2Ray + WebSocket + TLS + CloudFlare 中转：速度不重要，隐蔽性、抗干扰性第一。这么几层裹上去，除非真的掐网线搞大局域网，不然应该还是能撑个一段时间。 正文开始前先提个醒，本文不是小白教程，就是随手记录一下，所以我会假定你有一定的基础知识与操作经验。 ","date":"2020-01-12","objectID":"/posts/technology/lattern/:0:0","tags":["V2Ray"],"title":"搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare","uri":"/posts/technology/lattern/"},{"categories":["技术"],"content":"1. 安装 V2Ray 除非你是真的小白零经验，或者「能用就好」主义的忠实信奉者，不然我是不推荐你一上来就直接使用网上那些「一键脚本」的。 就算一键脚本再怎么优秀再怎么便利，至少也应该亲自手动操作一次，了解一下大致的流程。如果我想要做某件事，应该进行哪些操作，脚本会替我完成哪些操作，这些自动化操作是不是符合自己的预期（尤其是脚本是其他人写好的情况下），最起码这些东西得心里有数。 脚本写出来就是帮我们自动完成一些繁琐的操作的，其存在当然有意义，不然每台机器上都手动操作一遍过去，不得累死？用肯定是要用，我所不赞成的只是在不了解这个脚本的情况下瞎用。 线上服务器搭建 LNMP 环境时我也经常用 OneinStack 这样的一键包，很方便。而且它的源码我也都看过，很清楚它能干嘛、会干嘛。也知道它自带的 vhost.sh 虚拟主机管理脚本虽然看起来挺友好，但其修改出来的东西经常惨不忍睹，所以服务器上 Nginx 的配置我从来不用它，都是自己管理的。 总的来说就是可以用傻瓜式脚本，但咱也不能真成傻瓜了，对吧。 好了不说废话，来安装 V2Ray。 安装方法有很多，这里就直接用官方提供的脚本： bash \u003c(curl -L -s https://install.direct/go.sh) 脚本会自动安装这些东西： /usr/bin/v2ray/v2ray V2Ray 程序 /usr/bin/v2ray/v2ctl V2Ray 工具 /etc/v2ray/config.json 配置文件 /usr/bin/v2ray/geoip.dat IP 数据文件 /usr/bin/v2ray/geosite.dat 域名数据文件 /etc/systemd/system/v2ray.service Systemd Service /etc/init.d/v2ray SysV 启动脚本 ","date":"2020-01-12","objectID":"/posts/technology/lattern/:1:0","tags":["V2Ray"],"title":"搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare","uri":"/posts/technology/lattern/"},{"categories":["技术"],"content":"2. 配置 V2Ray 服务端 虽然严格来说 V2Ray 并不分客户端和服务端……反正就是那个意思啦。 编辑配置文件 /etc/v2ray/config.json： { \"inbounds\": [{ \"port\": 10086, // 因为还要用 Nginx 反代，这里直接监听本地就行 \"listen\": \"127.0.0.1\", \"protocol\": \"vmess\", \"settings\": { \"clients\": [ { // 用户 UUID，自己随机弄一个 \"id\": \"23ad6b10-8d1a-40f7-8ad0-e3e35cd38297\", \"level\": 1, \"alterId\": 64 } ] }, \"streamSettings\": { // 指定底层传输方式为 WebSocket \"network\": \"ws\", \"wsSettings\": { // 在哪个路径上提供 WS 服务，可自定义 \"path\": \"/whatever\" } } }], \"outbounds\": [{ \"protocol\": \"freedom\", \"settings\": {} },{ \"protocol\": \"blackhole\", \"settings\": {}, \"tag\": \"blocked\" }], \"routing\": { \"rules\": [ { // 默认规则，禁止访问服务器内网 \"type\": \"field\", \"ip\": [\"geoip:private\"], \"outboundTag\": \"blocked\" } ] } } 上述配置是直接基于默认配置修改的，V2Ray 的配置很灵活，还有很多可以完善的地方。不过配置调优并不是本文的重点，所以这里按下不表，有兴趣可以自行阅读官方文档。 ","date":"2020-01-12","objectID":"/posts/technology/lattern/:2:0","tags":["V2Ray"],"title":"搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare","uri":"/posts/technology/lattern/"},{"categories":["技术"],"content":"3. 运行 V2Ray 配置完了，运行一下： systemctl start v2ray 如果你的服务器不用 Systemd： service v2ray start # 要么 /etc/init.d/v2ray start # 或者手动运行 /usr/bin/v2ray/v2ray -config /etc/v2ray/config.json 测试一下有没有跑起来： curl -i http://127.0.0.1:10086/whatever HTTP/1.1 400 Bad Request Content-Type: text/plain; charset=utf-8 Sec-Websocket-Version: 13 X-Content-Type-Options: nosniff Date: Sun, 12 Jan 2020 11:45:14 GMT Content-Length: 12 Bad Request 注意 curl 访问的端口和路径要和上面 V2Ray 中配置的一致，出现 400 Bad Request 就对了。 ","date":"2020-01-12","objectID":"/posts/technology/lattern/:3:0","tags":["V2Ray"],"title":"搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare","uri":"/posts/technology/lattern/"},{"categories":["技术"],"content":"4. 配置 Nginx 毕竟要隐蔽嘛，最好是选一个已经上线的正常网站，悄咪咪地把其中一个路径反代到我们的 V2Ray 上。 网上不少 V2Ray + WebSocket + TLS 的教程里，Web 服务器 + SSL 证书的配置都是重头戏。可如果你平时就有在捣鼓网站的话，这些实在是都不算啥……所以我这里也就一笔带过了。 以 Nginx 为例，找个合适的 server {} 块添加以下内容（这重定向语法够蛋疼的）： location /whatever { proxy_redirect off; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection \"upgrade\"; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; set $is_v2ray 0; if ($http_upgrade = \"websocket\") { set $is_v2ray 1; } if ($is_v2ray = 1) { # 仅当请求为 WebSocket 时才反代到 V2Ray proxy_pass http://127.0.0.1:10086; } if ($is_v2ray = 0) { # 否则显示正常网页 rewrite ^/(.*)$ /mask-page last; } } 注意 location 的路径要和上面 V2Ray 里配置的一样。 最后完整的 Nginx 配置大概类似这样： server { listen 443 ssl http2; server_name example.com; index index.html index.htm index.php; root /data/wwwroot/example; ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; ssl_session_cache shared:SSL:10m; ssl_session_timeout 10m; ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; ssl_ciphers EECDH+AESGCM:EDH+AESGCM; location ~ [^/]\\.php(/|$) { fastcgi_pass unix:/dev/shm/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; } location /whatever { # ... } } 表面看上去像个正常 PHP 网站，/whatever 里才是大有乾坤。 再把路径和网站内容搞得唬人一点，我寻思隐蔽性方面应该是没问题的。 ","date":"2020-01-12","objectID":"/posts/technology/lattern/:4:0","tags":["V2Ray"],"title":"搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare","uri":"/posts/technology/lattern/"},{"categories":["技术"],"content":"5. 配置 CloudFlare 呃，这个就不用讲什么了吧。还不说声多谢 CloudFlare 哥？ CDN 配置完了再用 curl 测试一下： curl -i https://example.com/whatever HTTP/2 400 date: Sun, 12 Jan 2020 08:44:07 GMT content-type: text/plain; charset=utf-8 content-length: 12 sec-websocket-version: 13 x-content-type-options: nosniff cf-cache-status: DYNAMIC expect-ct: max-age=604800, report-uri=\"https://report-uri.cloudflare.com/cdn-cgi/beacon/expect-ct\" server: cloudflare Bad Request 同样也是出现 400 Bad Request 就对了。 如果你像我上面一样在 Nginx 中配置了 $http_upgrade = \"websocket\" 的判断的话，这里返回的会是用于伪装的那个页面（而且 Nginx 的 $http_upgrade 变量不知道是按什么赋值的，直接 curl --header \"Upgrade: websocket\" 的话还不认，怪得很）。可以使用 wscat 来测试： wscat -c wss://example.com/whatever Connected (press CTRL+C to quit) ","date":"2020-01-12","objectID":"/posts/technology/lattern/:5:0","tags":["V2Ray"],"title":"搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare","uri":"/posts/technology/lattern/"},{"categories":["技术"],"content":"6. 配置 V2Ray 客户端 客户端配置文件大概改成这样： { \"log\": { \"loglevel\": \"warning\" }, \"inbounds\": [{ // 本地代理配置 \"port\": 1080, \"listen\": \"127.0.0.1\", \"protocol\": \"socks\", \"settings\": { \"auth\": \"noauth\", \"udp\": false, \"ip\": \"127.0.0.1\" } }], \"outbounds\": [{ \"protocol\": \"vmess\", \"settings\": { \"vnext\": [ { // 套过 CloudFlare 的网址 \"address\": \"example.com\", \"port\": 443, \"users\": [ { // id 和 alterId 必须和服务端上配置的一样 \"id\": \"23ad6b10-8d1a-40f7-8ad0-e3e35cd38297\", \"alterId\": 64 } ] } ] }, \"streamSettings\": { // 传输协议为 WebSocket \"network\": \"ws\", // 底层传输安全为 TLS \"security\": \"tls\", \"wsSettings\": { // 路径要和上面设置的一样 \"path\": \"/whatever\" } } }], \"policy\": { \"levels\": { \"0\": {\"uplinkOnly\": 0} } } } 上述客户端配置同样也是简化的，路由、DNS 什么的都没设置。 当然，我估计桌面用户基本上用的都是各种图形客户端，不然可不是折腾自己嘛。以 Windows 上的 v2rayN 客户端为例，你可以这样添加服务器： 不出意外就可以正常使用了。 ","date":"2020-01-12","objectID":"/posts/technology/lattern/:6:0","tags":["V2Ray"],"title":"搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare","uri":"/posts/technology/lattern/"},{"categories":["技术"],"content":"常见问题 ","date":"2020-01-12","objectID":"/posts/technology/lattern/:7:0","tags":["V2Ray"],"title":"搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare","uri":"/posts/technology/lattern/"},{"categories":["技术"],"content":"TUN模式，开启热点连接暴增 开启热点分享功能，此时系统网络设置中会生成一个网卡 开启 TUN 模式 进入系统网络设置，在 Clash 网卡右键选择属性，选择共享标签页 勾选“允许其他网络用户通过此计算机的 Internet 连接来连接” 在“家庭网络连接”选择框中选择第 1 步生成的网卡 networdk-adaptor.jpg 参考链接： WebSocket+TLS+Web · V2Ray 配置指南|V2Ray 白话文教程 配置文件 · Project V 官方网站 使用Cloudflare中转V2Ray流量 · 233boy/v2ray Wiki CFW TUN 模式 移动热点冲突 - Leey’s ","date":"2020-01-12","objectID":"/posts/technology/lattern/:7:1","tags":["V2Ray"],"title":"搭建备用梯子：V2Ray + WebSocket + TLS + CloudFlare","uri":"/posts/technology/lattern/"},{"categories":["笔记"],"content":"多分类支持向量机可以用来处理多分类问题，其分类函数可以给每一个类得到一个分数值，从而从数值上了解哪个类别的分数高低，其损失函数也是通过某个特定的阈值来优化从而使得模型在正确类别上得到一个比其他类别更高的分数值。 loss函数(设定有C个类别) $$s = [s_1, s_2, …, s_C] = f(x_i, W) = [f(x_i, W)1, f(x_i, W)2, … ,f(x_i, W)C]$$ $$L_i = \\sum{j\\neq y_i} \\max(0, s_j - s{y_i} + \\Delta)$$ $$L = \\frac{1}{N} \\sum_i L_i + \\lambda R(W)$$ $$L = \\frac{1}{N} \\sum_i \\sum{j\\neq y_i} \\left[ \\max(0, f(x_i; W)j - f(x_i; W){y_i} + \\Delta) \\right] + \\lambda \\sum_k\\sum_l W_{k,l}^2$$ 梯度下降 $$s = W^Tx_i$$ $$j==yi时：\\frac{dL_i}{dW_{y_i}} = -\\sum_{j\\neq y_i}\\mathbb{I}(W^T_jx_i - W^T_{y_i}x_i + \\Delta\u003e0)$$ $$j！=i时：\\frac{dL_i}{dW_yi} = \\mathbb{I}(W^T_jx_i - W^T_{y_i}x_i + \\Delta\u003e0)$$ $$\\frac{dL}{dW} = \\frac{1}{N}\\sum^N_{i=1}\\frac{dL_i}{dW} + 2\\lambda W$$ $$执行 W = W - \\alpha \\frac{dL}{dW},在根据W求s，然后求loss，最后优化得到较理想的W值$$ ","date":"2018-06-28","objectID":"/posts/research/multiclass_svm/:0:0","tags":["分类"],"title":"多分类支持向量机","uri":"/posts/research/multiclass_svm/"},{"categories":["笔记"],"content":"bacth normlization中的前向传播 input:X_{ij}(本层所有的样本矩阵为X维度为mxD，m为样本数，D为神经元的个数，其中X_{ij}为X中的某一个样本) $$其中样本矩阵X = \\begin{bmatrix} X_{11}\u0026 X_{12} \u0026 … \u0026X_{1D} \\\\ X_{21}\u0026 X_{22} \u0026 … \u0026X_{2D} \\\\ .\u0026 . \u0026 …\u0026. \\\\ .\u0026 .\u0026 … \u0026 .\\\\ X_{m1}\u0026 X_{m2} \u0026 … \u0026X_{mD} \\end{bmatrix},X_{i} = \\begin{bmatrix} X_{i1}\u0026 X_{i2} \u0026 … \u0026X_{iD} \\\\ \\end{bmatrix},第j列为X_{\\cdot j} = \\begin{bmatrix} X_{1j}\\\\ X_{2j}\\\\ .\\\\ .\\\\ X_{mj} \\end{bmatrix}$$ $$ output格式为: Yi = BN(X_{ij}, \\gamma, \\beta)\\\\ 其中输出矩阵Y = \\begin{bmatrix} Y_{11}\u0026 Y_{12} \u0026 … \u0026Y_{1D} \\\\ Y_{21}\u0026 Y_{22} \u0026 … \u0026Y_{2D} \\\\ .\u0026 . \u0026 …\u0026. \\\\ .\u0026 .\u0026 … \u0026 .\\\\ Y_{m1}\u0026 Y_{m2} \u0026 … \u0026Y_{mD} \\end{bmatrix}，m为样本数，D为输入维度数$$ 前向传播过程如下 $$\\mu_{j} = E(X) = \\frac{1}{m}\\sum_{i=1}^{m}X_{i}，则\\mu_{j} 的维度为(1,D)\\\\ \\sigma_{j}^{2} = Var(X) = \\frac{1}{m}\\sum_{i=1}^{m}(X_{i}-\\mu_{j})^{2}，则\\sigma_{j}^{2}的维度为(1,D)\\\\ 对第i个样本的估计\\hat{X_{ij}} = \\frac{X_{ij} - \\mu_{j}}{\\sqrt{\\sigma_{j}^{2} + \\varepsilon }}，则\\hat{X_{i}}维度为(1,D)\\\\ 对m个样本估计\\hat{X} = \\frac{X - \\mu_{j}}{\\sqrt{\\sigma_{j}^{2} + \\varepsilon }}，则\\hat{X}维度为(m,D)\\\\ 第i个样本的输出Y_{i} = \\gamma \\times \\hat{X_{i}} + \\beta，其中\\gamma维度为(1,D),\\beta维度为(1,D),则Y_{i}维度为(1,D)\\\\ 则m个样本的输出Y = \\gamma \\times \\hat{X} + \\beta，其中\\gamma维度为(1,D),\\beta维度为(1,D),则Y维度为(m,D)$$ ","date":"2018-04-28","objectID":"/posts/research/bacth_norm/:1:0","tags":["神经网络"],"title":"批量标准化","uri":"/posts/research/bacth_norm/"},{"categories":["笔记"],"content":"bacth normlization中的反向传播 $$假设上层梯度为\\frac{dL}{dY}，本层输入为X，过程如下：\\\\ 从X中选中第j列，令x = \\begin{bmatrix} X_{1j}\\\\ X_{2j}\\\\ .\\\\ .\\\\ X_{mj} \\end{bmatrix}\\\\$$ (1)求dbeta $$我们先求d\\beta_{j} = \\sum_{i=1}^{m}\\frac{dL}{dY_{ij}} \\cdot \\frac{dY_{ij}}{d\\beta_{j}}， 由Y_{i} = \\gamma \\times \\hat{X_{i}} + \\beta可知Y_{ij} = \\gamma_{j} \\times \\hat{X_{ij}} + \\beta_{j}，\\frac{dY_{ij}}{d\\beta_{j}}=1\\\\ 所以d\\beta_{j} = \\sum_{i=1}^{m}\\frac{dL}{dY_{ij}}，则对整个矩阵操作d\\beta = \\sum_{i=1}^{m}\\frac{dL}{dY_{i}} = \\begin{bmatrix} d\\beta_{1}\u0026 d\\beta_{2} \u0026 … \u0026d\\beta_{D} \\\\ \\end{bmatrix}$$ (2)求dgamma $$ d\\gamma_{j} = \\sum_{i=1}^{m}\\frac{dL}{dY_{ij}} \\cdot \\frac{dY_{ij}}{d\\gamma_{j}}\\\\ 由Y_{i} = \\gamma \\times \\hat{X_{i}} + \\beta可知Y_{ij} = \\gamma_{j} \\times \\hat{X_{ij}} + \\beta_{j}，\\frac{dY_{ij}}{d\\gamma_{j}}=\\hat{X_{ij}}\\\\ 所以d\\gamma_{j} = \\sum_{i=1}^{m}\\frac{dL}{dY_{ij}} \\cdot \\hat{X_{ij}}\\\\ 对整个矩阵进行操作d\\gamma = \\sum_{i=1}^{m}\\frac{dL}{dY_{i}} \\cdot \\hat{X_{i}} = \\begin{bmatrix} d\\gamma_{1}\u0026 d\\gamma_{2} \u0026 … \u0026d\\gamma_{D} \\end{bmatrix}$$ (3)求dX 最后我们还要对X进行求导，首先我们先看下面的链式路径： $$对第i行第j列进行反向传播：\\frac{dL}{dX_{ij}} = \\sum_{k=1}^{m}\\frac{dL}{d\\hat{X_{kj}}} \\cdot\\frac{d\\hat{X_{kj}}}{dX_{ij}} = \\sum_{k=1}^{m} \\sum_{l=1}^{m}(\\frac{dL}{d\\hat{Y_{lj}}} \\cdot \\frac{dY_{lj}}{d\\hat{X_{kj}}})\\cdot\\frac{d\\hat{X_{kj}}}{dX_{ij}}\\\\ 由Y_{i} = \\gamma \\times \\hat{X_{i}} + \\beta可知Y_{lj} = \\gamma_{j} \\times \\hat{X_{lj}} + \\beta_{j}，则\\frac{dY_{lj}}{d\\hat{X_{kj}}}=\\gamma_{j}(当l=k时)，\\frac{dY_{lj}}{d\\hat{X_{kj}}}=0(当l≠k时)\\\\ 则\\frac{dL}{dX_{ij}} = \\sum_{k=1}^{m}\\frac{dL}{dY_{kj}} \\cdot \\frac{dY_{kj}}{d\\hat{X_{kj}}} \\cdot\\frac{d\\hat{X_{kj}}}{dX_{ij}} = \\sum_{k=1}^{m}\\gamma_{j} \\cdot \\frac{dL}{dY_{kj}} \\cdot\\frac{d\\hat{X_{kj}}}{dX_{ij}} \\\\ 由\\hat{X_{ij}} = \\frac{X_{ij} - \\mu_{j}}{\\sqrt{\\sigma_{j}^{2} + \\varepsilon }}，\\mu_{j} = \\frac{1}{m}\\sum_{k=1}^{m}X_{kj}， \\sigma_{j}^{2} = \\frac{1}{m}\\sum_{k=1}^{m}(X_{kj}-\\mu_{j})^{2}和上图可知我们求\\frac{d\\hat{X_{ij}}}{dX_{ij}}的话有三条路径:\\\\ 第一条路径为：\\frac{d\\hat{X_{kj}}}{dX_{ij}} = \\left \\lceil k==i \\right \\rfloor \\cdot \\frac{1}{\\sqrt{\\sigma_{j}^{2} + \\varepsilon }}\\\\ 第二条路径为：\\frac{d\\hat{X_{kj}}}{dX_{ij}} = \\frac{d\\hat{X_{kj}}}{d\\mu_{j}} \\cdot \\frac{d\\mu_{j}}{dX_{ij}}，\\frac{d\\hat{X_{kj}}}{d\\mu_{j}} = -\\frac{1}{\\sqrt{\\sigma_{j}^{2} + \\varepsilon }},\\frac{d\\mu_{j}}{dX_{ij}} = \\frac{1}{m}\\\\ 则\\frac{d\\hat{X_{kj}}}{dX_{ij}} = -\\frac{1}{m\\sqrt{\\sigma_{j}^{2} + \\varepsilon }}\\\\ 第三条路径为：\\frac{d\\hat{X_{kj}}}{dX_{ij}} = \\frac{d\\hat{X_{kj}}}{d\\sigma_{j}^{2}} \\cdot \\frac{d\\sigma_{j}^{2}}{dX_{ij}}，\\\\ \\frac{d\\hat{X_{kj}}}{d\\sigma_{j}^{2}} = -\\frac{X_{kj} - \\mu_{j}}{2(\\sigma_{j}^{2} + \\varepsilon)^{\\frac{3}{2}}}，\\\\ 求解\\frac{d\\sigma_{j}^{2}}{dX_{ij}}有两个路径： 路径1：\\frac{d\\sigma_{j}^{2}}{dX_{ij}} = \\frac{2}{m}(X_{ij} - \\mu_{j})，路径2：\\frac{d\\sigma_{j}^{2}}{dX_{ij}} = \\frac{d\\sigma_{j}^{2}}{d\\mu_{j}} \\cdot \\frac{d\\mu_{j}}{dX_{ij}} = - \\frac{2}{m}(X_{ij} - \\mu_{j}) \\cdot \\frac{1}{m}\\\\ 则\\frac{d\\sigma_{j}^{2}}{dX_{ij}} = \\frac{d\\sigma_{j}^{2}}{dX_{ij}} + \\frac{d\\sigma_{j}^{2}}{d\\mu_{j}} \\cdot \\frac{d\\mu_{j}}{dX_{ij}} = \\frac{2}{m}(X_{ij} - \\mu_{j}) + (- \\frac{2}{m}(X_{ij} - \\mu_{j}) \\cdot \\frac{1}{m}) = \\frac{2}{m^{2}}(X_{ij} - \\mu_{j})(m - 1)\\\\ 则\\frac{d\\hat{X_{kj}}}{dX_{ij}} = \\frac{d\\hat{X_{kj}}}{d\\sigma_{j}^{2}} \\cdot \\frac{d\\sigma_{j}^{2}}{dX_{ij}} = -\\frac{X_{kj} - \\mu_{j}}{2(\\sigma_{j}^{2} + \\varepsilon)^{\\frac{3}{2}}} \\cdot \\frac{2}{m^{2}}(X_{ij} - \\mu_{j})(m - 1) = \\frac{(X_{kj} - \\mu_{j}) \\cdot(X_{ij} - \\mu_{j}) \\cdot(1 - m)}{m^{2}\\cdot (\\sigma_{j}^{2} + \\varepsilon)^{\\frac{3}{2}}}\\\\ 综合上述三条路径可求得\\frac{dL}{dX_{ij}} = \\sum_{k=1}^{m}\\gamma\\cdot\\frac{dL}{dY_{kj}}\\cdot\\frac{d\\hat{X_{kj}}}{dX_{ij}} + \\sum_{k=1}^{m}\\gamma\\cdot\\frac{dL}{dY_{kj}}\\cdot\\frac{d\\hat{X_{kj}}}{d\\mu_{j}} \\cdot \\frac{d\\mu_{j}}{dX_{ij}} +\\sum_{k=1}^{m}\\gamma\\cdot\\frac{dL}{dY_{kj}}\\cdot \\frac{d\\hat{X_{kj}}}{d\\sigma_{j}^{2}} \\cdot \\frac{d\\sigma_{j}^{2}}{dX_{ij}}\\\\ = \\gamma\\cdot\\frac{dL}{dY_{ij}}\\cdot\\frac{1}{\\sqrt{\\sigma_{j}^{2} + \\varepsilon }} + \\sum_{k=1}^{m}\\gamma\\cdot\\frac{dL}{dY_{kj}}\\cdot\\frac{-1}{m\\sqrt{\\sigma_{j}^{2} + \\varepsilon }} +\\sum_{k=1}^{m}\\gam","date":"2018-04-28","objectID":"/posts/research/bacth_norm/:2:0","tags":["神经网络"],"title":"批量标准化","uri":"/posts/research/bacth_norm/"},{"categories":["笔记"],"content":" 再学完斯坦福大学的计算机视觉的课后，总结一下自己对全连接神经网络的理解，方便在以后自己可以查阅和复习。首先简单的复习一下神经网络的概念，神经网络有输入层、隐藏层和输出层三种层，其中隐藏层可能会有多层，一个神经网络有多少层要看有多少个隐藏层加上输出层就为该神经网络的层数。神经网络的来源源于生物体的大脑的神经元的触发机制，但是我们要区分神经网络和真实生物体的差别。神经网络不是生物体神经元的真实映射。本篇文章以cs231n中的作业二中的神经网络作为背景进行讲述。 ","date":"2018-04-22","objectID":"/posts/research/neural_network/:0:0","tags":["神经网络"],"title":"全连接神经网络","uri":"/posts/research/neural_network/"},{"categories":["笔记"],"content":"1.神经网络中的基本结构 如上图所示，神经网络有输入层、隐藏层和输出层组成，这个神经网络一共有两层，一个隐藏层和一个输出层，输入层不算层数。输入层有输入维度为3，第一层有四个神经元，输出层有两个神经元。在某些结构中，我们的神经网络结构会更加，隐藏层可能会不只一个，而且每一层的神经元个数也会不唯一。其中每一个神经元有一个输入和一个输出，如下为一个神经元的内部详解： 一个神经元其实有两个处理，首先是对前面的输入做一个线性求和$$Z = \\sum_{i=1}^{N} wi \\cdot xi +b$$ 然后在有一个激活函数f在对z做处理得到这个神经元的输出 $$f(\\sum_{i=1}^{N} wi \\cdot xi +b)$$ 讲完了基本的神经网络结构后，我们现在以cs231n中作业2中的全连接神经网络架构做一个讲述，他的架构为{affine - [batch norm] - relu - [dropout]} x (L - 1) - affine - softmax也就是说前面的L-1层的每一层，先做一个affine，然后batch norm 在接着激活函数用relu处理一下输出，最后做一个dropout，到最后一层就在一个affine后进入一个softmax层得到神经网络的最终输出。 ","date":"2018-04-22","objectID":"/posts/research/neural_network/:1:0","tags":["神经网络"],"title":"全连接神经网络","uri":"/posts/research/neural_network/"},{"categories":["笔记"],"content":"2.前向传播 前向传播是从输入层开始把每一层的输出递交给下一层直至最后一层将结果输出的过程，在cs231n中前面的L-1层的前向过程如下： affine层对输入做一个线性组合输出affOut： $$affOut = \\sum_{i=1}^{N} wi \\cdot xi +b$$ batch norm层： 得到输出batchOUt relu层： 得到输出reluOut dropout层： 得到输出dropOut 然后在第L层也就是最后一层先进入一个affine层，然后把结果进入一个softmax层得到各个类别的分类概率。 在对每个样本softmax进行求loss得到最后的softmax loss，在加上正则化后为 $$L=\\frac{1}{N}\\sum_{i=1}^{N}Li(W) + \\lambda \\cdot \\sum_{l} \\sum_{i}\\sum_{j}W_{ij}^{l}$$ #代码解释 affOut,affCache = affine_forward(inputX, W, b) batchOut,batchCache = batchnorm_forward(affOut, gamma, beta, self.bn_params[i]) reluOut,reluCache = relu_forward(batchOut) dropOut,dropCache = dropout_forward(reluOut, self.dropout_param) ","date":"2018-04-22","objectID":"/posts/research/neural_network/:2:0","tags":["神经网络"],"title":"全连接神经网络","uri":"/posts/research/neural_network/"},{"categories":["笔记"],"content":"3.反向传播 反向传播其实就是链式求导的一个应用，求loss函数对最后一层输入的求导为： $$dZL = \\frac{dL}{dZ} = \\frac{1}{N}\\sum_{N}^{i=1}\\frac{dLi}{dZi}$$ 到dropOut层反向传播（该层输入 reluOut， 输出 dropOut（当为L-1层的时候dropOut=ZL））： $$\\frac{dL}{dreluOut} = \\frac{dL}{ddropOut} \\cdot \\frac{ddropOut}{dreluOut}$$ 到relu层反向传播（该层输入 dbatchOut 输出 reluOut）： $$\\frac{dL}{dbatchOut} = \\frac{dL}{dreluOut} \\cdot \\frac{dreluOut}{dbatchOut}$$ 到batchout层（该层输入 affOut， 输出 batchOut）： $$\\frac{dL}{daffOut} = \\frac{dL}{dbatchOut} \\cdot \\frac{dbatchOut}{daffOut}$$ $$d\\gamma = \\frac{dL}{d\\gamma} = \\frac{dL}{dbatchOut} \\cdot \\frac{dbatchOut}{daffOut}$$ $$d\\beta = \\frac{dL}{d\\beta} = \\frac{dL}{dbatchOut} \\cdot \\frac{dbatchOut}{daffOut}$$ 到affine层（该层输入 X， 输出 affOut）： $$dX = \\frac{dL}{dX} = \\frac{dL}{daffOut} \\cdot \\frac{daffOut}{dX}$$ $$dW = \\frac{dL}{dW} = \\frac{dL}{daffOut} \\cdot \\frac{daffOut}{dW}$$ $$db = \\frac{dL}{db} = \\frac{dL}{daffOut} \\cdot \\frac{daffOut}{db}$$ ","date":"2018-04-22","objectID":"/posts/research/neural_network/:3:0","tags":["神经网络"],"title":"全连接神经网络","uri":"/posts/research/neural_network/"},{"categories":["笔记"],"content":"4.权重初始化 继续拿这个神经网络来说明，在第一层和第二层中我们都需要对权重进行初始化，每一层的w的维度初始化为本层的输入个数和本层的神经元个数，例如上图中第一层w的维度为3x4的矩阵，b的维度为1x4，第二层权重w的维度为4x2，b的维度为1x2。batchnorm层中beta和gamma的维度都为1xD（D为该层神经元的个数）。 一般w为从高斯分布中均值为0进行初始化，b初始化为0矩阵，beta初始化为0，gamma初始化为1 ","date":"2018-04-22","objectID":"/posts/research/neural_network/:4:0","tags":["神经网络"],"title":"全连接神经网络","uri":"/posts/research/neural_network/"},{"categories":["笔记"],"content":"5.神经网络中的梯度下降 对每一层： $$\\gamma = \\gamma - \\alpha \\cdot d\\gamma$$ $$\\beta = \\beta - \\alpha \\cdot d\\beta$$ $$W = W - \\alpha \\cdot dW$$ $$b = b - \\alpha \\cdot db$$ 然后前向传播求出loss，当loss足够小或者迭代次数足够多的时候停止梯度下降，此时参数即为近似最优解 ","date":"2018-04-22","objectID":"/posts/research/neural_network/:5:0","tags":["神经网络"],"title":"全连接神经网络","uri":"/posts/research/neural_network/"},{"categories":null,"content":"FixIt 主题的离线缓存页面","date":"0001-01-01","objectID":"/offline/","tags":null,"title":"","uri":"/offline/"},{"categories":null,"content":"學習，是我們人生中最重要的課題之一。而在這個學習的旅程中，筆記扮演著不可或缺的角色。 然而，對於許多人來說，如何在海量的資訊中找到關鍵，並將其有系統地整理成筆記，卻是一個巨大的挑戰。 筆記的價值不僅僅在於記錄知識，更重要的是它能幫助我們整理思緒、理解概念，並加深記憶。透過筆記，抽象的知識得以轉化為具體的文字或圖像，讓我們更容易理解和記憶。 然而，很多人對筆記卻抱持著負面的印象。他們覺得筆記是一項繁瑣且無趣的任務，只是為了應付考試或工作上的需求。他們可能會感到困惑，不知道該如何將大量的資訊整理成有組織性的筆記，或是如何將抽象的概念轉化為具體的文字或圖像。這樣的困境往往讓他們對學習產生抵觸情緒，甚至放棄學習。 我希望能夠幫助你解決這個困境。 在這本書中，我將介紹一套簡單卻高效的超人筆記方法。透過這套方法，你將能夠： 不再為課堂上的大量信息或書本中的密密麻麻的文字而感到焦慮。你將學會如何高效記錄資訊，並在筆記中輕鬆自如。 以新的視角重新組織你過去的知識，使其更容易被記憶和應用。你將發現原來你已經掌握的知識延伸出無限可能！ 善用科技輔助，打造一套完全適合自己的筆記系統。你將能夠在不同的場景下運用此系統，快速提升工作和學習的效率。 培養出更優秀的思考模式和記憶方法。持之以恆的筆記習慣，將使你的大腦運作得更高效。 本書分為三部分。 第一部分將教你如何建立一個長期有效的資訊紀錄系統、快速完整捕捉想捕捉到資訊、有條理的消化整理資訊。 第二部分則著重於如何整理並組織這些資訊，讓你可以更靈活地提取和運用所學。 最後，第三部分結合科技，提供一系列技巧，教你如何將抽象的知識實際應用於生活和工作中。 這本書的目標是幫助你建立一個有效的筆記系統，讓你能夠更輕鬆地學習、理解和應用知識。 無論你是學生、專業人士還是對學習有興趣的人，這套超人筆記方法都將對你有所幫助。我希望本書的內容能真正啟發讀者寫筆記、整理筆記、用筆記的熱情，並賦予你極大的超能力，去實現自己的人生目標。 讓我們一起開始這個筆記世界的新冒險吧！ ","date":"0001-01-01","objectID":"/posts/note-hack/00-%E5%89%8D%E8%A8%80/:0:0","tags":null,"title":"","uri":"/posts/note-hack/00-%E5%89%8D%E8%A8%80/"},{"categories":null,"content":"筆記，是人類獲取和記錄資訊的基石，無論在學習或工作中，都扮演著重要的角色。然而，筆記的效率和成效卻是一個普遍存在的問題。 無論是學生抄寫課堂筆記，還是職場上記錄會議內容，人們常常面臨筆記雜亂、找不到重要資訊、或是靈感消失無蹤等困難。 作為一名學習專家，我也曾經為這個問題困擾許久。我曾經試過許多不同的筆記方法和軟體，從最早的手寫筆記本，到後來的Word+資料夾，再到使用Evernote收集筆記，甚至嘗試過心智圖和卡片筆記法。 然而，這些方法和軟體都無法完全解決我在筆記領域中遇到的種種問題。 直到一個契機。當時的我正在研究一套現代筆記軟體，並想舉辦功能讀書會。在會前，我進行了一次意見調查。當時，原本我心中的假想，是大家會對這套這軟體裡面一些細部好奇。 然而，在收到問卷的回饋後，我卻相當意外。大家對於這套軟體幾乎沒什麼疑問。大家所提出的問題，竟然多半是傳統筆記方法所遇到的困境。 這讓我意識到，在筆記流程上。過去似乎我們都有共同錯誤努力。 讀書會總共收到了一百多個回應。 本來，這個讀書會原意，是交流這套軟體的功能。但在看完大家的問卷回饋後，我發現大家在這場讀書會，更加想知道的是更底層的議題是：「究竟如何將筆記做好」？ 讀書會的方向完全錯誤。但這也讓我從中窺見到一個驚天大秘密：筆記是我們在學習路上最常使用的工具，但在過去的教育中從來沒有人教過我們如何做筆記。大家都是憑直覺在暴力作筆記。 這引起了我的好奇心和研究興趣。 ","date":"0001-01-01","objectID":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/:0:0","tags":null,"title":"","uri":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/"},{"categories":null,"content":"重新梳理流程 那麼，我們共同的瓶頸點在哪裡呢？ 我將收集到的問題進行了標記後，發現在這個領域中存在著十幾種、二十幾種、甚至更多不同類型的困擾。 我發現原來筆記界困擾大家的真正問題，並不是單純「如何記錄」以及「如何重新應用」。而是分為五大類，圍繞著：紀錄、整理、搜尋、應用、軟體。 * 如何快速紀錄？ * 如何有效紀錄？ * 如何快速整理？ * 如何有效整理？ * 如何快速搜尋？ * 如何有效搜尋？ * 如何快速應用？ * 如何有效應用？ * 要用哪些方法、工具、軟體做到上述這一切？ 而且，五個關鍵字是以這樣直觀順序排列的： 乍一看到這張新的流程圖，讀者可能覺得十分合理。 彷佛我們天生筆記的流程就應該是這樣進行的。 但是為什麼我們還是在日常筆記紀錄、整理上踢到鐵板呢？ 因為我們正常人，真正在做筆記時，並不是這樣執行的。 ","date":"0001-01-01","objectID":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/:1:0","tags":null,"title":"","uri":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/"},{"categories":null,"content":"現實世界的筆記術：同時紀錄與整理 市面上幾乎所有的筆記法，都在使用相同一個流程： 同時紀錄與整理 同時「紀錄+整理」這樣的方法似乎合乎人類直覺。 但是這個方法，在後續實際操作上。特別是需要搜尋筆記內資訊時，卻變得相當困難。 同時，若後續要將多本筆記的資訊整合在一起，也幾乎是不可能的，需要付出極大的努力。 ","date":"0001-01-01","objectID":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/:2:0","tags":null,"title":"","uri":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/"},{"categories":null,"content":"高效的筆記術：將記錄與整理分開 同時紀錄與整理似乎是一個很直觀合理的筆記技巧。然而，在我對筆記學這門學問進行反思後，我發現這種方法其實非常違反人類大腦的運作原理。 怎麼說呢？ 接下來，讓我來慢慢解析一下人類大腦在上課時的思維過程，希望能幫助你理解這個問題。 一般人的大腦是這樣運作的： 首先，在上課時，人類接收到許多講者提供的資訊和觀點。 其次，基於這些資訊，你會產生自己的想法和詮釋。 這時候，你的大腦會開始快速運作，產生大量的想法。 這時候，大腦面臨一個決策問題： 當接收到外界的信息時，我們到底應該記錄 講者的觀點？ 自己的想法？ 或者兩者的結合? 這也恰恰是我們在做筆記時最容易面臨的困境。 按下暫停鍵，平移時間軸 那麼，又要如何解開這個問題呢？ 一個簡單的方法是，將這些問題分開處理，不要同時處理，一個一個逐個解決。 比如，現在科技很發達，所以可以這樣做： 在「記錄講者觀點」這個動作上，使用錄音筆、錄影機、相機去記錄資訊。這樣一來，就不會有「來不及抄」或「紀錄的不仔細」的問題。 而後就有足夠充裕的時間「寫下自己觀點」。 光是按下暫停鍵，加入一點科技流程，就可以產生很大的改變。 ","date":"0001-01-01","objectID":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/:3:0","tags":null,"title":"","uri":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/"},{"categories":null,"content":"在時限內整理複習 當然，只有前兩者是不夠的。因為沒有經過整理且內化的內容。是無法留存在大腦之中的。 我通常的建議是，在初步抄寫紀錄後，後續得在時限內（大腦記憶的保鮮期限通常是回家當天，當週末，兩周內）撥空，將「講者觀點」與「自己觀點」兩份資料，整理「寫下綜合觀點」，再進行有效的吸收。 這才是執行一份有效「上課筆記」的完整流程。 學習術才是筆記術的核心 在從前，單看「筆記」這個議題，會以為「如何將資訊快速記下」才是重點。但我認為整個筆記術的核心，重點應該是後續的學會用筆記進行「學習」。 畢竟我們記筆記這件事，從頭到尾都是為了「學習」。 而筆記的存在，本就是是為了降低學習過程當中，我們大腦儲存/處理資訊的壓力。 第一：緩衝過濾外界大量的資訊， 第二：切成可以進入大腦的尺寸大小，讓大腦可以在腦中梳理排序，在腦內搭成有效的記憶網路。 只是過去大家都在第一關就摔倒了。 就算僥倖能闖到第二關，也通常也會因為種種因素（耗時、費力、部分遺忘）而放棄。 所以我認為，有效的筆記術應該是 1. 瞭解原先目標：最終是為了強化我們的學習效果 2. 清楚當中流程：而是重新瞭解資訊進到大腦需要五道流程：紀錄 -\u003e 提取 -\u003e 整理 -\u003e 搜尋 -\u003e 應用 3. 用工具提升速度：合理利用現代工具輔助、降低大腦的儲存與搜尋壓力 最終達到筆記境界的終極理想： 能夠快速的捕捉資訊 輕鬆的整理 後續能夠快速搜尋到結果，實戰應用。 利用同樣的流程，可持續不斷的增添新筆記，與過去自己研究的 SOP 、洞見整盒，做到可以彼此串連 逐步累積成自己的私有領域百科。 當然乍聽之下，做起來似乎需要投入不少精力。一般人做得到嗎？ 我向你保證。其實是可以做到的。而且這個新流程實際上是比過去輕鬆省力數倍，而且做起來比大家想像的要簡單得多。 在之前的讀書會上，不少成員在採用了這個新流程之後，僅用了一天的時間就掌握了其要領，三天之內就深深著迷，成為了筆記狂魔。同時，他們也成功建立了自己的知識寶庫。 我出版這本書的原因之一，是因為這個議題一直困擾著太多人。但「合理」的流程實際上非常簡單和高效。我們沒有理由不與更多人分享，造福更廣大的讀者。 ","date":"0001-01-01","objectID":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/:3:1","tags":null,"title":"","uri":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/"},{"categories":null,"content":"解開整理無窮迴圈，記出有效又有用的筆記 我們在本節前段，點出了做出高效筆記的第一個關鍵作法： 放棄同時「紀錄」與「整理」 現在，我們將更深入地探討以下幾個流程步驟： 紀錄 整理 搜尋 應用 軟體 一步一步地探討，我們將讓你的筆記流程變得更加高效和有效! 通過對這些流程的深入理解，你會發現自己在短短幾天內就能逐漸變身成一位筆記達人。 （這張圖等全書定稿之後會重做） ","date":"0001-01-01","objectID":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/:3:2","tags":null,"title":"","uri":"/posts/note-hack/01-%E7%B4%80%E9%8C%84%E6%8F%90%E5%8F%96%E6%95%B4%E7%90%86%E6%90%9C%E5%B0%8B%E6%87%89%E7%94%A8/"},{"categories":null,"content":"許多人陷入無窮無盡的筆記循環中，是因為無法將「記錄」與「整理」這兩件事分開來處理。 更糟糕的是，一般市面上的筆記書籍有時會強化這種錯誤的觀念。我自己也曾閱讀過許多本筆記書，但基本上沒有一本能夠清楚地解釋這一點。 我在這裡強調，若要強化自己的筆記功力，必須得反覆厘清以下這個概念： 紀錄是紀錄，整理是整理。 紀錄是紀錄，整理是整理。 紀錄是紀錄，整理是整理。 將這兩件事情分開，是有效筆記的關鍵第一步。 因為從人類的大腦原始設計上來說，在天生本來就是完全無法做到「同時記錄+整理」筆記的。 在《打造超人大腦 》與《打造超人學習 》這兩本書中，我反覆的提及一個概念： 在我撰寫的兩本書《打造超人大腦》和《打造超人學習》中，我反覆強調一個概念：人類的大腦是單工型的中央處理器。不僅在接收資訊上有上限流速，而且在同一時間內，只能記住3-5件事情。 但是，回到上課抄筆記這件事情上，我們不但同時得暫記講者提及的數個資訊，將之抄寫在紙上。又同時間要捕捉到自己腦袋中產生幾個想法。更同時要決定：要記錄下哪些資訊（講者觀點 / 自己觀點）。 這等於是一秒內幾乎需要同時做出十幾個決定。人類怎麼可能做得來呢？ 我們之前認為同時記錄和整理筆記是可行的，是因為我們從小接受的教育和科技的限制，讓我們以為這是一件很自然的事情。但實際上，我們還沒有學會一種更好的筆記方法，即分別記錄和整理。 然而，我們沒有意識到，對於人類來說，同時記錄和整理在大腦機制的構造上實際上是不可能的，也沒有意義的。 人類的說話速度每分鐘大約是250個單詞，是打字速度的4倍，更是手寫速度的10倍。聽眾根本無法跟上演講者的說話速度進行手寫記錄。 而且，在聽課這件事上，真正有意義的輸出是什麼呢？是自己產生的見解，而不是演講者的原始內容。 因此，我認為同時記錄和整理筆記這件事根本上是人類作不到且沒有意義的。 只有當我們放棄這種執念時，筆記功力才有可能取得突飛猛進的進步。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/:0:0","tags":null,"title":"","uri":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/"},{"categories":null,"content":"使用速度更快的工具或方式做紀錄 我們對於同時進行記錄和整理筆記的想法如此執著，主要是因為我們內心深處對以下兩點感到恐懼： 擔心遺漏重要的信息 擔心在課後沒有足夠的時間重新整理筆記，從而遺忘課堂上的內容 然而，在當今科技高度發達的時代，我們已經擁有許多工具來解決筆記記錄的困擾。例如，錄音機和錄像機可以完整地記錄老師的講解，相機（甚至是手機相機）可以迅速捕捉投影幻燈片的內容。 此外，當前的語音識別技術已經非常成熟，例如中國的訊飛聽見軟件，該機器能夠識別中文錄音內容，準確率高達97%。 因此，在記錄方面，我們完全可以將這項任務交給比我們更先進的機器來完成。這樣一來，就可以將注意力和精力集中在記錄自己在課堂上產生的想法和見解上。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/:0:1","tags":null,"title":"","uri":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/"},{"categories":null,"content":"在記憶的有效時間之內做整理 我們面臨的第二個問題是，即使我們記錄了筆記，但以後可能沒有時間去整理它們。或者當我們有時間整理時，我們對課堂上的內容已經模糊不清，無法進行有效的整理。 然而，我們可以採取一些技巧來解決這個問題。如果我們沒有對信息進行整理和消化，那麼在一天之內，我們仍然可以回憶起大部分內容。但是在一周之內，我們會忘記至少一半以上的內容。兩周後，我們幾乎會完全忘記。 因此，在 1天、1 週、2週這幾個時間點內進行初步的整理是非常重要的，這樣我們就能保留有效的信息，不會遺忘。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/:0:2","tags":null,"title":"","uri":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/"},{"categories":null,"content":"所謂的整理可以是用自己的話重講一遍 儘管我們都知道及時整理筆記的重要性，但大多數人實際上對此非常害怕。他們認為整理筆記是一項龐大的工程，需要花費大量時間來完成。 然而，實際上我們可以將整理筆記分為「粗整理」和「細整理」兩個階段。 按照人腦的機制，當我們用自己的話重新講述上課內容時，這已經是一次「粗整理」。這是因為你的大腦將這些信息重新組織起來，並用對大腦有意義的結構來連接它們，然後通過口述將這些信息再次回放。 只要跑過這個流程一遍，大腦就會有印象。所以，如果你真的沒有時間專心坐下來，重新組織自己手抄的筆記以及機器錄製的音檔語文檔。但花個五分鐘時間，但憑著印象重大致粗講一遍你在上課瞭解到的東西，並不會很難吧？而且這通常還是下課時間可以立刻做的事，對吧？ 而且，甚至我們還可以用點小技巧。將自己重新講的內容，用手機的鏡頭對著自己錄一遍（開直播對朋友講一遍，效果更好。因為講給朋友聽會更有組織更有意圖）。再將這份影片，用聽譯軟體重新轉錄成文字。 所以，「記錄與整理分開」這件事，其實並沒有那麼令人恐懼。用對方法，甚至還會比原先的流程輕鬆很多倍。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/:0:3","tags":null,"title":"","uri":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/"},{"categories":null,"content":"不同場景使用不同的紀錄技巧 當然，我們需要筆記的場景並不僅限於上課。我們只是在「記錄與整理」方面使用了上課作為一個簡單的例子。 在我們的日常生活中，還有許多需要做筆記的情境。這些情境所需要的解決方案、工具和技巧可能各不相同，但基本的觀念卻是相似的。 而這些場景需要的解決方案、工具與技巧其實是「相當不同」的。 （但觀念精神並沒有相差太遠） 以下我會就生活中 90% 的場景一一介紹破解它們的方法。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/:1:0","tags":null,"title":"","uri":"/posts/note-hack/02-0-%E7%B4%80%E9%8C%84/"},{"categories":null,"content":"在開始進入場景之前，我們要先談一點能夠提升紀錄速度與日後查找的小訣竅。 我們之前提到，其實我們完全可以使用機器來取代我們的「筆記記錄」工作。 但是，事實上，我們可以更進一步，甚至可以使用機器來取代我們的「大腦儲存」工作。 這是什麼意思呢？ 我們人類的大腦之所有容易遺忘事情，是因為容量有限。而我們之所謂的「記憶」，並不是「資訊」本身，80% 都只是關於「資訊的索引」。 所以我們完全沒必要去背上很多東西，甚至我們更要把這些東西放在可以很快調用的設備上。 一般人在筆記管理這個議題上，往往有個共同的困擾，就是需要過去這些筆記時，很難找得到或有效調用。 因此，我強烈建議將這些資料和資訊直接電子化成檔案，例如放在Dropbox上，這樣就可以隨時存取。 然後進行簡單的檔案整理，就可以實現「一次寫入，隨處存取」的效果。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/:0:0","tags":null,"title":"","uri":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/"},{"categories":null,"content":"1. 將檔案變成文字 一般来说，我们日常的载体有五大类： 在我們日常生活中，常見的資訊載體可以分為五大類： (1) 文字 (2) 圖片 (3) 書籍 (4) 聲音檔案 (5) 影像檔案 通常，我會將文字、書籍和影像檔案整理成文字檔案。(而聲音檔案和影像檔案則可以透過聽譯軟體轉換為文字) 這樣做的好處在於，現今的電腦內建搜索功能通常非常強大，只需輸入關鍵字，便能輕鬆找到所需內容。將聲音檔案和影像檔案轉換為文字檔案的好處更在於，能夠節省回顧內容所需的精力，快速定位到所需部分，並且能夠對段落資訊進行搜索。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/:0:1","tags":null,"title":"","uri":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/"},{"categories":null,"content":"2. 將檔案變成照片 而我會將 (2)(3) 變成圖片（照相起來），甚至在路上看到一些有趣的事情，刷 FB 看到一些有趣的文章，一樣會用截圖功能保存。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/:0:2","tags":null,"title":"","uri":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/"},{"categories":null,"content":"用符合大脑特性的方法建索引 為什麼要多做這兩件事呢？因為大腦回憶事情的方法，通常只有這兩種： 按照日期 按照關鍵字 一般來說，手機內保存的照片都是用日期排序。要找到前幾天前幾個月發生的資訊，往上滑幾下就可以找到了。 而有了電腦的幫助，即使只記得一些簡單的關鍵字，也能輕鬆地找回當初保存的大量信息。 使用這種方法，你實際上不需要使用特殊的筆記軟件來做筆記。只需利用手機和電腦內建的功能（拍照、截圖、文件搜尋），就能快速且輕鬆地找到所需的信息。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/:0:3","tags":null,"title":"","uri":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/"},{"categories":null,"content":"五種場景模式 以下，我會基於上述這個概念，講解各種場景的的不同筆記法。詳細介紹如何在不同情境下進行筆記，以達到高效且有效的效果。 為什麼不同的場景需要不同的筆記方式呢？ 因為他們的「目的不同」，導致需要的記錄結構與方式也不同。 隨手記需要快速捕捉重要的想法和資訊 上課筆記需要有組織性和完整性 讀書筆記需要深入思考和分析 會議筆記需要快速捕捉與產生會議行動 練功筆記需要目標和反思 選擇適合的筆記方式和工具，能夠幫助我們更好地記錄和理解內容，並提升學習和工作效率。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/:1:0","tags":null,"title":"","uri":"/posts/note-hack/02-1-%E6%8F%90%E5%8D%87%E8%A8%98%E9%8C%84%E7%9A%84%E9%80%9F%E5%BA%A6%E8%88%87%E6%9C%89%E6%95%88%E6%80%A7/"},{"categories":null,"content":"首先，讓我們來談談隨手記。這種筆記方式適用於快速捕捉重要的想法和資訊。 當您在日常生活中遇到一個有趣的觀點或是一個重要的事實時，隨手記能夠幫助您迅速記錄下來，以免遺忘。在這種情境下，您可以使用手機的便利功能，例如語音筆記或是快速筆記應用程式，以便隨時隨地記錄下您的想法。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/:0:0","tags":null,"title":"","uri":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/"},{"categories":null,"content":"Read it Later 「稍候再讀」是指當您在閱讀文章或是網頁時，發現有一些有趣或是重要的內容，但是目前沒有時間可以仔細閱讀或是處理。這時候，您可以使用隨手筆記的方式，將這些文章或是網頁連結記錄下來，以便日後有時間再來閱讀。 有許多工具和應用程式可以幫助您進行「稍候再讀」的筆記。例如，Evernote Clipper 是一個非常受歡迎的工具，它可以讓您將文章、網頁和影片保存到您的帳戶中，以便稍後閱讀。您也可以在瀏覽器上安裝 Pocket 的擴充功能，以便隨時將有趣的內容保存起來。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/:0:1","tags":null,"title":"","uri":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/"},{"categories":null,"content":"Do it Later 「稍候去執行」則是指當您在忙碌的時候，突然想到一些需要處理的事情，但是目前沒有時間可以立即處理。這時候，您可以使用隨手筆記的方式，將這些事項記錄下來，以便日後有時間再來處理。 對於「稍候去執行」的筆記，您可以使用一些簡單的工具，例如筆記本或是手機的備忘錄應用程式、手機語音備忘錄。只要將需要處理的事項寫下來，並在需要時查看這些筆記，以確保不會遺漏任何重要的事情。 有時候甚至不需要使用專門的待辦事項工具，比如說與家人共同要執行的事項。我甚至是直接在 Facebook 或 Line 的家庭群組裡面備忘。 隨手筆記還有分成兩種方向，一種是「稍候再讀」，一種是「稍候去執行」。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/:0:2","tags":null,"title":"","uri":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/"},{"categories":null,"content":"有趣的小事 有趣的小事通常是日常中的小事件，例如在 Facebook 上发现有趣的文章，出门碰到的惊喜，或者别人分享的读书心得等资讯。 如果这些信息是短暂的，我通常会使用手机拍照或截屏来保存，因为这样的成本最低。 如果是在电脑上发现的链接，我会使用 Evernote Clipper 来保存它们的网址。 这些有趣的小事都是按日期存档的，因为它们“不太重要”，只需要在需要的时候按日期查找即可。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/:0:3","tags":null,"title":"","uri":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/"},{"categories":null,"content":"使用日常開啟頻率最高軟體而非專屬軟體 你可能會感到驚訝，我在做這些「稍後閱讀」或「稍後處理」的記錄時，並不是選擇專用的軟體，而是使用日常開啟頻率最高的社群軟體。 這是因為我有幾個考量： 成本最低：如果這些資訊只是短暫的，我通常會使用手機拍照或截圖來保存，因為這樣的成本最低。 按照日期索引：這些有趣的小事都是按日期存檔的，因為它們「不太重要」，只需要在需要的時候按日期查找即可。 開啟頻率最高：在工作上，我使用複雜的專案管理軟體來管理數百個待辦事項。但在日常生活中，我卻幾乎不使用這些軟體，只使用家庭行事曆和家庭專用的訊息群組來溝通。這是因為雖然直覺告訴我們，應該安裝一個家庭待辦事項應用程式，並在上面記錄並提醒自己。但這往往會失敗。我在安裝完待辦事項應用程式後，最大的困擾是忘記打開它（建立一個新習慣很不容易）。因此，我的解決方法是創建一個家人的 Facebook Messenger 群組（專門用於記錄小事），每次想到要做的事或要購買的物品，就拍照或記錄在上面。因為 Facebook 是我日常使用最頻繁的應用之一，我不會漏看或忘記這些事情。 融入固有習慣：這種方法嵌入了我已經有的習慣（瀏覽 Facebook、查看訊息），而不是創造一個新的習慣（使用待辦事項應用程式來記錄和追蹤事項）。所以不容易漏接。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/:0:4","tags":null,"title":"","uri":"/posts/note-hack/02-2-%E9%9A%A8%E6%89%8B%E8%A8%98-read-it-later-do-it-later/"},{"categories":null,"content":"在上課時，筆記需要有組織性和完整性，以便後續複習和學習。 做上課筆記，很多人糾結的重點在於可能是要專心聽還是專心記。要用筆記、打字記還是拍照記？ 但我認為重點都不是以上。而是要先釐清課程的格式。 一般來說，市售課程分兩種，一種是概念聽講型、一種是流程操作型。  聽講型的課程是上課時，老師說你聽  實做型的課程是上課時，老師示範你操作 這兩種課程的上課筆記操作方法，其實是完全不一樣的。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/:0:0","tags":null,"title":"","uri":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"聽講型課程如何做筆記？ 聽講型課程，比較常見的情形是演講或者理論課。 但坦白說上這種課時，非常賭運氣。有的老師一次就能吸住學生注意力一兩個小時，讓學生直到下課都還依依不捨離開。有些老師，剛開場五分鐘學生想放空逃離，或者直接去找周公。 若是遇到後者的情形，真的會非常倒楣，爛老師東拉西扯，自己又無法離場，甚至還得聚精會神，想辦法從裡面找到點乾貨，來對得起當初自己交的學費。 但無論老師本身能力如何，上課做筆記本身就是一件挑戰度相當高的事情。 因為老師提供的信息是通過聲音傳遞的，你必須先將聲音轉化為腦電波，並過濾出需要記錄的內容或者你自己的想法。 而且你無法快速跳過每一秒的聲音。 這也是為什麼上課會讓人感到疲憊的原因，無論是否做筆記，都需要消耗巨大的能量。 然而，有一些方法可以幫助你更有效地做筆記，降低做筆記的成本。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/:0:1","tags":null,"title":"","uri":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"Step 1: 開錄音筆 在上這種聽講課時，我建議的第一個動作，就是開錄音筆。 第一個好處：資訊不會漏接，而且下課時，甚至就能拿到聽譯服務的逐字稿進行複習。 第二個好處：當自己知道無論如何都有錄音筆音檔墊底時，大腦就不會那麼緊張，害怕漏接了什麼資訊，而在一開始就消耗了不必要多的注意力與能量在紀錄(Record)資訊之上。我們可以可以將大部分的能量分配給真正有意義的事情（產生與捕捉洞見）。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/:0:2","tags":null,"title":"","uri":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"Step 2: **觀察老師授課結構 老師的教學能力參差不齊。有些老師只是擅長表達自己的經驗，但實際上他們的授課內容可能雜亂無章，甚至會浪費很多時間。 然而，高效的老師會為他們的授課內容建立一個清晰的結構，使學生更容易理解和吸收知識。 我建議在上課時，不論老師的教學能力如何，都可以花一些時間觀察老師的授課結構。因為一旦你瞭解這堂課的結構，你就可以像有進度條一樣上課了。 這樣的觀察讓你能夠專注於你感興趣的議題，同時放棄你不感興趣的議題，從而節省精力。這樣的學習方式能夠提高你的學習效率，並且讓你更容易記住所學的知識。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/:0:3","tags":null,"title":"","uri":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"步骤3：轉換成主動式學習心態 聽講課讓人感到疲勞的原因是聽課者不知道講課者的教學目標，只能被動地聽取講課者提供的信息並搜索答案。 聽課者預設所有的資訊都應該是重要的，因此花費了大量時間解碼每一段資訊。但最後80%的資訊都是不重要的，能量都被浪費掉了。如果講師沒有講授技巧或者沒有重點，那麼這堂課的學習效果將非常差甚至等於零。 所以換個角度，如果我們上課前先準備一些自己原本就很感興趣的問題，專心在這堂課裡找答案呢？ 有了這些問題，再加上觀察結構。我們就等於開了濾鏡模式，等於所有內容都可以放掉，等到出現自己覺得相關的關鍵內容時，再專注即可。 這樣的心態與方法，就不會讓自己在上課時非常累，甚至反而最後甚至會產生「這門課非常棒，我想知道的都得到了解答」。 這是一種非常不同的積極成果。 即使你錯過了某些部分，也可以通過後續的錄音聽譯和筆記來彌補。看文字和做筆記的好處是可以直接用眼睛搜索要找到的資訊，並隨時快進倒退，而不必從頭到尾重新聽一遍。 這樣你就可以專注於你感興趣的議題，而放棄你不感興趣的議題，從而節省精力。 這種主動式學習心態不僅能提高學習效果，還能幫助你更好地理解和應用所學知識。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/:0:4","tags":null,"title":"","uri":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"Step 4: 只記自己的感想 使用這種方法，你就不需要只是機械地記錄老師講的內容，而可以專注於寫下自己對於所學知識的感想和發現。這樣的筆記方式能夠幫助你更深入地理解和吸收所學的內容，並且讓你在回顧筆記時更容易回想起當時的思考和感受。 這樣的筆記方式才是你上課真正想要得到的結果！ ","date":"0001-01-01","objectID":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/:0:5","tags":null,"title":"","uri":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"Step 5 : 重新講述一遍你的心得，並錄影存檔 最後一步，也是最重要的。 在上完這門課時，立刻找同學、直播、錄影講一遍這個課的 ORID。 ORID指的是： ORID 是 我看見了什麼 我感覺到了什麼 我領悟了什麼 我決定去做什麼 為什麼「立刻重述」這件事情這麼重要呢？ 這是因為在上課之後，我們剛剛得到一些資訊。這些資訊，在我們的大腦中，還僅是一些零散的想法與線索而已。 而經過當場講述這個方法，可以立刻在腦子裡面粗略建構一段用自己觀點表達的「完整新記憶」。 這才是能讓大腦真正產生有效索引的方法。因為大腦本身，只會紀錄 有具體結構的資訊 與我有關的資訊 否則過了幾天，不管當下自己抄了什麼，記錄的多詳細，當天沒有經過這樣一輪的索引創建，大腦一樣會把這些「影像」沖刷的乾乾淨淨。畢竟人類內建的「行車記錄器」硬碟儲存空間有限。 這當中該注意的訣竅有幾個： 強烈建議在上課完的中午或晚上，立刻做一遍。記憶是有關於保存期限的。這個方法等於是立刻作保鮮處理，確保你的記憶能夠長期保存。 講述比書寫更有效。而且講述會在大腦中產生聲音記憶，這樣可以更好地記住內容。 講述的內容比書寫或打字輸出的內容更多。錄制下來後，又可以轉化為逐字稿，這樣你可以更詳細地回顧和總結課程內容。 在當周重新整理資料。口述只是記憶鞏固的第一步，將它整合到已有的知識體系中需要進一步的整理。在後續章節中，我們將深入討論整理的技巧，幫助你更好地整理和組織學習資料。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/:0:6","tags":null,"title":"","uri":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"實做型課程如何做筆記？ 在參與實踐型課程時，有幾個方法可以幫助你有效地做筆記： 錄製視頻或拍攝照片：如果允許的話，使用相機或錄影機記錄老師的每一個步驟。這樣做的原因是因為在實踐型課程中，程序性知識的步驟順序非常重要。這樣你可以在需要時回顧和模仿老師的動作步驟。 問問題：如果你對老師示範的步驟或順序有疑問，可以在下課時詢問老師。這樣你可以更好地理解為什麼順序是這樣，以及一些細節的好處。你可以使用錄音設備記錄下老師的解釋，以便日後回顧。 進行練習：回家後，立即進行一遍的練習。這樣可以幫助你鞏固所學的知識和技能。在練習過程中，你可以將自己的練習結果進行一次講述的 ORID（Objective, Reflective, Interpretive, Decisional）分析，以幫助你更好地理解和記憶所學的內容。 多次練習：在當周至少要做三遍的練習。這樣做的原因是，在學習程序性知識時，我們需要使用肌肉記憶而不是大腦記憶。通過多次練習，你可以更好地培養肌肉記憶，使所學的知識和技能更加熟練。 總之，實踐型課程需要採用不同的筆記方法，包括錄製視頻、問問題、進行練習和多次練習。這些方法可以幫助你更好地理解和記憶所學的內容，並提高你的實踐能力。 这样做的原因是，在学习程序性知识时，我们需要使用肌肉记忆而不是大脑记忆。 沒有萬用筆記本與軟體，但有超級捷徑 為什麼在本章我們要將「記錄」與「應用場景」各個分開講述。是因為很多人在學習筆記技巧時，認為使用一種筆記本格式或一套筆記軟件可以解決所有問題。 然而，實際情況並非如此。即使是在上課中，筆記也可以分為聽講型和實踐型，側重點也不同。因此，對於接下來的四個場景，我們將提供不同的解決方法。 透過上課例子，我們希望向大家展示筆記技巧並不僅僅是暴力記憶和整理這麼簡單。然而，將其分為不同的場景並不是為了讓筆記技巧變得更加複雜，而是反而要讓筆記流程更輕便、結果更有效。 我想要強調的是，要做到有效的筆記，不是通過用大量的粗暴記錄和整理來消耗人體能量。 要做到高效的筆記，我們需要先思考，我們做筆記的真正目的是什麼。然後，利用人類天生的機制和現代科技，找到最簡單的方法。這樣才能事半功倍。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/:1:0","tags":null,"title":"","uri":"/posts/note-hack/02-3-%E4%B8%8A%E8%AA%B2%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"當您閱讀一本書時，筆記需要更深入的思考和分析。 常見讀書筆記的形式有： 划線筆記：通過在書上劃線或標記重點句子，快速捕捉到關鍵信息。 在書上做筆記：在書的空白頁或邊緣做筆記，詳細地記錄自己的思考和理解。 抄句子在筆記本上做筆記：在讀書時遇到一些特別有啟發性或重要的句子，將這些句子抄寫在筆記本上，並加上自己的註解和思考。 寫讀後感：閱讀完一本書後，寫下自己的讀後感和心得。回顧和檢視自己的閱讀成果，並將所學應用到實際生活中。 但究竟在閱讀時，我們應該選擇哪種方式記錄筆記比較好呢？ 我認為我們不應該這樣武斷的推論。 更準確地說，讀書筆記需要根據不同的場景進行分類。 在《打造超人學習》的讀書篇中，我介紹了一種閱讀方法論。 這套方法論，把鑽研一個領域的書，分成三種閱讀模式： ","date":"0001-01-01","objectID":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/:0:0","tags":null,"title":"","uri":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"第一：篩讀 許多人在讀書時，常懊悔自己浪費時間買了難啃難讀或非常水的錯書。但我計算過，其實買錯書非常正常。我自己實測的結果是，買到一本具備正確資訊（符合我們當前程度，且是自己認同且需要）的書，在書市上的機率最多也只有 50% 而已。 如果一開始就花了大筆力氣去精讀一本錯的書，那豈不是把力氣花的很冤枉嗎？ 所以在鑽研一門新領域時，要採取篩讀 -\u003e 略讀 -\u003e 精讀的一個流程。 在第一輪篩讀。只需要大致翻翻拿到的書籍。目的是找到這個領域重要的關鍵字、問題、論述。鎖定一批書可以進行下一輪的「略讀」 在略讀過程中，再過濾出一兩本真正夠好的書，進行精讀。 在略讀時，我們粗略的畫線即可。而在精讀時，才要認真的去做筆記。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/:0:1","tags":null,"title":"","uri":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"如何精讀一本書 ","date":"0001-01-01","objectID":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/:0:2","tags":null,"title":"","uri":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"如何精读 那麼我們又要如何精讀呢？ 而且，就算是精讀。實際上都有分兩種模式：密度低的書與密度高的書，兩者精讀方式是截然不同的。 一般來說，對於資訊密度較低的書。我會採取類似極速讀書法的閱讀方式： 1. 先對這本書準備一些基本的問題。 2. 然後帶著問題搜尋我要的答案 3. 將在書本中看的金句一一複製貼到數位筆記本之內 4. 看完之後再對金句逐一的打上 #tag 做點輕分類 5. 將這本書的金句搜集成一張該書的書籍金句筆記卡 而資訊密度較高的書，我就會反過來操作。 這類書籍，整本書上金句太多，一句一句複製貼上太累。於是我採取的方式是： 1. 一次將一整章書內容貼到數位筆記本內 2. 將不要的句子砍除 3. 將砍剩下的內容重新編排成我自己要的新結構 4. 將這本書當中出現的名詞或概念，在筆記軟體上整理成 「卡片」 5. 重複整理過去的卡片，利用名詞相連，找到相關的資訊比對編刪，重新組織出新的卡片、新的見解。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/:0:3","tags":null,"title":"","uri":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"卡片筆記法 在精讀模式的章節中，對於「將金句複製起來貼到筆記本裡」、「整理成卡片」、「打上 Tag」「用軟體串連在一起」，讀者聽到這套模式可能聽起來很驚奇，會覺得怎麼可以如此操作？ 但這其實是一個幾十年前就被發明的方法，只是當年沒有軟體，筆記方法的設計者，當年用的方式是土法煉鋼的紙質索引卡片。 是的。這套方法就是最近十年開始「紅」起來的卡片筆記法。 卡片筆記法是由德國社會學家盧曼 Niklas Luhmann 所發明。他在 30 年多年間的研究生涯中，一共出版了 58 本著作與數以百計的論文，當中還橫跨多個領域。 當時，他發明了一種卡片筆記法。他將有興趣與搜集到的資訊，隨時捕捉到卡片之上。等到這些資訊卡片累積到一定程度時，就重新整理這些卡片，進行創作。這種卡片筆記法，成了他的高產秘密武器。 這個方法乍聽之下很費工，很多人羨慕盧曼的高產，但很少人會實際去跟隨這個流程，因為光想像流程就覺得很花時間。 但我自己在實測之後，才發現盧曼這種筆記方法，其實一點都不費工，反而非常科學與高效。只是一般人並不知道如何入門這套筆記方法。 卡片流程法在一邊傳統「記錄」-\u003e「應用」的流程，複雜到無法想象。 但是卡片筆記法本身的思維在「紀錄」-\u003e「整理」、「搜尋」-\u003e「應用」-\u003e「軟體」用起來就像雷神之槌般威力無窮。 我曾經用這種方法搭配上現代最新的一套筆記軟體 Logseq閱讀了一套 1200 萬字的美國經濟學古書《Modern Business》。在兩三個月的時間里，寫了兩三千張知識卡片。 這些卡片不僅讓我最後讀透了古典經濟學，從卡片的交叉詞條中，我更從中發現了許多現代經濟學中自相矛盾或虛幻的立論與假設。 我才領教到這套卡片筆記法威力之強大。後續研究各種艱深的探索性學問。我都使用這套方法。並且挖掘出很深的洞見。 作者注： 我們在目前的章節中，卡片筆記法暫時點到為止。 本書的講述結構是幫助大家正確建立梳理資訊的流程和方法，唯有理解：「紀錄」-\u003e「整理」、「搜尋」-\u003e「應用」-\u003e「軟體」這套新流程思維，才揮得動這把槌子。 後續的章節我們將繼續回來為大家講述這套筆記法。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/:0:4","tags":null,"title":"","uri":"/posts/note-hack/02-4-%E8%AE%80%E6%9B%B8%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"這一節我們要討論的是會議筆記。 會議筆記，乍看比上課筆記、讀書筆記棘手。 直觀來說：上課與讀書的資料多數是由專業人士，經過結構化的輸出排而成。會議是不特定人士的你一言，我一語的所構成，且本體又是聲音。做筆記難度看起來高出許多。但改善會議筆記的品質，不如大家原先想的那麼難。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/:0:0","tags":null,"title":"","uri":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"會議筆記的關鍵在於開會技巧 改善會議筆記的重點，並不在筆記技巧本身。 我們之所以覺得做會議筆記困難，是因為職場上許多人不懂開會技巧。會議室經常上演的情形：大家在開會前，毫無準備。在討論時也常你一言我一語的天馬行空發想，拖了幾個小時，最後卻沒有具體的決行結論。搞得與會人苦不堪言。 這樣的會議到底要如何做上會議筆記呢？ 我認為，要改善這件事，本質上是會議結構要進行改變。 我曾在《 遠距工作這樣做》這本書：談到如何高效開會。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/:0:1","tags":null,"title":"","uri":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"1. 使用常態會議流程模版開會 大多數的會議，本身是從流程開始都亂七八糟。 不過，公司內一般常態性的會議，有其目的以及希望產出。而控制流程就可以控制一定的複雜度。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/:0:2","tags":null,"title":"","uri":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"2. 強制要求參會者有「會議是拿來表決，不是拿來討論」的集體共識 與會人常見的會議誤區是：以為會議是拿來討論的。但會議要開的開效的秘訣是：在會議前，大家必須先行提供自己的看法，而會議是拿來表決的。 這一點甚至在 Amazon 這間公司是標配品。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/:0:3","tags":null,"title":"","uri":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"3. 決行或甩鍋 會議記錄之所以必須存在的原因，只有兩個： 決行 或甩鍋到其他人身上。 倒推回去，你會發現一個會議會有只有四個面向需要記： 1. 會議目的 2. 會議上被提出的方案 3. 會議上表決的結果 4. 眾人對方案與表決的分歧意見 當我們使用這個角度去開一個會議的時候，開會與紀錄會議筆記自然就比較容易事半功倍。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/:0:4","tags":null,"title":"","uri":"/posts/note-hack/02-5-%E6%9C%83%E8%AD%B0%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"在練功過程中，筆記需要有明確的目標和反思。 我們在職場上，有時候需要紀錄自己上班所需場景的操作筆記。或是對於學習職場技能時，記一些學習筆記。 又該如何進行呢？ ","date":"0001-01-01","objectID":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/:0:0","tags":null,"title":"","uri":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"Step 1: 將任務先拆分成小問題 拆成小問題的好處是： 當問題顆粒小時，容易完成。當完成時，自己的成就感相對較高。會很像電玩破小章節的爽感。甚至可以解到自己樂此不疲。 而工作上那些難以解決的問題，通常是因為問題顆粒大或是問題模糊。將原始的問題拆分拆散，通常就可以把困難與未知的問題先行隔離出來。將來再回頭進行研究實做，我們在工作上就不容易撞牆或失去方向。 。 而我們將之拆細後，就容易繞著具體的問題去搜集資訊。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/:0:1","tags":null,"title":"","uri":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"Step 2: 將搜集到的相關記錄（包括錯誤訊息），鉅細靡遺的記錄下來 拆成小问题的好处是： 当问题颗粒小时，容易完成，成就感较高 有些问题难以解决是因为问题颗粒大以及模糊，将问题拆分，就可以把困难与未知的问题先行隔离出来。未来再进行研究实做。就不容易撞墙 再来，当我们将之拆细后，就容易绕着这个问题去搜集资讯。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/:0:2","tags":null,"title":"","uri":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"Step 2: 將搜集到的相關記錄（包括錯誤訊息），鉅細靡遺的記錄下來 在學習新技能時，我有一個特殊的習慣：將在學習過程中找到的網址都集中貼在這個任務的留言區中。 我不僅會貼正確的嘗試，也會貼錯誤的嘗試和錯誤訊息。 當然讀者讀到這裡可能會覺得奇怪，貼「正確的嘗試結果」可以理解。為什麼連「錯誤的嘗試與錯誤訊息」都要貼進去呢？ 這是因為「錯誤的嘗試」本身也是一種「正確」訊息。 有時候在挑戰未知的領域時，我們可能會無意中踩到一些坑。如果我們沒有標記出這些坑，下次我們還是會無意中踩到它們。而踩中這些坑也可能隱藏著我們某些觀念不是很正確，這些坑可能也包含一些我們未來需要學習的新信息。 很多人在學習新技能時很是苦惱，因為要記的線索、資料、資訊實在太多太雜了。也散落各處。 所以我自己才會發明了這個方法，等於是在學習練習時，就「錄製」自己學習的過程。且是圍繞著該問題集中錄製。 將來遇到相似的問題，我就可以打開這個紀錄，一撈出來，記憶就全部回來了。 這種方法不僅可以幫助我們更好地記錄和整理學習過程中的信息，還可以幫助我們更好地理解和掌握新技能。通過紀錄下來的錯誤訊息，我們可以更深入地分析問題的根源，並找到解決問題的方法。 此外，這種方法還可以幫助我們建立一個個人知識庫，方便我們隨時查閱和分享。我們可以將這些記錄整理成筆記、文章或者書籍，與他人分享我們的學習心得和經驗。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/:0:3","tags":null,"title":"","uri":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"Step 3 : 事後一定要再單獨整理一篇總結 當然，「錄製」只是這個方法的前半。 另外一半更重要，就是必需要寫總結。 過去我在當程式設計師時，工作或學技能時，都是使用這套方法，紀錄下我解問題所找到的相關資料，然後將問題解開。 我通常在一兩周之內，還會回頭看當時的任務記錄，再總結發表一篇新的部落格作為教學。 這樣做的好處，第一個是複習。 第二個好處，是後面寫的那一篇教學就，是以後遇到類似情形可以立即馬上再利用的「程序性ＳＯＰ」或「概念」文章了。在未來，不管是他人與自己都可以馬上再拿來重複利用。 而不是看著一堆線索筆記或錯誤訊息，再花上與第一次相同的時間研究解決。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/:0:4","tags":null,"title":"","uri":"/posts/note-hack/02-6-%E7%B7%B4%E5%8A%9F%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"無論在哪種場景下，以下原則都可以幫助提升筆記的效果： 分開記錄與整理：將筆記分開記錄和整理，可以讓大腦不再混亂。在記錄時，專注於快速捕捉重要資訊；在整理時，將筆記結構化、歸類和補充。 善用科技軟體：利用科技軟體可以加速和輔助筆記的流程。例如，使用筆記應用程式可以方便地編輯、搜尋和分享筆記；使用錄音或影音工具可以記錄講座或會議的內容。 適應不同場景：在不同場景中使用不同的筆記流程，可以提高效率。例如，在上課時使用結構化的筆記格式，在隨手記時使用快速記錄的方式。 筆記只是一個環節：記筆記只是筆記過程中的一個環節，更重要的是整理、回顧和應用筆記。定期回顧筆記，將其應用於學習、工作或創作中，可以提升筆記的價值。 善用記憶特性：根據大腦的記憶特性，將捕捉回來的線索和資料初步堆積起來。這可以通過使用關鍵詞、摘要和圖表等方式來實現。 保鮮筆記：記憶就像魚肉一樣，有保鮮期。捕捉回來的筆記至少需要進行初步的保鮮處理，例如整理、歸檔和備份。 適用不同記錄方式：不同類型的知識（例如程序和概念）適用於不同的記錄方式。例如，程序可以使用流程圖或程式碼片段來記錄，概念可以使用概念地圖或摘要來記錄。 在接下來的章節中，我們將更深入地探討「整理」這個主題，並提供更多實用的技巧和方法。 ","date":"0001-01-01","objectID":"/posts/note-hack/02-7-%E5%B0%8F%E7%B5%90/:0:0","tags":null,"title":"","uri":"/posts/note-hack/02-7-%E5%B0%8F%E7%B5%90/"},{"categories":null,"content":"在學習的過程中，筆記是一個非常重要的工具。它可以幫助我們記錄重要的知識點、理解概念、整理思緒，並且方便日後複習和回顧。 但「整理筆記」這個議題，平常較少人願意深談，是因為這是一個讓人望之生懼的議題。在一般印象中，這個過程會耗費學習者比「記筆記」這件事還要巨大的能量。 所以，學習者們才會尋求「一邊記筆記、一邊整理筆記」的方法。 但這也是為什麼在筆記這門學問中，入門陣亡的比例這麼高的原因：  在記錄的道路上跑得氣喘吁吁  在一邊記錄一邊整理的道路上雙腳打結，摔個狗吃屎  在整理的道路上，未戰先逃 很少我們聽到有人能夠在「整理筆記」這件事上，是越整理越開心，越有成就感的，最後衣櫃甚至整理的整整齊齊，閃閃發光，聽起來根本是天方夜譚的事。 但其實這樣的方法不僅存在，還相當簡單。 下面我們就會拆解箇中奧妙。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-0/:0:0","tags":null,"title":"","uri":"/posts/note-hack/03-0/"},{"categories":null,"content":"進入「整理」議題之前，在這裡，我想先談一個往往被人遺漏的環節：「提取」。「提取」其實是「整理」環節中一個相當重要的基礎。少掉這個環節，基本上會事倍功半。 因為，嚴格的來說：上一章「記錄」篇，我們所記下的東西，不叫「資訊」，甚至也不叫「資料」，只能叫「線索」。 資訊是有意義的輸入／輸出 資料是可以拿來整理刪改的材料 而我們記下的只能叫「線索」，通往資料的索引。 在我們模糊的感覺中，這三者非常相似。但其實在筆記這個領域中，是有巨大差別的。 過去，我們往往花了半條命，專注記回當下學到的東西，或回家整理了好一陣子。過了兩個月，再回去翻閱寫下的東西，卻什麼都不記得也沒有印象，也不能直接拿來使用。這些，不叫線索叫什麼呢？ 再進一步說，「線索」還是指當下能讓你通往下一道門的材料。我們當時只是記了一些「有趣的東西」，甚至都不是一份「可以直接拿來修改使用的資料」。如果又把線索放到過期了，那就什麼也不是了。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/:0:0","tags":null,"title":"","uri":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/"},{"categories":null,"content":"將線索變成資料 在 [[02-2-隨手記　Read it Later \u0026 Do it Later]] 中我們介紹了如何快速隨手記的訣竅。並說明了第一遍摘下的筆記，其實只需保持時間戳記做為索引。 這是使用大腦的其中一個索引特性：「時間序列」作為原理。我們再將之「標準格式化」（統一轉成文字或用照片收藏），之後就容易使用電腦輔助搜尋。 這個流程叫「線索捕捉」。 不過，若這些材料後續要真正能被使用，要能夠「搜尋」、「挖掘」、「利用」，其實還需要經過進一步的加工。 讀者看到這裡，乍看之下可能會覺得有些麻煩。但其實這是必要的。不然當時記得那麼辛苦，後來卻很難被搜到，搜到以後也沒辦法用。那不是很可惜嗎？ ","date":"0001-01-01","objectID":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/:0:1","tags":null,"title":"","uri":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/"},{"categories":null,"content":"如何正確整理筆記：談談如何「折衣服」 我相當喜歡用一個日常生活中的概念「折衣服」類比到筆記整理的領域上。 能夠快速找到過去的筆記，並很快的能夠重新利用。本質上極像從乾淨且排列整齊的衣櫃裡面找到想穿的衣服一樣。 ![[Pasted image 20230818131533.png]] 我們要學的其實只是一套衣櫃收納術。 問題來了，怎麼入門？而且，雖然我們知道衣服收納的重要性，折好以後可以衣服筆挺，想要穿的時候方便取用。但是其實沒有人喜歡折衣服。 第一個原因：折衣服的過程實在很累。 第二個原因：每個人望到筆記專家的衣櫃都感到羡慕。 但看到自己堆積成山的衣服，以及面前的空衣櫃。一下就浮上超強的無力感。不知道從何下手。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/:0:2","tags":null,"title":"","uri":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/"},{"categories":null,"content":"引入流程化的概念 我曾經也是筆記苦手。也是經過長久的摸索與嘗試之後，才發現當今的筆記術，讓我們在學習時掉進了一個大坑。 簡單來說，當我們在學習筆記術時，或這些筆記術在教學時都犯了一個很嚴重的錯誤。它假設了大家的筆記都應該從衣服堆直接放進衣櫃裡面，邊放邊整理。 試想：每從地上拿起一件衣服，然後要憑空折好，再放進櫃子裡面。擺著擺著又看了不順眼，好像跟型錄上美美的照片，看起來很不像。於是你又把疊好的衣服換個位子，加個隔間，調來調去的。 如果我們有五十件衣服要折，如果使用這樣的流程。恐怕折到第十件時，心靈與肉體就陣亡了。 那我們應該怎樣改善這樣的折衣服效率呢？ 簡單來說，我們 1. 至少要把衣服先分類，相同類型的分成一籃一籃的待折衣物 2. 然後我們再專心的把每一籃的簡單折個大概。相同款式或相同顏色的疊一起。 3. 最後在一籃一籃的收進櫃子裡面 這樣起碼是比較省力與合理的折衣服方式。 至少你懶得折又趕著穿衣服的時候，也可以直接從分好的上衣籃裡面撈衣服出來穿。 ![[Pasted image 20230818131351.png]] 當我們把折衣服的這個概念映射到做筆記上，指的是至少要將資料分籃整理。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/:0:3","tags":null,"title":"","uri":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/"},{"categories":null,"content":"收納衣服第一步：分籃（資訊提取） 那麼，我們又要如何開始呢？ 我們在前述講的將記下來的筆記轉成統一格式（mp3,mp4 轉成文字）。看起來在正常人很多餘。其實是必要的環節。 因為這個步驟可以讓我們的外部大腦（電腦）快速找到 其實就有點像是至少你可以直接去分類好的籃子拉衣服出來穿的意思 不僅以「日」單位可以方便查找。同時我們也可以利用現代電腦的強大，利用關鍵字快速找到我們要的資料，而且隨處可存取。 至少就達到了「方便取用」的第一步。 我自己甚至會將購買過的紙本書，電子化後，透過 Zappier 將 Dropbox 與 Notion 串接。 這樣一來，我就可以快速找到我曾經購買的書籍，並查看我對這些書籍的短評和分類。 同樣地，我也會將網上的影音課程轉換成文字檔，並進行翻譯，以便將其收藏成可搜尋的電子書。（在當今科技，這並不是昂貴不可行的科技。OpenAI 的 Whisper 與 ChatGPT API 就可以做到，而這甚至是我在 OpenAI 的服務誕生以前就利用類似科技在進行定期的資料整理） 這樣，未來在翻找相關資料時，很快就能用進行文字搜尋，而不需要逐個查找影片或視頻。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/:0:4","tags":null,"title":"","uri":"/posts/note-hack/03-1-%E6%8F%90%E5%8F%96%E5%B0%87%E7%B7%9A%E7%B4%A2%E8%AE%8A%E6%88%90%E8%B3%87%E6%96%99/"},{"categories":null,"content":"現在，我們將介紹如何將衣櫃中的衣服進行細分類，並製作一份易於回顧的筆記。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-2-%E5%B0%87%E8%B3%87%E6%96%99%E6%95%B4%E7%90%86%E6%88%90%E8%83%BD%E6%B6%88%E5%8C%96%E7%9A%84%E8%B3%87%E8%A8%8A/:0:0","tags":null,"title":"","uri":"/posts/note-hack/03-2-%E5%B0%87%E8%B3%87%E6%96%99%E6%95%B4%E7%90%86%E6%88%90%E8%83%BD%E6%B6%88%E5%8C%96%E7%9A%84%E8%B3%87%E8%A8%8A/"},{"categories":null,"content":"做出一份日後可以理解回顧的筆記 或許有些讀者會覺得奇怪，為什麼製作筆記需要這麼多步驟呢？ 舊式抄筆記流程，不就是抄 -\u003e 找，就收工完事了嗎？現在為什麼要搞那麼多事？ 這是因為使用舊式抄筆記法。其實問題一大堆，當初抄了老半天，整理的要死要活，幾個月回去後還是看不懂。 那麼，新式的這套方法，就沒有類似問題嗎？ 還真沒有。 或許讀者看到這裡會覺得好像不太可能。 但在繼續之前，我想和大家談談大腦的運作方式，先從人類理解新事物的方法開始： 人類周遭的世界，幾乎每個領域每件事物，都是由多個元素所構成。 所謂，「理解」在大腦中的作用機制，是先回去大腦裡挖掘有沒有「元素」或「結構」相似的過去記憶，再試著與現有經驗結合匹配運行看看。 當我們在腦袋裡面找不到類似的匹配物時，大腦會說「我不理解」。 所以，大部分時候，我們之所以不理解一件新領域的事物。絕大多半的原因可能是： l 「元素」是新的 l 或「結構」是新的。 而教學上的譬喻是對於「理解」這件事是極其有用的。因為譬喻往往是等於將眼前這件事物用你過去記憶曾出現的結構重新表示。 就如同我們正在舉的這個「筆記」折衣服的例子，對於「整理筆記」這件事，我們往往會覺得很麻煩也無從下手。 但以折衣服這件事的結構去譬喻，突然間這問題就好像被解開大半，看起來也沒有那麼困難了。 大腦是否理解一件事物，只看這兩件事是否成立： 元素一致性 結構一致性 這就是為什麼我們在學習過後，捕捉一大堆資料之後，必須要將事物進行適當分解、重構以及整理。。方便大腦消化和理解。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-2-%E5%B0%87%E8%B3%87%E6%96%99%E6%95%B4%E7%90%86%E6%88%90%E8%83%BD%E6%B6%88%E5%8C%96%E7%9A%84%E8%B3%87%E8%A8%8A/:0:1","tags":null,"title":"","uri":"/posts/note-hack/03-2-%E5%B0%87%E8%B3%87%E6%96%99%E6%95%B4%E7%90%86%E6%88%90%E8%83%BD%E6%B6%88%E5%8C%96%E7%9A%84%E8%B3%87%E8%A8%8A/"},{"categories":null,"content":"學習就像是打獵 我再以另外一個打獵的例子解釋「資訊消化」的重要性。 我們可以把上課想像成是去野外裡獵野味，野外雖然有很多動物，但實際上要真的捕捉一支野豬或野兔真的是相當費勁的。 且即使我們真的在外面捕捉到一隻野豬，也不能直接生啃它。 我們需要先將野豬放血、拔毛、剁塊。 放血、拔毛，你可以想像是「筆記處理」。 剁塊是「簡單分類」。 至少我們需要將肉剁成塊狀或切片，才能煮來吃嘛！ 而我們吃肉的方式，多半也是肉片、肉絲，絞肉。很難是直接啃一支豬腿或啃一顆豬頭對吧？ ![[Pasted image 20230818131408.png]] 而且，如果這些肉吃不完，我們也需要進行加工處理，因為記憶就像肉類一樣有保存期限。如果我們在殺豬後的幾天內不進行處理和冷藏，肉就會腐壞，無法食用。 這樣一來，讀者們是否認為同時記錄、整理並立即可以用來複習，之後也能迅速拿出來重複使用是合理的呢？ 簡直是天方夜譚嘛！ 這就是為什麼我們在這堂課裡面說，要做好筆記，必須經過： 紀錄 -\u003e 整理 -\u003e 搜尋（取用）-\u003e 應用 這一道過程。 對應的就是 打獵 -\u003e 整理 -\u003e 切片 -\u003e 下廚。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-2-%E5%B0%87%E8%B3%87%E6%96%99%E6%95%B4%E7%90%86%E6%88%90%E8%83%BD%E6%B6%88%E5%8C%96%E7%9A%84%E8%B3%87%E8%A8%8A/:0:2","tags":null,"title":"","uri":"/posts/note-hack/03-2-%E5%B0%87%E8%B3%87%E6%96%99%E6%95%B4%E7%90%86%E6%88%90%E8%83%BD%E6%B6%88%E5%8C%96%E7%9A%84%E8%B3%87%E8%A8%8A/"},{"categories":null,"content":"線索 -\u003e 資料 -\u003e 資訊，還要經過兩個環節：「總結」與「歸納」。 這兩個詞乍聽之下好像差不多，但其實上本質非常不一樣。 「總結」說的是將資料塞到大分類裡面。 歸納就是切細到小分類。 我相當喜歡「折衣服」這個概念，是因為當很多人聽到，要做出高效筆記，至少要經過「紀錄 -\u003e 整理 -\u003e 搜尋 -\u003e 應用」，四道工序，且最好能夠多次反覆的整理，下次才能很快找到的找到筆記，且找到了筆記之後也能很高效的重新利用……….後，往往直接謝謝再聯絡。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-3-%E7%B8%BD%E7%B5%90%E8%88%87%E6%AD%B8%E7%B4%8D/:0:0","tags":null,"title":"","uri":"/posts/note-hack/03-3-%E7%B8%BD%E7%B5%90%E8%88%87%E6%AD%B8%E7%B4%8D/"},{"categories":null,"content":"收納衣服第二步：總結（用特定格式打包資訊） 許多人做筆記一開始就撞牆的根本原因，是因為他們直接先「歸納」再「總結」，而不是先「總結」再「歸納」。 ![[Pasted image 20230818131453.png]] 總結：塞一起 歸納：折起來 先「歸納」再「總結」等於是從地上的洗衣堆裡面直接拿衣服，馬上折就放進籃子裡面。折到幾件了又發現籃子分類錯，又拿出來調整。結果折好的幾件又被搞得亂七八糟了！ 基本上我們在折衣服時是不會犯基本錯誤的，因為這樣非常沒有效率。 但是我們在整理筆記時卻非常喜歡這麼做，先開個分類筆記本，對著空白的頁面工整的整理謄抄上課筆記，寫了一點之後又發現自己整理的不好，只好再開一個筆記本，寫沒幾頁又覺得自己搞的一團糟，於是就放棄了筆記整理。 這就是先「歸納」再「總結」的大毛病。 要輕鬆整理筆記，我們得「總結」再「歸納」。（注） ","date":"0001-01-01","objectID":"/posts/note-hack/03-3-%E7%B8%BD%E7%B5%90%E8%88%87%E6%AD%B8%E7%B4%8D/:0:1","tags":null,"title":"","uri":"/posts/note-hack/03-3-%E7%B8%BD%E7%B5%90%E8%88%87%E6%AD%B8%E7%B4%8D/"},{"categories":null,"content":"總結 V.S 歸納 這兩個概念非常容易混淆。所以這裡我們要精講這兩個概念。 1. 總結 這裡我推薦使用一套教育界非常知名的知識分類方法「布魯姆分類法」 布魯姆將知識分類成四種不同的知識： 事實知識 概念知識 流程知識 後設知識 所謂的總結，我們可以取用這裡面的概念知識與流程知識。 整理一套流程 什麼是？如何做？用在哪？ 歸結出一張張「流程卡」與「概念卡」。 2. 歸納 歸納是圍繞總結整理出來的流程，去拆解裡面的每一個事實，鑽研如何將裡面的每一個步驟調整的更好。組織圍繞出現的關鍵字。 總結與歸納 所謂先「總結」再「歸納」指的是：先整理「流程」、「觀念」，再整理當中「個別關鍵字的定義」。而不是倒過來。 所以，我們一般在寫筆記或使用筆記軟體都錯了，我們一開始不應該從「分類」或名詞開始，而是要先散寫一篇篇的流程、概念（可以打上日期戳記方便日後尋找）。等累積到一定程度的文章時，我們再整理這些流程，分開到不同資料夾，或者針對裡面重複出現的資訊上#tag，或專門寫一篇名詞解釋並且連結到相關文章。 這個流程與概念與當今直觀的筆記術是完全相反的。但這才是合乎我們日後取用的最有效方式與格式！ 所以，要進行有效的筆記，正確的流程是： Step 1 ：上課當天的下課，將這些知識的 * 流程 * 什麼是？如何做？用在哪？ 先粗略打包成一篇文章，或一個重複講述的 vlog 影片。 Step 2: 週末時梳理成一篇一篇的流程（How to? What is?）。 Step 3：每個月的結尾，再進行關鍵字的精細研究與分類整理。 先「總結」再「歸納」，就可以讓你未來在調用這些知識時，你就發不管是「要搜尋」或「直接應用」都很方便快速了。(直接改了就能用) 這樣一來，當我們回頭看這張流程圖時，是否就比較有感覺了呢？ ![[Pasted image 20230818131514.png]] 是否就比较有感觉了呢？ ","date":"0001-01-01","objectID":"/posts/note-hack/03-3-%E7%B8%BD%E7%B5%90%E8%88%87%E6%AD%B8%E7%B4%8D/:0:2","tags":null,"title":"","uri":"/posts/note-hack/03-3-%E7%B8%BD%E7%B5%90%E8%88%87%E6%AD%B8%E7%B4%8D/"},{"categories":null,"content":"最後，我們想來談談筆記最終去向這個話題。當我們做了那麼多筆記後，如何拿來整合、應用、輸出？ 許多人都曾遇到過這樣的一個問題，用了市面的筆記法，雖然當下做了很多筆記，最後卻無法整合起來。 為什麼會出現這樣的情形呢？ 其實歸根究底的原因，就是這些筆記法，多數只是教你記錄的方法（或當時紀錄整理）。這些當下的資訊線索本身並沒有經過梳理，自然也無法整合。 要真正能夠整合筆記，做到能夠應用、輸出的效果。其實真的必須經過這樣一套資訊淘洗（紀錄 -\u003e 整理 -\u003e 總結 -\u003e 歸納）的過程，才能在後續進行整合動作。 讓我將整套流程圖展開，各位讀者可能就明白了。 我們必須把上課或日常補捉到的散裝知識，先行整理封裝成一篇篇有目的性的知識，後續才談的上要修改或整合甚至是改進。 經過這樣的流程解釋，各位讀者是否有恍然大悟的感覺呢？ 下一章，我們將回到卡片筆記法以及如何用現代工具實做出這樣的效果。 ","date":"0001-01-01","objectID":"/posts/note-hack/03-4-%E6%95%B4%E5%90%88%E6%87%89%E7%94%A8%E6%94%B9%E9%80%B2/:0:0","tags":null,"title":"","uri":"/posts/note-hack/03-4-%E6%95%B4%E5%90%88%E6%87%89%E7%94%A8%E6%94%B9%E9%80%B2/"},{"categories":null,"content":"在第二章時，我們曾提及德國社會學家盧曼以及它的卡片筆記法。 「卡片筆記法是由德國社會學家盧曼 Niklas Luhmann 所發明。他在 30 年多年間的研究生涯中，一共出版了 58 本著作與數以百計的論文，當中還橫跨多個領域。 當時，他發明了一種卡片筆記法。他將有興趣與搜集到的資訊，隨時捕捉到卡片之上。等到這些資訊卡片累積到一定程度時，就重新整理這些卡片，進行創作。這種卡片筆記法，成了他的高產秘密武器。」 各位讀者，在當時可能還對這段敘述，沒什麼感覺。甚至還會覺得盧曼怎麼美國時間這麼多，繞一個大圈去整理筆記？ 事實上，盧曼第一步作的事情就是，將吸收到的資訊，拆散整理： 續再應用時，利用平常歸類好的「流程卡」、「知識卡」就能快速生成新的創作。 這才是盧曼博學多聞且高產的真正秘密！ ","date":"0001-01-01","objectID":"/posts/note-hack/04-0-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95+%E8%BB%9F%E9%AB%94%E5%AF%A6%E6%88%B0/:0:0","tags":null,"title":"","uri":"/posts/note-hack/04-0-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95+%E8%BB%9F%E9%AB%94%E5%AF%A6%E6%88%B0/"},{"categories":null,"content":"卡片筆記法，雖然是盧曼發明的。但盧曼本身並不是這套筆記法的推廣教學者。因為在只有紙筆科技的當時，盧曼這種行為實在太神奇古怪了。 大家雖然敬佩他的卡片整理狂熱度以及產出結果，但實在沒人想真的去模仿學習。 這套筆記法，還是他去世後，另外一個學者申克．艾倫斯Sönke Ahrens，去蒐羅盧曼做學問的方法，最後集結成另外一本書 《How to take smart note》，這套方法才重見於世上。 但，讀者看到這裡可能又會有個疑問？既然卡片筆記法這麼牛，也一堆人在談，為何還是很少看到有人在使用。 我也曾經觀察到這個問題，後來觀察大量入門卡片筆記法的人從入門到放棄的過程，才挖掘出真正原因。 原因在於許多人對於卡片筆記法的入門方式，都是直接在網上 Google。而網上卡片教學法的第一個法門，就是教你將筆記原子化：「一則記事只記錄一件事情」 這一句話讓所有人掉進了大坑。很多人開始做卡片筆記，就是從「名詞」開始寫起。寫了一堆名詞卡一陣子後，學習者發現自己寫了超多卡片，筆記功力與學習功力一點起色都沒有，卡片之間也沒有串連的可能，持續做這件事情下去，自己還或像個傻帽，於是就放棄了！ 這也就是為什麼我在上一章「總結與歸納」時，反覆強調為什麼不可以「先歸納再總結」（先寫名詞定義，再寫個名詞目錄收集），而是要先**「總結再歸納」（先寫粗流程、概念，後續再挖掘關鍵字意義）**的原因。 這個筆記上流程的順序不同，造成的學習效果與筆記效果簡直是天差地遠！！ ","date":"0001-01-01","objectID":"/posts/note-hack/04-1-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%85%88%E7%B8%BD%E7%B5%90%E5%86%8D%E6%AD%B8%E7%B4%8D/:0:0","tags":null,"title":"","uri":"/posts/note-hack/04-1-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E7%AC%AC%E4%B8%80%E6%AD%A5%E5%85%88%E7%B8%BD%E7%B5%90%E5%86%8D%E6%AD%B8%E7%B4%8D/"},{"categories":null,"content":"我們在這個章節會介紹幾種方法讓讀者學會實做卡片筆記。我們會示範兩種版本。一個是只使用 Word 的傳統流程版（比較讓讀者也可以揣摩紙筆版的該怎麼做）。一個是使用科技筆記軟體 Logseq 版的現代流程版。 有一般流程版也有專用軟體版（ 2020 後已經有強大的專業筆記軟體 Logseq可以完全發揮這套筆記法的威力）。 在一般流程版中，我們會假設讀者，可能不想學一套專業軟體，或是就是只有一般文書軟體做筆記。 首先，我推薦的流程作法如下： ","date":"0001-01-01","objectID":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/:0:0","tags":null,"title":"","uri":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/"},{"categories":null,"content":"Step 1開始寫電子日記 只要是能用電腦編數字流水號檔名軟體都可以。比如說你可以製作一個 2022-02-22.doc 這樣的檔案，或在 evernote 等等軟體，開一篇 2022-02-22 的一篇 Note。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/:0:1","tags":null,"title":"","uri":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/"},{"categories":null,"content":"Step 2 把這個 Note 當作當日雜記筆記本 筆記裡面記什麼呢？ a. 記下當天查到的任何關鍵網頁， b. 當天的 ORID c. 當天看的書的 ORID d. 當天學會的小知識（可複製貼上）等等 e. 當天上課學會的簡單流程 ","date":"0001-01-01","objectID":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/:0:2","tags":null,"title":"","uri":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/"},{"categories":null,"content":"Step 3: 當週末（或當週你有空的時間）整理該週累積的 5 篇日記 等到週末時，看著當週累積出的5 篇每日雜記。開始進行粗整理。這個粗整理可能是流程，可能是概念解釋，可能是有趣小知識\u003e 比如說內容之這樣的: - 2022-02-week 1烹飪課 課上學到的 XXX 菜作法 - 2022-02-week 1 烹飪課 關於火候與梅納反應 - 2022-02-week 1 烹飪課 為什麼專業廚師做菜會先熬湯 這些流程也不用很詳細，只要自己寫起來很輕鬆，能夠幫助回憶就好。在寫筆記時，也不要太在意是不是要用自己的話重寫，或是到底是不是複製貼上會觸犯版權什麼的。你只要記得，這是你的私人筆記，你想放什麼都可以。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/:0:3","tags":null,"title":"","uri":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/"},{"categories":null,"content":"Step 4: 當月整理該月的五十篇知識，上 Tag，並且「公開」發表一兩篇自己的想法 到了該月底，你可能累積了已經超過 50 篇小文章。 這時候，你應該可以發現這些小文章，它們之間有類似的元素，你可以把這些元素打上 #tag。 上 #tag 的好處是，某些筆記軟體支援將 #tag 相關的文章一次抓出的功能。有時候累積多了一次抓出來，可能自己還會發現想像不到的文章關連性。 而公開發表自己一兩篇的想法，是要融會貫通你看了這些材料之後，大腦產生的新連結領悟。 不要小看這一個月 50 篇知識、2 篇公開文章的威力。一年累積下來就有 600 篇知識、24篇專文。 這在任何研究者眼中都是非常厲害的成績。 而且最重要的是，我們當時記下來，整理時，其實都是幾乎不太費力的！ ","date":"0001-01-01","objectID":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/:0:4","tags":null,"title":"","uri":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/"},{"categories":null,"content":"示範 : 書的卡片筆記 在前面的章節，我們提到了讀書時如何對低密度的書與高密度的書進行筆記。 低密度的書，如傳記類 《雪球：巴菲特傳》檔名：2022-03-03-雪球-巴菲特傳.doc。 當天： 1. 對這本書準備一些基本的問題: - 巴菲特的投資原則跟別人有什麼不同？ - 他遇到過哪些重要的人改變了他？ - 人生有沒有挫折過？他有什麼啟發 - 他認為投資最重要的原則有哪些 2. 然後帶著這些問題搜尋書中的答案 3. 將在書本中看的金句一一複製貼到數位筆記本之內 然後在該週做： 2022-03-week-3-巴菲特的書讀後-ORID.doc 2022-03-week-3-雪球-投資重要原則與金句.doc 2022-03-week-3-雪球-提到的人名與書名.doc 2022-03-week-3-雪球-股市專有名詞.doc 在該月底做： 發表雪球書籍讀後感 - 購買窮查理的普通常識、費雪-非常潛力股、葛拉漢-智慧型投資人、投資最重要的事(一本股神巴菲特讀了兩遍的書) - 做 ROE / EPS / 成長率 / PE 的名詞研究 而下個月在讀高密度的書：投資最重要的事 反過來做： 1. 直接開 * 2022-04-22-投資最重要的事-ch-01-第二層思考.doc * 2022-04-22-投資最重要的事-ch-02-市場與侷限.doc * 2022-04-22-投資最重要的事-ch-03-估計價值.doc * 2022-04-22-投資最重要的事-ch-04-價格與價值.doc * 2022-04-22-投資最重要的事-ch-05-風險.doc 將書裡面的章節內容，一整章都貼進 doc 檔裡面。 2. 將覺得不是重點的句子整段砍除 3. 將砍剩下的內容，修成自己要的新結構（比如說一章有15個段落。砍成3 個重點段落） 4. 將這本書當中出現的名詞或概念，在筆記軟體上再敵力出来整理成 一张新增的「卡片」 ","date":"0001-01-01","objectID":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/:1:0","tags":null,"title":"","uri":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/"},{"categories":null,"content":"示範 : 上烹飪課（海鮮食材處理）的流程卡片筆記 上课前： 1. 對這門课一些基本的問題: - 如何三去（去頭、去鱗片、去內臟） - 如何有效去腥？ - 如何高效去骨？ - 如何去皮乾淨不連肉？ 下課後前： 1. 馬上記錄今天每一道菜的菜譜流程。 a. 2022-04-week-1-食譜-炸魚塊.doc b. 2022-04-week-2-食譜-宮保花枝.doc c. 2022-04-week-2-食譜-味增魚頭.doc 2. 利用 ORID 寫下一些雜感、心得、豆知識：022-04-week-1-烹飪課-ORID.doc 3. 寫下一些課程上得到的重要訣竅： a. 2022-04-week-1-魚-三去訣竅.doc b. 2022-04-week-1-魚-去腥訣竅.doc c. 2022-04-week-1-魚-採購訣竅.doc d. 2022-04-week-1-魚-去骨訣竅.doc e. 2022-04-week-1-魚-去皮訣竅.doc f. 2022-04-week-1-如何控制菜色鹹度.doc 所謂的卡片筆記法的正確流程，並不是我們在有時間整理筆記時，憑空從腦袋一個一個把某些名詞的定義寫下來放在卡片裡堆起來成卡片堆。相反的是我們要先把「我們記得的一件完整的事情」「打包成一包一包」的格式，後續再有空閒的時再將這些裡面可以抽出來獨立的元素整理拆分成一張一張更小單位的知識卡片。只是當時盧曼快速記東西甚至日記時，他直接用的不是小筆記本而是索引卡片（他速記的第一層載體就是「紙質索引卡」）。 各位讀者看完這套方法如果有興趣，不妨可以用類似的方法實踐一兩週。一定可以很快就看到效果（甚至是堆積如山的成果）。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/:2:0","tags":null,"title":"","uri":"/posts/note-hack/04-2-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-word/"},{"categories":null,"content":"時間來到兩個禮拜後，若照正常進度，這時讀者肯定手上已經有一百來篇的筆記。雖然短時間東西算是好找（因為都有標時間，還可以用電腦內建的軟體輔助搜尋了）。 但是，面對這麼多篇筆記，我們還是希望可以有更有效率的軟體協助我們整理。特別是筆記之間，要是可以用關鍵字自動串連起來就好了。 （如圖） 我們點擊關鍵字，就能自動找到相關曾經記載的資訊。這是最理想的操作模式！ 為什麼我們內心渴求這樣的功能呢？ 我們點擊關鍵字，就能自動找到相關曾經記載的資訊。這是最理想的操作模式！ 為什麼我們內心渴求這樣的功能呢？ 這是因為：在大腦內部，對於記憶本來就是用關鍵字去串連的。透過一串一串的關鍵字，逐漸擴大成關鍵字記憶網路。 只是，我們的大腦始終並沒有那麼大的儲存空間與檢索能量去把我們生活中發生的每一件事都記錄下來，所以我們才要靠外部的儲存空間（也就是筆記），把儘可能的紀錄下來。 但在傳統只有紙與筆的世界，要用紙與筆去達成關鍵字網路這樣的效果，卻是十分困難。理論上我們 1. 只要把自己一篇一篇的筆記重新整理成一張一張的卡片線索 2. 再將卡片與照日期編號，並貼上各種顏色的關鍵字貼紙， 3. 再按照知識領域收到不同的卡盒 將來我們需要檢索時，就可以很快的找到我們要的資訊！（事實上這就是盧曼的卡片筆記法原理） 但實際上每個人都非常懶惰，不可能有美國時間與毅力去做這件事。（更何況一開始可能就搞錯卡片筆記法的步驟了） 但是，現在科技進步了。有沒有軟體可以達到類似的效果呢？更自動、更省力？ 有！這套軟體就是 Logseq，在 2020 問世。當初這套軟體的發表，讓我十分驚喜。 它本身的運作原理，就是使用者書寫一張一張的卡片，透過 [[條目]] 與 #tag ，就可以自動串連起來。筆記者可以直接在當則筆記看到過去「相關」筆記的串連與引用關鍵字。 不僅如此，這套筆記一開始就作對了。 這套筆記軟體新增資訊的預設兩種模式： 日誌」( Journal ) 模式 : 以日期流水線做為頁面名稱 「詞條」(Page)模式: 以詞為單位作為頁面名稱 本身就是搭配大腦記憶運作的方式。 下面我會介紹在 Logseq 下新建筆記的流程方法。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:0:0","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"模式一：日誌模式 Logseq 的兩種模式： 「日誌」( Journal ) 模式 「詞條」(Page)模式。 詞條模式，是在你很確定自己就是要開什麼關鍵字開始撰寫時，直接開該詞條的頁面開始撰寫。 而日記模式是，當你暫時還不知道要放哪時，可以將搜到的資訊貼在「日誌」上。日後再回來整理 正確的操作流程，是應該先「日誌」再「詞條」。 許多想要入門卡片筆記法與Logseq 的筆記愛好者，在第一次接觸到這套軟體時，也有相同的興奮感。但是打開頁面，寫下關鍵字（等於針對名詞寫卡片定義）後，卻不知道怎麼開頭，也不知道如何才能堆積出這樣的網路。 我在前面的章節，提及到之所以會發生這樣的情形。是因為「關鍵流程」錯了。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:1:0","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"Step 1: 先用日誌模式捕捉「線索」 ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:1:1","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"STEP 2: 使用 ORID 模版格式快速組織 通常我會在日誌模式貼入今日隨手搜到的資訊。有時候是邊看邊查邊貼到裡面。不過呢，有時候只是單純想要記錄今天發生什麼事，有什麼感想體悟。 為了更有組織性，我會使用 ORID 的模版變成心智成本最低的答題模式，來增加效率。 * O-“目標”：觀察外在客觀、事實。了解客觀事實的問題句如下： 看到了什麼？ 記得什麼？ 發生了什麼事？ R-“Reflective”：重新看內在感受、反應。喚起情緒與感受的句子如下： 有什麼地方讓你很感動/驚喜/難過/開心？ 什麼是你覺得比較困難/容易/處理的？ 讓你覺得印像深刻的地方？ I-“Interpretive”：勸釋意義、價值、經驗。尋找前描述意義與價值的問題句如下： 為什麼這些讓你很感動/驚喜/難過/開心？ 引發你想到了什麼？有什麼重要的領悟嗎？ 對你而言，重要的意思是什麼？學到了什麼？ D-“Decisional”：找到決定、行動。找到決定和行動的句子如下： 我們有什麼可以改變的地方？ 接下來的行動/計劃會是什麼？ 還需要什麼資源或支持才能完成目標？ 未來你要如何應用？ ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:1:2","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"Step 3: 將這些線索打上 #tag 我並不是一個「隨時整理筆記」的人。不過呢，因為有了 Logseq，我在隨手記完之後，會在我認為有意思的段落或句子，先打上 #tag 。 在 Logseq 中，「詞條」(Page)是與 #tag 直接相關連的。將來若我要整理專有名詞的「專屬詞條」當時這些被打上 #tag 的段落，就會因為內鏈的關係，自動被引入顯示。若覺得看起來雜亂，那時再梳理不遲。 ![[Pasted image 20230626222342.png ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:1:3","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"Step 4: 整理成詞條 [[Page]] 等這些 #tag 線索累積到夠多（大概是 5-10 條），我就會將之整理合併成 [[詞條 ]]。 關鍵字通常是儲存 一個名詞的概述 一個概念的解釋 一套流程的紀錄 等等。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:1:4","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"模式二：[[詞條]] 模式 在 Logseq 中，只要使用 [[關鍵字]] 將關鍵字框住，立刻就可以形成一個該詞的獨立節點。或者是點入 #tag 中，也會連到該關鍵字的詞條裡面。 場景示範：撰寫閱讀筆記 1. 開一篇日誌紀錄我目前正在看的某本書。 2. 這本書可以是密度高的書（使用貼上整本砍句法）或密度低的書（複製金句法）。 3. 等待閱讀到一段落（讀完整本書，或至少 1-3 章）時，開始二次整理。 4. 二次整理時，我會在句子間，針對我認為是關鍵字的地方打上 “[[]]” 標記。尚只有模糊想法的大段落，打上 #tag。 5. Logseq 會針對[[關鍵字]]、#關鍵字 自動進行索引串連。若點進去就是獨立一頁，你可以 Page 詞條就 = 維基百科的條目，這是主條目內容是空白的，但下面注釋方面會自動顯示所有提及到這個關鍵字的所有頁面。 6. 後續你在編輯這個條目時，就可以看著這些相關資訊，快速重新組織這個條目的內容，編寫該名詞卡。 這當中，如果在詞條之內，有看到人名，或書名，我也會立刻先標記人名、或書名卡。通常會有這樣的情況，會是當時摘錄時，原始資訊所提及。 而這往往是重要線索（就我以往的經歷，通常是重要來源，濃度會超高）。 但我在閱讀該本書時已經很忙，現在沒有空再去追閱另外一本書。我就會利用這個方式先記下。有空時再開書籍卡，閱讀被提到的書或作者。 我會另外使用 Logseq 的命名方式Namespace技巧 ，比如說 [[人名卡/巴菲特]]、[[人名卡/查理蒙格]]、[[書名卡/窮查理的普通常識]]、[[名詞卡/價值投資]]。 這樣以後我只要點進 [[人名卡]]，就可以看到下面有兩個條目是巴菲特、查理蒙格。如果這兩個條目日後沒有內容，但我很有興趣知道，日後再找時間繼續補充整理。 作者再次提醒： 我們在製作筆記甚至卡片筆記時，不應該一開始就先寫「名詞卡」。 而是應該先塞進一堆還未梳理的知識，然後幫這堆東西先打 #tag ，等 #tag 累積到一定程度後，再用 page 收集起來。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:2:0","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"模式三： #tag 模式 在 Logseq 中，使用 [[關鍵字]]或 #關鍵字，通通會連到詞條。 可能有讀者會問這兩者使用時機的差別。 基本上我會用 [[關鍵字]] 去框我很確定的「名詞」、「概念」。而使用 #tag 去對一個段落下注解。 而且在使用上，我們甚至可以對一個段落去打上很多個 #tag 做為註解。 比如說在整理資料時，我會偏好先用 #tag 去梳理一沱資料。 以下當時筆記讀書會的問卷回應。為了要快速將這些資料分類。我將所有的回應都先打上 #tag，然後再去統計到底 #tag 的數量。 再逐一合併 #tag，找到真正的大分類。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:3:0","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"模式四： namespace 模式 我們在前面提及了，讀書遇到特別的人名與書名時，我們可以將之拆分出去。這時候會遇到 NameSpace 功能。Namespace 直譯是「命名空間」，用於同一個條目裡面有很多細項時，可以拆出類似資料夾的索引手法。 比如說這是 Modern Business 這套書，廣告這一節的筆記，當初這個詞條資訊量實在太大。於是我用 Namespace 功能，拆成多層去收納。 筆記要拆到多細呢？我自己的原則是筆記最好是維持在 1-2 個捲軸之內可以一目了然看完，太大了我就會拆出去。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:4:0","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"TODO 模式 在整理筆記時，有時候常常讀著讀著就會萌發出新想法，或關鍵字。 但當下沒有空追溯填補。 這時我會使用 TODO / DOING 的關鍵字，將想法變成 Do it Later放著。 等待下次有空時，再接續之前的研究進度。（點入 [[TODO]] 這個詞條就可以看到有哪些條目待辦） ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:5:0","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"模式六： Query Logseq 本身就內建關鍵字關連功能，而 Query 技巧是在當頁面強行拉進你覺得有關的關鍵資料並展現。 通常我會在做研究比對時，利用頁面這個內建功能進行橫向比對。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:6:0","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"模式七： Template Logseq 還有一個進階功能，就是 Template。但本書在這裡不做操作示範。只敘述概念。 Template 是指你可以將類似結構的東西儲存成模版。下次要開類似類型的節點，可以直接用快速鍵複用。 一般來說，我最會常會在 Logseq 上儲存的卡片模版有幾種： 名詞卡 是什麼？ 流程卡 如何做？ 後設卡 如何做得更好？ 書籍卡 相關進階書籍 人名卡 作者相關書籍 模版卡 文章寫作模版 書籍寫作模版 任務跟蹤模版 會議紀錄模版 ","date":"0001-01-01","objectID":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/:7:0","tags":null,"title":"","uri":"/posts/note-hack/04-3-%E5%8D%A1%E7%89%87%E7%AD%86%E8%A8%98%E6%B3%95%E9%AB%98%E7%B4%9A%E6%B5%81%E7%A8%8B%E7%89%88%E4%BD%BF%E7%94%A8-logseq/"},{"categories":null,"content":"vergreen note（長青筆記）是一個用於描述一種永遠保持價值和有用性的筆記或文章的概念。意思是做出一份記不受時間限制，不論過了多久都能保持其可靠性和相對的不變性的筆記。 這種筆記通常涉及一個主題或概念的深入探索，提供有價值的見解、觀點、知識和資訊。高度結構化、時常更新，這份筆記得讀者讓筆記服務的讀者，可以隨時查閱和參考，並且在各種情況下仍然有價值。 這是筆記人在筆記領域的最終目標，但這也是存在夢裡的一個目標。 因為，事實上長青筆記，受限於筆記載具（紙筆、軟體、筆記檢索方式、筆記更新方式）的限制，實在太難達成了。 而且，人類都是懶惰的。我們都希望最好做筆記時，能夠Write Once, Use Anywhere。 這世界上最好可以有人發明套筆記法，能讓我們做到當初只要記一次，後續只要不斷複看這本筆記本，就能達到最大學習效果。 後續再拿出這本筆記本時，也可以從這裡面快速取用資訊，立刻實戰應用。 世界上存在這種筆記法嗎？ 我希望它存在。因為我也懶。 但事實上這套筆記法不存在。 不僅不存在，這個想法還是因為我們受限於紙筆工具，才「幻想」出來的「可能」的解決方式。 我當時在重新梳理筆記流程時，發現這個原因時，也相當震撼。因為在我們一路走來的學習生涯中，一路都在追求這個懶人聖杯，一直都在等終極筆記法出現。 卻從來沒有思考過，其實這個「聖杯」與原先我們用的筆記流程、所做的努力方向、產出效果是如此不合理。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/:0:0","tags":null,"title":"","uri":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"「整理」筆記而不是「寫」筆記 我還想在本書帶出一個新概念，新流程：也就是「筆記」是要用「整理」出來的，而不是寫出來的。 筆者觀看這本書的時候，是否有留意到筆者在數位筆記流程一個不尋常的筆記習慣。就是對於資料的堆積與梳理。都是用錄的、貼的、砍的。 1. 錄下上課的內容，轉成逐字稿 2. 直接複製書籍裡面的金句、段落貼進筆記，砍掉自己不要的 相較於他人的筆記都是「自己重新寫過」。這種大膽的筆記手法，很不尋常。 其實不是我的手法大膽新穎。而是我把動作放大放慢了。 這裡讓我重新播放我們上課時的情景： 這裡讓我重新播放我們上課時的情景： 上課場景 Step 1: 老師講課　（我們抄下內容） Step 2: 我們對於剛剛抄下的內容　（想出我們自己的見解） Step 3: 我們重新看著我們的筆記　（重新寫出新詞條） 看書場景 Step 1: 閱讀書籍　（我們摘抄書上的內容） Step 2: 我們對於剛剛抄下的內容　（想出我們自己的見解） Step 3: 我們重新看著我們的筆記　（重新寫出新詞條） 我做的是 1. 讓機器去做摘抄的動作（對課程錄音或複製書上段落）。 2. 我不馬上重寫筆記，只當「筆記內容編輯」，剪下覺得有價值的段落 3. 我不馬上整理筆記，而是在「有空整理」的時間，透過「整理」的方式，「歸納」出新詞條。 這的確是「筆記流程」: 錄下資訊 -\u003e 篩出有用的內容 -\u003e 重新內化。 但每一步，這個新方法都更省力。「不花腦力」且「不需立刻執行」。 而且效果更好：原始內容保留的更多，自己最終整理的結果，越接近自己的洞見。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/:1:0","tags":null,"title":"","uri":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"用對大腦省力的方式，生出品質更好的筆記 傳統筆記流程之所以辛苦，是因為以下原因。 1. 即時算力要求太高 我們在學習一個新領域時，不但要同時紀錄，還要同時整理，甚至還要同時生成。這對於大腦來說，即時算力的要求太高。 2. 對於新領域掌握不夠 我們對於一個新領域要產生洞見，必然是要先大量蒐集知識，才能解析出他們當中的關連性與重要性。 然而在上課時，光「大量蒐集知識」，我們就沒有足夠的時間與算力可以進行「解析」了。 3. 生成新內容的要求算力太高 大腦生成新記憶的原理並不是憑空創造一段新內容。而是基於「已知的節點」，在彼此之間生成新的連線。 但在學習一個新領域知識時，大腦並不知道哪些是「有效節點」，更遑論生成「有效」連線。 基於這三個原因，上課即時做筆記，對任何人都是苦差事。 但是如果我們改用放大放慢的新流程，去「整理」筆記，效果那就完全不同了。 首先我們是從複製貼上一本書的精髓開始。 1. 首先我們第一個跳掉了「記錄」的步驟。 2. 第二，從中砍掉自己不認同不理解的句子。 3. 第三，以軟體「大量重複」浮現的關鍵字作為基礎，看出「關連」，並以新視角去重新創造「自己的看法」 以這樣的省力流程去「做一份筆記」，不僅分散算力，更能夠把絕大多數的腦力用在關鍵動作：「找關連」，出來的最終筆記，品質反而是比較高的！ ","date":"0001-01-01","objectID":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/:1:1","tags":null,"title":"","uri":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"記憶是基於「重複」而不是「生成」 當然，讀者乍看一下這種新流程，可能會有稍許疑惑，這樣的流程，似乎不過腦，真的能有效吸收？ 讓我來仔細解釋，大腦的記憶原理。這樣的筆記方式，其實並不是「不過腦」，而是「過很多遍腦」。 首先 1. 在整理筆記的時候，首先這個新領域的關鍵概念一定會浮現在你面前「非常多遍」。 2. 我們是在「重複看到非常多遍」同樣的新東西時，覺得放在那邊看起來很煩，於是應該要收納起來「放在一個新地方」，才另開一個詞條「歸納新意義」。 大腦對於一個新資訊是否有意義，判斷的規則是： 1. 是否一直重複 2. 是否與舊記憶中的「元素結構」「重疊」（相同意義） 所以這樣的新流程，首先就會讓我們在閱讀時，看過很多遍。只是一點都不費力而已。 而我們最終又會重寫這個詞條。「重寫」的動作在大腦的角度，就是「生成新的連線」。 而所謂「記憶」是這個「連線」被「重複」刻畫多次。 我們可能會對於這個新流程感到疑慮，那純粹是我們被以前的「費力」才能「記住」這個印象所綁架了。 新的流程可以讓我們在做筆記時五倍省力，而且還有五倍的記憶效果。因為你可以重複這個流程非常多遍卻一點都不累。 同樣的時間與精力，原本我們連抄下筆記的時間與精力都不夠。但在新流程下，我們可以拿來做 3-5 遍以上的粗整理、細整理了。 有經過仔細整理的產出，當然是更好的學習成果。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/:1:2","tags":null,"title":"","uri":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"「洞見」就是原創筆記 讀者對這個筆記法的第二個疑慮：可能會擔心如此寫出來的筆記，最後只是複製原作者一份內容，可能沒有什麼學習上的幫助。 非也，在我的實測成果中，用這樣方式的流程與梳理，透過交叉「整理」「挖掘」，我還常常出與作者截然不同的觀察洞見，產生意外的驚喜。 （我在後面的章節會提到為什麼會有這樣的結果） 讀者對這個筆記法的第三個疑慮：可能是筆記內容的原創性與著作權。 複製與摘抄真的可以嗎？ 首先，我們自己寫的筆記放在我們私人筆記夾裡面的草稿、整理箱。我們摘抄筆記是「使用」作者的內容，但是著作權談的基本上是重新製作與公開。 只要你不公開自己的研究筆記，基本上沒有踩線的問題。 第二，世間作品很少處於原創狀態。大多數的創作與筆記，幾乎都是口水筆記。一定是看了前人的示範資訊，才會有手上的這份筆記。 上面的「概念」「定義」「流程」早就存在世界之中。「概念」與「定義、「流程」的摘錄、整理，並沒有什麼「原創」問題。 而筆記嚴格的定義，指的是你看完這些「概念」、「事實」的「內容組織結構」的一手角度「意義重述」。 最後我們的筆記一定經過自己的多重組織、整理、編修，最後產出的新結構、新想法，最後怎麼可能還會跟原作一樣呢？ 而且，用傳統流程根本不可能造出「長青筆記」，誰有可能有那種「腦力」啊！ 長青筆記當然是要靠這種「複製」、「砍掉」、「重新整理」。才能不斷的進化。保持新鮮。 這本筆記，內容每天可以不斷的進行翻修、增添、重新連結。而且我們還可以輕鬆的從中找到有效的資訊，並快速應用出來。 現在，你知道我是如何在兩三個月內，就讀完千萬字巨作 Modern Business ，並且做出幾千則交叉連結筆記的秘密了吧。 這放在以前，一次讀破經濟巨作並且還能自己整理幾百條新洞見對我來說根本是想都不敢想的事。如今卻完全不是什麼費力的事。甚至，我還越讀越上癮。 好像在玩整理紙箱發現新寶物的尋寶遊戲一樣！ 在此前，我甚至也未想像過做筆記甚至可以是一件能夠成癮的事。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/:1:3","tags":null,"title":"","uri":"/posts/note-hack/04-4-%E6%89%93%E9%80%A0%E4%B8%8D%E6%96%B7%E6%88%90%E9%95%B7%E7%9A%84%E9%95%B7%E9%9D%92%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"我們講完了整理筆記本身。接下來想要談談，如何抽空整理筆記。 我們都知道整理筆記是重要的。但，怎麼擠出時間整理這些線索、資料、資訊呢？ 這個議題是多數人不願面對的最大問題：知道整理筆記這件事是重要的，但我就沒有時間去做阿！ 這個問題看起來很棘手。 但本質上，我認為這個問題，與另外一個問題「什麼時候有辦法擠出時間讀書」？本質上是差不多結構的問題。 我對資訊淘洗的看法是： 讀者可以將書/筆記視為未經清洗上面還沾滿泥土的蔬果。 而我們之前在學習上的誤區，常是以為這種型態的蔬果可以拿來生吃。最後吃下去卻三兩下消化不良、拉肚子。 其實呢，要消化這些資訊，與吃蔬果一樣。 本來就需要清洗、切片、烹調（就算想生吃，至少也要切塊到能塞進嘴巴吧！）。 但，沒有時間做飯怎麼辦？而且是一整塊的時間去做飯。 別擔心，現代人，除了學術研究機構的人之後，有誰是有一整塊時間做飯的奢侈。 但我們可以把做菜的階段劃分出來，你就可以發現，其實他們是可以利用零碎時間進行的。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/:0:0","tags":null,"title":"","uri":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"1. 買菜 買菜可以想像成是從外面吸收資訊。可以是上一堂課程、讀一本書、聽一場講座，路上閑晃捕捉。時間不拘。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/:0:1","tags":null,"title":"","uri":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"2. 洗菜、切菜 洗菜是將這些買進來的菜，「標準化」[[03-1-提取：將線索變成資料]]提及的標準化手法）。 將外面的泥土刷乾淨，並且放入冰箱內。至少得做到想用時，知道放在哪裡，而且塞得進去冰庫，到時候也拖的出來。 這需要一些比較長的時間，建議週末作。 ","date":"0001-01-01","objectID":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/:0:2","tags":null,"title":"","uri":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"3. 做菜、試吃 因為在前一道工序，菜都先被處理差不多了。這時候需要烹調通常只需要切片或加熱。所以通常花不了多少時間：大概 30-60 分鐘。 通常是精煉關鍵字、流程梳理，筆記歸併。重新增添刪減舊筆記 ","date":"0001-01-01","objectID":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/:0:3","tags":null,"title":"","uri":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"4. 消化 而內化後重新分享，可以是小的也可以是大的。 小的：FB 上隨手的感想，直撥上的簡單心得分享 大的：認真的長文發表，投影片整理，課程設計 經過這樣的重新安排，各位讀者是不是發現，其實「持續性」整理筆記，其實門檻並沒有想像的高，反而比原先的舊方法高效許多了呢？ ","date":"0001-01-01","objectID":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/:0:4","tags":null,"title":"","uri":"/posts/note-hack/04-5-%E5%A6%82%E4%BD%95%E6%93%A0%E5%87%BA%E9%9B%B6%E7%A2%8E%E6%99%82%E9%96%93%E6%95%B4%E7%90%86%E7%AD%86%E8%A8%98/"},{"categories":null,"content":"在對搜尋這個議題中，其實還分可以分成兩個細項需求： 快速找到過去曾寫下的筆記 對於想解決的問題，精準找到過去相關的筆記內容加以使用 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:0:0","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"1. 快速找到過去曾寫下的筆記 在傳統的紙筆與筆記方式裡面，要從層層疊疊的筆記中將想要的資訊挖掘出來，再運用基本上是相當困難的。 但經過前兩章我的拆解示範之後，各位讀者應該會有種「什麼，這問題就這麼簡單，我怎麼當初會被困擾這麼久」的感覺。 因為只要讀者按照 03-提取-將線索變成資料 提及的方法，將線索經過  格式處理（轉換成手機、電腦容易搜尋）  檔案是使用日期序列方式排列  檔案使用關鍵字連結 儲放在雲端服務上（如 Dropbox, Evernote） 在現代資訊工具的輔助下，過去的筆記其實很容易就可以被透過「關鍵字」與「日期排序」輕鬆的被打撈出來。 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:1:0","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"2. 對於想解決的問題，精準找到過去相關的筆記內容加以使用 打撈筆記碎片的門檻被降低之後的進一步。我想各位讀者更感興趣的主題是：如何利用過去所累積的筆記資訊，去破解自己想解的問題，找到答案。 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:2:0","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"Step 1: 羅列問題 在一般情況，我們做筆記，面對的都是紀錄已知的資訊，然後試著去整理出一些在結構上我們能夠理解的資訊去做內化。 本章這個「搜尋」問題既簡單也困難。因為對於已知解法的問題，提取筆記內容很簡單。對於未知解法的問題，雖然我們知道過去筆記裡面可能會有答案，但光找到線索都很困難。 有時候，我們在做研究時，有時候想要研究的難題，我們甚至不知道如何定義問題。所以根本不知道怎麼樣找資料！ 這牽扯到一件事，其實我們不僅需要對筆記進行整理，我們對問題也許也要進行整理！ 只要問題定義不清，也沒有被整理清理，就不可能找到後續的答案。 就像我們在研究筆記術這個問題一樣。在此之前，我跟各位可能一樣，過去買了很多筆記書，試著摘要重點。也寫了很多重點。但是在筆記上遇到的問題，就始終沒有被解答過： 筆記速度不夠快，無法快速摘要重點。 筆記散落在不同的筆記軟體中，尋找困難。 筆記整理困難，容易遺忘。 筆記之間的連結關係不明顯。 筆記無法有效地應用和分享。 筆記容易遺失或無法快速找到。 筆記無法有效地整理和歸納。 筆記無法快速記憶和內化。 筆記無法有效地搜尋和提取資訊。 筆記無法有效地轉化為行動。 筆記分類和標籤混亂，尋找困難。 筆記無法有效地記錄和整合不同形式的資訊。 筆記無法快速摘要和理解。 筆記無法有效地連結和串聯不同的知識點。 筆記無法快速找到相關的筆記知識。 筆記無法有效地整理和應用學習心得。 筆記無法快速抓住重點，尤其是跨領域學習。 筆記無法有效地拓展自身能力和領域。 筆記無法快速找到相關內容和解決問題。 筆記無法有效地記錄和回顧個人成長和學習經驗。 在本書，我們只是做了一個不起眼的動作，就是把問題全部羅列出來，然後進行分類。找到筆記問題的五大關鍵字：「紀錄、提取、整理、搜尋、應用」。 在一個一個問題深入探討之後，許多相關問題竟然自己迎刃而解。 是不是很神奇？這是怎麼做到的？ ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:2:1","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"Step2: 整理問題：整理節構再組織 在「研究」這個議題上，我認為絕大多數人有個誤區。就是認為萬物的答案，在書上、筆記上都有答案。只要搜索引擎夠強大，我們一定挖掘的到答案。 這個答案可謂正確也不正確。 正確的是，歷史上，絕大多數的經驗很多都有被保存下來。 不正確的是，我們要尋求答案的領域裡，這個問題的流程節點甚至還未被解開過，所以自然也沒有答案。 如同本書的筆記術一樣。誰想的到筆記關鍵流程最後可以變得如此簡單呢？ 我們只是做了一個簡單的流程：把問題都記錄下來、攤開陳列、切碎、抽取、再重新排序而已。 就如同我們對每篇「新資訊」（上課內容、書籍、外部文章）做的事情一模一樣。 為什麼有這麼神奇的效果呢？ 我想要向你介紹一個既老又新的筆記方法：「KJ 法」。看完 KJ 法的來龍去脈，可能你更清楚為什麼會有這樣神奇的效果。 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:2:2","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"解決問題的實戰創新方法：KJ 法 閱讀過打造超人系列的讀者，應該對於筆者上述舉列的「紀錄、整理、分類、排序、解決」的手法不陌生。我對於任何有挑戰性的問題，都是這樣操作的。 但是這套方法為什麼有效呢？ 老實說，我當初自己也不清楚。我只是軟體專案做的夠多，而且軟體專案往往有時間上（三個月內要做成一套超大系統）的達成壓力。所以我發現了使用這道工序方法超快而已。 我在做軟體時，往往因為用戶需求很多，於是我們先都把這些需求記錄下來。因為軟體功能都有複雜相依性。在時程壓力下，我們就會先設定假設有三個月時間，我們應該要在第一個月、第二個月、第三個月完成哪些要做的事。而且是得先從第三個月倒過來規劃，不這樣規劃的話，很容易因為進度過度樂觀而出包。 因為是倒過來規劃的，於是我們每個月完工的節點與相關計畫就非常明確。加上程式設計領域的特性。每一個工程要求都要有明確的輸入與輸出。於是我們會對於大目標、小目標、任務，都會切的非常細。 工程團隊每天會對任務、小目標，進行施座、釐清、再排序、再串連、捨棄等等動作。 我只是把這套原先工程上我習慣的高速方法，後來搬到我的日常領域來解決各類的問題。 後來我在偶然看到一本 1968年日本出版的書「發想法」時，才意識到原來早就有人發明了非常先進的領域研究方法。 這個方法就是《 發想法》作者「川喜田二郎」發明的「KJ法」（使用他的姓名縮寫而成）。 KJ 法的核心在於研究時，捕捉大量的想法和資訊，再進行分類和整合以解決問題，主要有以下三個步驟: 腦力激盪(Brainstorming):在不批判的情況下提出大量想法。這可以單獨完成,也可以多人共同完成。 標識(Labeling):對上一步得到的想法進行分類歸納,生成標籤。重點是要找到共同點,歸納出主題。 整理(Arrangement):根據標籤將想法進行重組,找到事物之間的關聯和脈絡,進而獲得新的視角和理解。 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:2:3","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"对问题的结构重新组织 在我的研究中，我认为绝大多数人都存在一个误区：他们认为所有问题的答案都可以在书本中找到。只要够勤奋，答案一定就在那里等待被发现。 然而，这种想法并不完全正确。 确实，历史上保存了很多有用的经验。但是，在我们需要寻找答案的领域中，有些问题的经验甚至还未被解开过，因此根本没有答案可供我们参考。 过去，我曾尝试解决这个难题，发明了一种逆向法（详见《打造超人大脑》与《打造超人思维》），即先设定目标，再从各个散落的抱怨中逆向找出真正的症结，一一克服难题，再重新整理出一套更高效的解题顺序。 使用这种方法的原因是，通过这种方式，我能够捕捉到实现目标中间的所有障碍，并将它们转化为相对明确的问题。通过将问题粗略分类，并将其拆分成细节，将单一大问题拆分成足够细的小问题，细化到足以进行类比，并在一般领域中找到类似但明确的答案。然后，通过排列组合，找到更有效率的执行路径，从而创造出新的答案。 这套方法是我在无数个专案执行和知识粹炼的过程中逐渐归纳出来的。 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:3:0","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"三種科學：書齋科學、實驗科學、野地科學 川喜田二郎在《 發想法》提出這樣一個觀點：他認為這世界上所謂的「科學」，實質上還更細分為三種科學。 書齋科學 實驗科學 野外科學 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:4:0","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"1. 書齋科學 什麼是書齋科學呢？ 書齋科學指的是在書齋或研究室內進行理論推理和思考的科學,主要依靠閱讀和推理,很少涉及實地調查或實驗。 市面上很多頭頭是道的書籍很大一部分，是所謂的學者，讀書所「整理」出來的。這些被整理出來的「學問」，有時候是正確的。但有時候是錯誤的。 因為這些學問嚴格來說，並不是被驗證過的「事實」，而是「筆記」。很多時候，只是研究者自己發起一個問題，在書中粗暴的找到覺得還 OK 的主觀答案，最後組織而成的讀書筆記。 書齋科學的弊病是： 1. 重視並依賴先人或古代的文獻和著作，對古典和傳統的過度崇拜,，對後世的知識更新和發展反應緩慢,容易導致學術上的守舊和保守。 2. 過度重視推理而忽視實踐。書齋科學重視頭腦中的理論推理，忽視對實際現象的觀察和驗證。最後導致空談和背離現實，推論出的結論嚴重實際情況不符。 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:4:1","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"2. 實驗科學 實驗科學指的是依靠實驗和觀察驗證理論和假設的科學。它起源於17世紀,典型的有物理學、化學等自然科學領域。 實驗科學具有驗證假設的實踐性。通過實驗可以驗證某個學術假設是不是真實可行，這也使得實驗科學在社會上獲得很高的信用。相比之下，書齋科學提出的看法由於難以驗證其真實性，因此不一定會被社會信任。 實驗科學的工作場所是實驗室，更貼近實際應用。相比書齋科學主要在書齋進行理論探討，實驗科學可以通過實驗設備和操作，觀察假設指示的實際結果。 但實驗科學並非沒有缺點。 1. 實驗科學過於依賴過去的文獻資訊和理論框架。很多時候，實驗的設計和執行都是基於現有理論和知識，容易局限於現有模式，忽視真實世界的複雜性。 2. 實驗科學偏重分析和抽象，較少考慮具體環境因素。實驗環境相對簡單和控制，而真實世界往往很複雜，並不可避免會產生誤差。如果過分依賴實驗結果，可能會導致不適用於實際情況。而且有時候實驗結果並無法複現在現實生活中，因為生活中的環境因素並不如實驗室的單純。可以說實驗科學可能只對某一組控制變因能夠產生出確定結果而已。 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:4:2","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"3. 野地科學 野外科學指的是在現實的野外環境中進行觀察和研究的科學方法。它與實驗科學相對應，實驗科學通常在實驗室控制條件下進行理論驗證。相比而言，野外科學更注重在自然界觀察獲得的數據，並從中發現問題和得到啓發。 野外科學起源很早，人類在漫長的發展歷史中，一直在通過直接觀察和體驗來認知周圍的世界，這就屬於一定程度的野外科學。隨著科學知識的積累，野外科學逐漸形成獨立的學科，例如地理學、人類學等。這些學科通過田野調查和第一手資料的收集，來研究地區和族群現實的真相。 川喜田二郎所在的領域是社會科學。社會科學恰好無法用「書齋科學」或「實驗科學」解決領域內想探究的問題。 因為這門領域的特點是 *通常沒有前書可以推論 也很難在實驗室裡面重現結果（因為沒有辦法創造出無塵環境） 而這門科學最困難的甚至是，如何定義最初的問題？ 其實不只是社會科學。世界上大多數的領域，其實都面臨著這樣的動態挑戰： * 什麼才是真正的問題？  我們又如何挖掘出真正的關鍵並解決  並且把關鍵點解開重新排序成為真正的概念方法  這些概念與方法還要是可重複可證偽且放諸四海皆準的 於是他才提出 KJ 法這樣的解題方法： ![[Pasted image 20230818131622.png]] 先大量搜集資訊以及目前環境中浮現的問題，用索引卡片搜集起來，經過一定的整理、分類，對卡片上的問題，找到合理的流程與公式，最後一個一個攻破，找到更高效的答案後，整合在一起。 經過大量的淘洗之後，這樣產出的最終結論甚至會顛覆原有領域直覺的答案。 我相信，在閱讀本書《打造超人筆記》之前，我想很多讀者，可能一輩子都想像不到筆記是可以這樣整理的，也必須這樣整理： 原來我們大腦的原始設計，無論如何是無法應付一邊紀錄一邊整理的。 原來我們花上許多功夫整理的筆記，很多時候，根本只是沒有辦法重新再利用的線索。 而我們每次整理筆記，從入門到放棄，是因為我們先歸納再總結，而不是先總結再歸納 ","date":"0001-01-01","objectID":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/:4:3","tags":null,"title":"","uri":"/posts/note-hack/05-1-%E6%90%9C%E5%B0%8B%E5%A6%82%E4%BD%95%E6%8E%A2%E7%B4%A2%E6%9C%AA%E7%9F%A5%E5%95%8F%E9%A1%8C%E7%9A%84%E7%AD%94%E6%A1%88/"},{"categories":null,"content":"看到這裡，各位讀者應該會開始知道，這本書本身是怎麼淬鍊出來的？ 我正是類似這樣的方法 + 卡片筆記法 + 筆記軟體 Logseq 做出來的。 當時，我原本試想開一個 Logseq 的讀書會，分享軟體的使用技巧。於是發放了一個讀書會的問卷調查表單，結果沒想到想參加的人，提出的問題，全部都不是針對這門工具的。而大家對於平常在做筆記上，有很多還沒被解決的基礎流程難題。 看完之後。我覺得這些問題，我自己也相當感興趣最終答案。於是在收到這一百多個問題，我就先將問題進行清洗：一條一條貼進軟體內，然後再為它們打上 TAG。 打過了一兩輪 TAG 後，我發現這些問題，主要具攏在五大主題上： 紀錄 提取 整理 搜尋 應用 這五個類別下，有各自大概十數條難題。有些難題是我曾解過的，有些則是我沒碰過但稍微搜尋一下，可能當今世界上答案已經存在的。 我試著將我能回答的問題，一一耐心整理完。一回頭就發現，這裡面經過流程梳理後，筆記世界裡面 90%的問題差不多被就破解完了….. 不僅如此，為了整理出一份易於理解的讀書會投影片。 所以我努力構思了一些較為形象的概念比喻：比如「用折衣服服比喻總結與歸納」、「用打獵切肉比喻資訊淘洗」、「用煮菜吃飯比喻資訊吸收」。 許多相關的細微解法，在比喻的領域流程「搬移」下。甚至也很輕鬆的被挖掘出來。 如果讀者本身是研究者，若要進行一項新領域的挑戰，或者要展開一項新領域、興趣的挑戰，不妨用這個新的「搜索」方法流程、整理你的問題、整理你的筆記看看。極有可能會產出令人驚喜的結果。 ","date":"0001-01-01","objectID":"/posts/note-hack/05-2-%E6%95%B4%E7%90%86%E6%A8%99%E8%A8%98%E9%87%8D%E6%96%B0%E6%AD%B8%E7%B4%8D%E9%A1%9E%E6%AF%94/:0:0","tags":null,"title":"","uri":"/posts/note-hack/05-2-%E6%95%B4%E7%90%86%E6%A8%99%E8%A8%98%E9%87%8D%E6%96%B0%E6%AD%B8%E7%B4%8D%E9%A1%9E%E6%AF%94/"},{"categories":null,"content":"經過以上示範。各位讀者應該不難瞭解為什麼當年發明卡片筆記法的盧曼教授，有辦法橫跨那麼多領域，同時也那麼高產了吧！ 不是靠單靠一套軟體或方法本身，而是我們要對處理的資訊與問題 紀錄 淘洗 定義 結構重整 才能更快速的存取有效資訊，再次利用。 我們前面講述了四大主題：紀錄、提取、整理、搜尋。這一章我們要來深入講應用。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/:0:0","tags":null,"title":"","uri":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/"},{"categories":null,"content":"任何創意工作都可以流水線化 這裡我想要提出一個新穎且令人震驚的觀點，就是使用這套新流程後，關於任何創意工作都可以工業化、流水線化，做到高效產出。 而且這個方法並不是一個假說，而是一個已被實踐的現實。 讓我談談一個你可能不知道的例子。中國最近有一間「讀客文化」出版公司，正在快速的竄紅。但它們其實也不算是快速的在竄紅，而是它們出版的書，在中國這麼競爭激烈的書市，每一部都是現象級的「大賣特賣」。 從「藏地密碼」、「生死疲勞」、「銀河帝國」、「沙丘」。不管是新書還是公版舊書，在它們手上就是能賣爆！ 們之所以會快速竄紅。事實上是大家到最後發現，咦，這些我們不由自主就會買回去的書，怎麼都是「讀客文化」做出來的。 讓我跟你講講一些「讀客文化」震驚的數據與事實： 某一本公版書全市場10年賣了 5 萬本。在讀客手上賣了半年就賣了 15 萬本。 每一本書稿進讀客，不到1個月就可以完成包裝上市。 每一本公版書基本上銷量都是其他人的至少 5 倍甚至 10 倍以上。 讀客那極度吸睛，極度催動人購買慾望的封面，設計與構思時間平均最多花1個小時。（就算你用 ChatGPT 寫文案 與 Stable Diffusion畫設計稿都沒有它們快） 讀客已經把它們全公司的出版流程，細化成 4300+ 的 SOP，正在順暢的執行創意工業化。 換言之，讀客文化完成了一個「白領界」都想要（老闆想要）或不想要（員工不想要）的「現實」：將創意產業工業化，將成功方程式人肉自動化。 How? ","date":"0001-01-01","objectID":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/:1:0","tags":null,"title":"","uri":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/"},{"categories":null,"content":"汽車產業可以工業化、創意產業也可以工業化 讀客文化的老闆華楠在 2023 年初公開了它們的秘密訣竅：讀客方法論。但我覺得比起想法，它們的精神與貫徹執行更加值得令人學習。 這套方法並不是華楠在讀客發明出來的。而是華楠在前一家公司華與華廣告諮詢營銷公司，就摸索出來的。華與華是中國四大廣告公司之一，傳奇中的傳奇，華與華是華楠與華杉共同的創辦公司。坊間流傳的華與華超級符號創造方法就是它們發明的。 華楠受不了廣告業的高強度產出之後，希望把這套方法論移植到廣告可以批量搭載的商品上，也就是書籍市場。後來創辦了讀客文化，才有了這套新的讀客方法論。 將「創意產出」工業化，這種對文化人的天方夜譚的目標。­始於他的一個研究契機：研究汽車工業的工業化始祖 Model T是怎麼被造成的？ 很多人大概難以想象，現在大幅自動化的汽車生產行業。在 100 年前生產效率非常的低。 組裝一台汽車可能需要花費數天到數週的時間，具體取決於該工廠的規模和生產效率。許多零件需要手工安裝和調整，而不像現代生產線那樣可以實現快速且精確的自動化裝配。就算是火力全開。福特在當時 1 年最多也只能生產 10607 輛。 亨利·福特意識到，如果將生產過程分解為一系列的簡單步驟，並讓工人專注於其中一個步驟，然後將汽車在製造過程中沿著流水線進行移動，每位工人只需負責特定的任務，那麼生產效率就可以大幅提高。 福特公司後來借鑒了芝加哥屠宰場的流水宰製流水線，在1913年推出了著名的「T型車」（Model T）並引入了流水線生產技術。這種製造方式使得汽車在裝配過程中按照一定的順序在工作站之間移動，每個工人專注於自己的任務，從而節省了時間和成本。例如，一個工人專門負責安裝輪胎，另一個工人負責安裝引擎，而另一個工人可能專注於安裝車身等。 這種流水線生產方式帶來了多方面的好處。首先，它大幅提高了生產效率，大大縮短了生產時間。同時，由於每個工人只需掌握特定的技能，培訓和人力成本也得以降低。此外，流水線還有助於標準化和質量控制，因為每個車輛都經歷相同的裝配過程，減少了變異性和錯誤。 福特公司的流水線生產模式革命性地改變了整個汽車行業的製造方式，使得汽車的生產變得更加高效、快速且可靠。福特 Model T 汽車流水線在後續的 19 年內，就生產了15458781輛（平均每年80多萬輛）。 而在1948-1975 年，日本的豐田汽車，更提出了豐田生產方式，其中的 Just in Time 與看板(Kanban)工作法，更將整個汽車業界生產效率提高到另外一個境界。 目前汽車生產在流水線化、機器自動裝配化的技術幫助下。特斯拉的中國超級工廠，目前生產汽車的速度是難以令人置信的 1 分鐘 1 台（Model Y）。 正是汽車工業從高度手工業，變成高效自動產出，才讓華楠覺得「創意流水線化」是高度可行的。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/:2:0","tags":null,"title":"","uri":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/"},{"categories":null,"content":"紀錄、梳理、檢核、SOP模版 華楠決定借鑒汽車產業這個概念，對文化產業進行改造。他發動全公司員工「紀錄」日常的各樣出版工作。總共梳理了四千多條 SOP，並且「分類」了八大模塊：版權、研發、生產物流、地面銷售、網絡銷售、全版權運營、營銷推廣、新媒體運營。 並對每一個模塊梳理各自的流水線，並且對流水線上的流程「編號」。 每一個被編號的流程都有 SOP、檢核表、操作模版。這些 SOP 由公司的流程委員會審定。每個員工都可以提出建議改進（並有獎金），經過流程委員會審批之後會更新。所以流程 SOP是週週在改進的「長青筆記」 而且這套流程效率有多誇張呢？本來很多讀客外的同業對這套方法是有存疑的。但讀客也很大方的每個月舉辦讀客工作坊，甚至邀請嘉賓一起參與封面創作，使用它們的「一個小時創意車間」方法創作封面。 我的朋友也曾經參與過這個工作坊，它們在參加這個過程前，從來沒有設計過一本書的封面。在讀客方法的輔助下，一組新手，竟然也在一個小時內完成對市場的調研（稱：尋寶報告）並設計出讀客風格的封面與文化。（再次強調，比 AI 軟體： ChatGPT + Stable Diffusion 雙開還快） 當然，你會對將出版工業化有所存疑。認為會不會扼殺創意？ 讀客認為不會，它們認為正是要將這些瑣碎流程固定化，成功模式結構固定化。員工才可以專注在尋找元素之間的創新。而後續的產出成績與銷售成績也證明了它們這套方法的實用性與可靠性。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/:3:0","tags":null,"title":"","uri":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/"},{"categories":null,"content":"將自己的筆記、工作模版化 讀客的這套流程對筆記方法有什麼啟發呢？ 我們常常認為，工作上日常中學到的概念、是很難被拆解的。抄下來的筆記是很難被複用的，工作是很難被分派出去的、效率是很難被提升的。 但事實上這當中更大的原因只是我們分解的不夠細緻、不夠模版化、不夠流程化。 只要當你能建立起自己的資訊消化流程、累積出足夠的知識模版，你的創意、洞見產出質與量就會快速的提升。 在本章，我將介紹本書在寫作上的素材整理、用到的內容模版，提供大家作為靈感。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/:4:0","tags":null,"title":"","uri":"/posts/note-hack/06-0-%E6%87%89%E7%94%A8/"},{"categories":null,"content":"Step 1: 蒐集所有的困擾 這本書的素材，是由當時我的筆記讀書會上蒐集問題衍生而來。裡面總共有100多條困擾。我大概歸納出大概是需要解決這 20 條問題 筆記速度不夠快，無法快速摘要重點。 筆記散落在不同的筆記軟體中，尋找困難。 筆記整理困難，容易遺忘。 筆記之間的連結關係不明顯。 筆記無法有效地應用和分享。 筆記容易遺失或無法快速找到。 筆記無法有效地整理和歸納。 筆記無法快速記憶和內化。 筆記無法有效地搜尋和提取資訊。 筆記無法有效地轉化為行動。 筆記分類和標籤混亂，尋找困難。 筆記無法有效地記錄和整合不同形式的資訊。 筆記無法快速摘要和理解。 筆記無法有效地連結和串聯不同的知識點。 筆記無法快速找到相關的筆記知識。 筆記無法有效地整理和應用學習心得。 筆記無法快速抓住重點，尤其是跨領域學習。 筆記無法有效地拓展自身能力和領域。 筆記無法快速找到相關內容和解決問題。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/:1:0","tags":null,"title":"","uri":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/"},{"categories":null,"content":"Step 2: 分類 可以將這 20 個主題，粗分為 輸入的場景 想提升的境界 如何進行整理 如何進行搜尋 如何進行高效應用 如何進行跨領域研究 ","date":"0001-01-01","objectID":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/:2:0","tags":null,"title":"","uri":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/"},{"categories":null,"content":"Step 3: 進行研究 對這 20 個主要的問題，進行過去的流程、經驗概念提取、他人解法的研究。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/:3:0","tags":null,"title":"","uri":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/"},{"categories":null,"content":"(1) 概念與流程筆記 1. 點出問題 2. 定義這個問題 3. 敘述流程 4. 怎麼樣把這件事做到更好 ","date":"0001-01-01","objectID":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/:3:1","tags":null,"title":"","uri":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/"},{"categories":null,"content":"(2)觀察與感想筆記 * O-“目標”：觀察外在客觀、事實。了解客觀事實的問題句如下： 看到了什麼？ 記得什麼？ 發生了什麼事？ R-“Reflective”：重新看內在感受、反應。喚起情緒與感受的句子如下： 有什麼地方讓你很感動/驚喜/難過/開心？ 什麼是你覺得比較困難/容易/處理的？ 讓你覺得印像深刻的地方？ I-“Interpretive”：勸釋意義、價值、經驗。尋找前描述意義與價值的問題句如下： 為什麼這些讓你很感動/驚喜/難過/開心？ 引發你想到了什麼？有什麼重要的領悟嗎？ 對你而言，重要的意思是什麼？學到了什麼？ D-“Decisional”：找到決定、行動。找到決定和行動的句子如下： 我們有什麼可以改變的地方？ 接下來的行動/計劃會是什麼？ 還需要什麼資源或支持才能完成目標？ 未來你要如何應用？ ","date":"0001-01-01","objectID":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/:3:2","tags":null,"title":"","uri":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/"},{"categories":null,"content":"Step 4: 寫書籍大綱 我最終將所有的筆記領域，重新梳理出一個新流程：「紀錄 -\u003e 提取 -\u003e 整理 -\u003e 搜尋 -\u003e 應用」 並根據這個五大分類，開始構思大綱。 接著將這些題目整理成詳細大綱，若太長則切割為寫作卡片。 根據每一個大綱的標題，我先粗略展開寫上 5-10 句，我對這個事情的感想。 等感想大致寫完。我再看著這 5-10 句的感想線索、搭配原先問題的關鍵字，重寫成一篇的文章。 而這些文章就會變成一篇一篇有效的資訊。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/:4:0","tags":null,"title":"","uri":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/"},{"categories":null,"content":"Step 5: 重新整理成書籍章節 等到我重新重寫了這 80% 的文章稿。（這通常是第一遍書稿） 我就會進行二次三次的整理。 也許是將所有的內容做成一份更直觀的投影片，透過整理投影片的過程，讓整個內容可以有更立體的濃縮與對比。 又或者是直接重寫成書籍的章節結構，重新調整安排內部的內容比重。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/:5:0","tags":null,"title":"","uri":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/"},{"categories":null,"content":"Step 6: 利用內容矩陣形式，構思章節內的可能標題與內容 Nicolas Cole 在 《The art and business of online writing》提到互聯網上有常見的五種文章形式。 1. 可操作指南(Actionable Guide):提供讀者具體例子和步驟的長篇指南文章。 2. 意見(Opinion):表達作者觀點或立場的文章。 3. 整理清單(Curated List):提供精選信息或資源的清單式文章。 4. 故事(Story):講述一個故事或案例的文章。 5. 可信的評論(Credible Talking Head):邀請專家學者發表專業意見的訪談式文章。 比如我們原先在筆記的這 20 個困擾，按照這 5種文體，就成了 20 篇可以撰寫的角度： 1. 可操作指南(Actionable Guide Form) 如何提升筆記速度，快速摘要重點的技巧和步驟 如何避免筆記遺失和快速找到需要的資訊 如何有效分類和標籤筆記，解決尋找困難 如何整理和應用學習心得的實用步驟和方法 2. 意見(Option) 筆記軟體整合的重要性：為什麼將筆記集中在一個平台上有助於解決尋找困難 簡單筆記整理策略的價值：如何快速歸納筆記內容 整合不同形式資訊的筆記方法：如何記錄和整合文字、圖片、音頻等多媒體資料 在跨領域學習中筆記如何抓住重點 3. 整理清單(Curated List Form) 最佳筆記記憶和內化方法的精選清單 快速摘要和理解筆記的工具和技巧清單 5個有效的筆記整理方法，幫助您避免筆記遺忘 擴展筆記能力和領域的推薦資源清單 4. 故事(Story) 如何運用筆記連結關係解決實際問題：一個成功的案例分享 一位學習者如何透過筆記搜尋和提取資訊，解決學習困境的故事 透過筆記連結和串聯知識點，我如何完成一個跨領域學習專案 如何透過筆記找到相關內容 5. 可信的評論(Credible Talking Head) 專家觀點-分享筆記的最佳方法和工具，提高有效應用和分享能力 專家觀點-對筆記轉化為行動的看法和建議 專家觀點-如何快速找到相關筆記知識，提高學習效率 專家觀點-筆記如何記錄和回顧個人成長和學習經驗的重要性 ","date":"0001-01-01","objectID":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/:5:1","tags":null,"title":"","uri":"/posts/note-hack/06-1-%E5%AF%A6%E6%88%B0%E5%B1%95%E7%A4%BA%E6%9C%AC%E6%9B%B8%E5%A6%82%E4%BD%95%E5%AF%AB%E6%88%90/"},{"categories":null,"content":"前一節利用實際這本書的流程，示範了其實我們只要能將元素拆細。透過模版與元素就可以創造不同種類的內容。 其實非虛構類文體都是可以利用這樣的方式做問題研究。產出時再轉換成不同的載體格式。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/:0:0","tags":null,"title":"","uri":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/"},{"categories":null,"content":"1. Podcast Podcast的腳本大綱結構可以根據不同的節目類型和主題而有所不同，但通常包含以下幾個主要部分： 開場白：開場白是介紹節目的開始部分，可以包括主持人的自我介紹、節目的名稱和主題，以及一個簡短的概述。 主題介紹：在這一部分，主持人可以更詳細地介紹節目的主題，解釋為什麼這個主題是重要的，以及將要討論的內容。 主線內容：這是節目的主要部分，其中主持人和嘉賓或主持人之間進行對話或訪談，討論主題的不同方面。這部分可以根據節目的風格和目的而有所不同，可以是深入的討論、故事分享、問答環節等。 插播音樂或音效：在節目中插播音樂或音效可以增加節奏感和吸引力。這些音樂或音效可以用來引入新的主題、分隔不同的節目部分，或者營造特定的氛圍。 廣告或贊助商宣傳：如果節目有廣告或贊助商，可以在適當的時候插播廣告或宣傳贊助商的內容。這可以是主持人自己朗讀的廣告，或者是預先錄製的廣告片段。 結語：在節目接近結束時，主持人可以總結討論的重點，提供一些結論性的觀點，並感謝嘉賓或聽眾的參與。 結束語：最後，主持人可以結束節目，再次提及節目的名稱和主題，並鼓勵聽眾進一步參與，例如訂閱、評論或分享節目。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/:1:0","tags":null,"title":"","uri":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/"},{"categories":null,"content":"2.知識類 Youtube 知識類 Youtube 影片的腳本大綱結構可以根據不同的主題和風格有所變化，但以下是一個常見的結構： 引言：開場白，介紹自己和影片主題，吸引觀眾的注意力。 問題陳述：提出一個問題或主題陳述，讓觀眾明白影片的目的和內容。 背景介紹：提供相關的背景資訊，讓觀眾了解主題的背景和重要概念。 主要內容：這是影片的核心部分，可以根據主題的不同分為多個小節。在每個小節中，可以使用文字、圖片、影片片段等方式來解釋和展示相關的知識。 實例和案例分析：使用實際的例子或案例來說明和應用所介紹的知識，讓觀眾更容易理解和記憶。 關鍵點總結：在影片接近尾聲時，重點回顧和總結所介紹的關鍵知識點，強調觀眾應該記住的重要內容。 問題回答和互動：鼓勵觀眾在評論區提問或分享他們的想法，並在下一個影片中回答這些問題或回應觀眾的意見。 結語：結束影片，再次感謝觀眾的觀看，並提醒他們訂閱頻道或觀看其他相關影片。 這只是一個基本的腳本大綱結構，你可以根據自己的風格和主題進行調整和修改。重要的是確保影片結構清晰，內容有條理，並能夠吸引觀眾的注意力。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/:2:0","tags":null,"title":"","uri":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/"},{"categories":null,"content":"3.線上課程 線上課程的腳本大綱結構可以根據不同的課程內容和目標而有所不同，但通常包含以下幾個主要部分： 導入部分：介紹課程的目標和重點，激發學習者的興趣，並提供一個概述，讓學習者了解整個課程的結構和內容。 學習目標：明確列出課程的學習目標，讓學習者知道他們將在課程中學到什麼，並能夠評估自己的學習成果。 內容部分：根據課程的主題和目標，將內容分成不同的模塊或單元。每個模塊應該有一個清晰的主題，並按照一個邏輯順序進行組織。在每個模塊中，可以包括教學視頻、演示、案例研究、練習問題等。 互動和參與：線上課程應該提供互動和參與的機會，以促進學習者的參與和主動學習。這可以包括討論區、問答環節、小組活動等。 評估和回饋：在課程中，應該有評估學習者的機會，以確定他們是否達到了學習目標。這可以通過測驗、作業、專案等方式進行。同時，提供即時的回饋和建議，幫助學習者改進和進一步學習。 總結和結束：在課程的最後，總結課程的內容和學習成果，並提供進一步的學習資源和建議，以便學習者繼續深入學習。 這些是線上課程腳本大綱的一般結構，但具體的腳本結構還需要根據課程的特點和目標進行調整和定制。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/:3:0","tags":null,"title":"","uri":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/"},{"categories":null,"content":"4. 論文的撰寫 科學論文的撰寫結構通常包括以下幾個部分： 標題：標題應該簡潔明確，能夠準確描述研究的主題。 摘要：摘要是論文的總結，應該包含研究的目的、方法、結果和結論。摘要應該簡明扼要，能夠讓讀者快速了解研究的內容。 引言：引言部分應該提供研究的背景和動機，說明研究的目的和重要性。同時，引言還應該回顧相關的文獻和研究，並指出研究的研究問題。 方法：方法部分應該詳細描述研究的設計、實驗材料、實驗方法和數據分析方法。這部分應該足夠詳細，以便其他研究者能夠重複實驗。 結果：結果部分應該清晰地呈現研究的主要結果，可以使用表格、圖表或圖片來展示數據。同時，結果部分還應該對結果進行統計分析和解釋。 討論：討論部分應該對研究結果進行解釋和分析，並與相關的文獻進行比較。同時，討論部分還應該討論研究的局限性和未來的研究方向。 結論：結論部分應該總結研究的主要結果，並回答研究的問題。同時，結論部分還可以提出對未來研究的建議。 參考文獻：參考文獻部分應該列出論文中引用的所有文獻，並按照特定的引用格式進行編排。 此外，一些科學論文還可能包括其他部分，如致謝、附錄等，具體結構可能會根據不同的學科和期刊要求而有所不同。在撰寫論文時，還應該注意使用清晰、精確的語言，避免使用模糊或主觀的詞語，並遵守學術倫理和寫作規範。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/:4:0","tags":null,"title":"","uri":"/posts/note-hack/06-2-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E9%9D%9E%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87/"},{"categories":null,"content":"從非虛構類文的的模版。我們不難看出，非虛構類的文體，門檻不在「應用」。只要我們在研究過程中，將資訊梳理拆解的夠細，填入既有模版，應用產生速度就可以高不少。 但是虛構類文體，如故事、小說、劇本可不可以這樣做呢？我本來認為這是非常困難的。 但這個概念，在我讀完 美國劇本大師 Robert Mckee 的新書：《Action: The Art of Excitement for Screen, Page, and Game》後徹底改觀了。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:0","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"1. 先挖掘價值觀 小說、劇本類也可以格式結構化。只是我們之前沒想過可以這樣做而已。 首先，我們必須先選擇載體。因為載體長度會限定你的複雜度。越短的東西能談的東西越少。 但假設我們以一本小說（假設 9 章）之後或劇本選定這個載體後，創作者首先要做的不是寫角色，而是要去思考，想要在這個故事裡面談什麼「主題」，這個主題不是說類型，而是價值觀。 很多人在寫虛構類文體的時候，順序都做錯了。一上來先寫角色，上來先挑類型，一開始就容易陷入發想的死胡同。 我們應該是是先有個很重要的概念，想透過這個載體去傳達，才去開始創作。 所謂「類型」(Genre)只是一般作品在上市時，曾經「容易打動很多人」的東西，才叫類型。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:1","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"2. 選定載體案件 我們必須先選定價值觀，再列一大堆可以大大凸顯這個價值觀的類型，從中挑幾個去找到最適合去凸顯這個價值觀的類型當載體。 我可以舉幾個熱門的例子：拆彈專家2, Breaking Bad, 讓子彈飛, Ozark 等等。 比如說拆彈專家 2 是拆彈專家被退休了以後報復社會，我們應該如何對待因傷退休的專業人士。Breaking Bad 探討什麼是\"壞\"，錢的價值。讓子彈飛探討土匪想正義, 想站著掙錢，結果最後一場忙到底是為什麼? Ozark 是會計師被壞人迫洗錢，毒梟、調查官員誰是好誰是壞。 當然這是個人觀點，不一定正確。我講的不一定對。但是出發點，先發想探討一個社會議題。然後去挖掘。 找到這個價值觀之後，就有很多可以發揮的地方。 首先我們就可以去找這些價值觀，可能發生的最勁爆的社會案件是什麼？我們就可以發現比如：炸彈案、販毒案、土匪搶官府、洗錢好像當相當適合。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:2","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"3. 發想主角職業 有了社會案件。我們就可以找到下一個最重要的主體是什麼？也就是主角是什麼職業？ 主角一定是去做這件事最爭議的人。比如說：拆彈專家放炸彈，化學老師販毒，土匪去當官，會計師去洗錢。 虛構類的創造大原則，本質上就是要勁爆，白話文就是「新奇」與「衝突」。 新奇：在日常生活道德價值觀內不太可能發生 衝突：探討一個價值觀的正反兩面 所以，我才說進行創作前要先定價值觀。定了價值觀再找震驚社會的社會事件。然後再找誰最不可能幹這件事，瞬間就可以找到一堆可能的素材。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:3","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"4. 前進與後退：主角與反派 很多人的虛構類創作，一開始上來就描寫角色的背景故事與成長。寫的又臭又長又平淡。最後就爛掉了。這是因為不懂的故事最重要的核心，就是要討論「價值觀」。 我們應該是要有一個想討論的「價值觀」，才能依此去發想角色。 一開始角色也不用多，兩個就好：就是主角與大反派。 主角就是在這個主故事線裡面一直想前進的人，大反派就是一直想讓它後退的人。 整個劇情就是圍繞他們在一個主故事線上一個往前進，一個一直讓它往後退。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:4","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"5. 鋪陳故事線 我們回到寫故事上。一般來說故事都是一個 3 Act 的套路。 Act1 主角的成長與鋪陳 Act2 主角第一次相遇小戰爭 Act3 主角與反派的最終戰爭 有了價值觀、案件、主角與反派，我們就可以開始進行填充。 主角如何前進 大反派讓主角後退 這裡有一個常見的結構。假設一個劇本內容是 45 分鐘。那麼則在這個劇本的 1/4 段前，就會有一個觸發事件 (Inciting Event)。 這個觸發事件通常是觸發主角從「平凡人」變成「主角」的一個刺激性事件。 比如 Breaking Bad 的 Inciting Event 就是主角 Walter White 被診斷出罹患絕症型肺癌。他是一個高中化學老師，本來生活得過且過，但經濟負擔很重。醫生給他的肺癌診斷讓他對未來感到絕望，驅使他去尋找一種不尋常且極度危險的方式來確保他的家庭在他過世後的經濟穩定。他選擇製造並銷售冰毒（methamphetamine），並與前學生 Jesse Pinkman 合作。 這個事件導致了整個系列的主要劇情，推動 Walter White 沉淪至犯罪世界，並導致他的人格變化，從謙卑、害怕的高中老師變成冷酷無情、不擇手段的毒品大亨。這是一個他的道德和倫理價值觀的逐步崩解的故事，由於他在壓力和生存的需要之下做出的一連串選擇。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:5","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"6. 寫出劇本 Plotline 並引出正派配角與反派配角 劇本的 plotline 是指故事的情節線索或劇情發展的脈絡。 一開始在創作劇本時，並不需要先描寫細節。只需要粗寫故事的起伏、發展和高潮，以及角色之間的互動和事件的轉折點。 一個劇本的 plotline 包含了主要的情節、衝突、解決方案和結局，以及人物的目標、動機和成長。在劇本撰寫和電影、戲劇或電視節目製作的過程中，它是一個重要的元素，有助於確保故事的流暢性和吸引力。 當我們有了 plotline 之後，就可以引出正派配角與反派配角。正派配角幾乎無例外會在「Act1 主角的成長與鋪陳」出場，反派配角會在「Act2 主角第一次相遇小戰爭」出場。而正反派配角中幾乎會有一個人在正反間橫跳，比如原本有一個人是一直幫助主角的，此時會突然叛變幫助反派。或者是反過來一直欺負主角，在緊要關頭叛變幫助主角。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:6","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"7. 以卡片為單位構思情節 聽到這裡，其實各位都發線了，創作劇本一開始並不需要寫實際詳細內容。多半時候我們只需要先寫「卡片」。 價值觀卡片 案件卡片 主角與反派卡片 Act 1,2,3 主線卡片 主情節卡片、主衝突卡片、結局卡片等等 以卡片為基礎的故事創作，會讓過程變的相對簡單很多。比如說主角與反派可能是一體兩面。也就是勇者跟魔王其實是同一種人，魔王其實是財富自由崩壞過的勇者 XDDDD 正派配角與支線就是協助主角往前進的東西 反派配角與小衝突就是把主角中間往後推的東西。 劇本創作裡面還有一個情節裝置：“MacGuffin”。這個物品比較像是一個劇情橄欖球，誰拿到去壓線就有壓倒性的勝利。像是復仇者聯盟的寶石一樣。故事就在雙方互相搶奪MacGuffin中，逐漸推進，精彩萬分。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:7","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"8. 以場景為單位衝突 多長的載體決定了角色的立體度與劇本的反轉程度。 可以以場景為單位。也可以以時間為單位。 比如說，一部電影2小時120分鐘，5分鐘一個scene，總共要想24個 scene。 但這世界上的故事結構是重複在循環發生的。 比如拆彈專家2這部高潮迭起目不轉睛的電影，仔細分析的話，你就會發現這個電影實質上把36個經典故事衝突，抽出了24個，換成警匪皮在每5分鐘用不同方式轟炸觀眾。 但美劇一季有20集，可以談的更多。每一集只要講一個事件就好。 120 分鐘、45 分鐘、25 分鐘能談的內容不一樣。比如說《黑鏡》這種影集類，雖然劇情讓人深刻，角色就不夠立體。這是因為每種載體能承載的信息量不同，越長的載體越能承載更多的角色，越多的維度。而越短的載體則越突出想探討的價值觀，而削弱角色的立體度。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:8","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"9. 用 Excel 寫故事 從資深編劇的說法，聽到這個方法時，我也非常的吃驚。但這竟然是業界的常態。因為我沒想過原來大部分的故事與編劇是這樣創作出來的。 因為拍攝的需要，某一些類型刺激強度不夠或某一些主角的職業張力不夠。所以編劇常常需要「重寫故事」、「重寫角色」。 這世界上有很多模版能輔助創作 類型(Genre) 的固定方式套路及其配套的核心價值 故事衝突的固定套路 主角成長的固定套路 情節裝置（MacGuffin）的固定格式 經典情節的固定表現方式 雖有格式，但人類是無法對這麼多選項進行融合創作，所以反而要透過 Excel 對這些模版的亂數抽樣，激發新的「靈感」，不斷的創作與重寫。 ","date":"0001-01-01","objectID":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/:0:9","tags":null,"title":"","uri":"/posts/note-hack/06-3-%E5%A6%82%E4%BD%95%E5%89%B5%E4%BD%9C%E8%99%9B%E6%A7%8B%E9%A1%9E%E6%96%87%E9%AB%94%E5%A6%82%E5%B0%8F%E8%AA%AA%E5%8A%87%E6%9C%AC/"},{"categories":null,"content":"在這本書的結尾篇章中，我想總結整個書籍的內容和，並回顧一開始提出的問題。 這本書的目標是幫助讀者解決筆記的困擾，並提供一套簡單卻高效的超人筆記方法。 我們在書中介紹了一套新的筆記流程：「紀錄 -\u003e 提取 -\u003e 整理 -\u003e 搜尋 -\u003e 應用」。 紀錄篇：提出了一套「記錄」與「整理」分開的關鍵概念，幫助讀者節省腦力，但能捕獲更多訊息。 提取篇：提出了一套符合大腦科學原理的提取方法，將記錄下的線索格式化成大腦與電腦易於檢索的關鍵字與日期形式，輔以現代科技可以快速找到過去相關筆記內容。 整理篇：筆記整理本來是一個令人望之生懼的議題。但是若我們若像折衣服的流程去將資訊「總結」與「歸納」。或許不需要那麼耗費腦力就能二次吸收資訊再利用。令人羨慕的長青筆記不是透過「寫出來的」，而是「整理」出來的。 搜索篇：一般做筆記有兩大需求：「快速找到過去曾寫下的筆記」和「用筆記破解想解決的問題」。並且介紹了野外科學先進的解題的方法，讓讀者能夠更好的利用「筆記整理」這件事，反過來破解在領域應用探索時的難題。 應用篇：應用篇主要在談論整理好「筆記卡片」後，如何整合、應用筆記的流程與方式。如何使用過去筆記累積出來的知識模版，在工作上、非虛構類文體、虛構類文體加速生成的質與量。 在結尾篇章中，我想強調筆記的重要與價值。 筆記不僅僅是為了記錄知識，筆記還能幫助我們整理思緒、理解概念，並加深記憶。而在現代的科技輔助下，我們甚至能拿筆記進行更進一步的深度探索與內容矩陣創作。。 這本書並不厚，結構簡單，可能是我寫過相對薄的書了。但是這本書背後的資訊量，我相信是這系列書籍裡面相對較為龐大的書。且打破所有筆記界的觀念，用科技與流程重新「發明」筆記。 ","date":"0001-01-01","objectID":"/posts/note-hack/07-%E7%B5%90%E8%AA%9E/:0:0","tags":null,"title":"","uri":"/posts/note-hack/07-%E7%B5%90%E8%AA%9E/"},{"categories":null,"content":"就知道你會點進來XDD 如果你還沒看完這本書，先請把這本書的前六章部分看完。 如果你看完這本書 將你的筆記開始細化 將你的筆記開始磨版化 一但把知識細化與模版化，加上 ChatGPT 就會擁有超能力！ 請你立即試著這樣做，用了以後你絕對會覺得很神奇的！ ","date":"0001-01-01","objectID":"/posts/note-hack/08-bonus-%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88-chatgpt-%E9%80%B2%E8%A1%8C%E6%87%89%E7%94%A8%E8%88%87%E5%89%B5%E4%BD%9C/:0:0","tags":null,"title":"","uri":"/posts/note-hack/08-bonus-%E5%A6%82%E4%BD%95%E9%85%8D%E5%90%88-chatgpt-%E9%80%B2%E8%A1%8C%E6%87%89%E7%94%A8%E8%88%87%E5%89%B5%E4%BD%9C/"},{"categories":null,"content":"打造超人笔记 重新發明筆記法 本書 v1-完成時間 2022/02 本書 v2-完成時間 2023/02 本書 v3-完成時間 2023/06 ","date":"0001-01-01","objectID":"/posts/note-hack/readme/:0:0","tags":null,"title":"","uri":"/posts/note-hack/readme/"},{"categories":null,"content":"1. 用一句話介紹這本書的內容 重新解構筆記學，做出有效筆記。重新梳理成紀錄、提取、整理、搜尋、應用 ","date":"0001-01-01","objectID":"/posts/note-hack/readme/:0:1","tags":null,"title":"","uri":"/posts/note-hack/readme/"},{"categories":null,"content":"2. 詳細介紹 《打造超人筆記》是一本關於如何有效記錄和整理筆記的書籍。作者認為，筆記是一個看起來複雜但實際上比學習和閱讀更簡單的問題。通過拆解筆記的流程，作者發現主要問題的結構變得非常簡單。此外，隨著外星科技的發展，許多快速記錄工具和筆記整理軟件已經被發明出來，使筆記搜尋變得更加容易。在本書中，作者探討了如何通過做筆記和整理筆記來挖掘和整理自己對一個領域的各種答案。通過閱讀本書，讀者可以學習到如何使用各種工具和方法來提高自己的筆記能力，成為一個筆記超人。 本書解決 ","date":"0001-01-01","objectID":"/posts/note-hack/readme/:0:2","tags":null,"title":"","uri":"/posts/note-hack/readme/"},{"categories":null,"content":"3. 目錄 00 前言 01 紀錄、提取、整理、搜索、應用 大幅節省腦力的作法：將記錄與整理分開 用科技翻修筆記流程提昇效率 02 紀錄 隨手記 : Read it Later \u0026 Do it Later 上課筆記：概念型課程與流程型課程 讀書筆記：篩讀、略讀、精讀、卡片筆記法 會議筆記 練功筆記：任務拆分、目標導向 03 提取 將線索變成資料 將資料變成資訊：用收納衣服的折衣籃概念降低整理負擔 將資訊變成容易回顧的筆記條目 調換筆記順序：輕鬆總結、認真歸納 萬向流程快速提取 04 打造永遠實用的長青筆記 卡片筆記法實戰 – 傳統紙筆 / word篇 卡片筆記法實戰 – 現代軟體篇 Logseq 日誌模式 詞條模式 Tag 模式 TODO 模式 Query 連結 Template 複用 從日常生活中找到滿滿可用的筆記時間 05 搜尋 – 利用筆記探索未知問題的答案 快速尋找到過去寫下的筆記的方法 對於想解決的問題，精準找到過去的筆記內容加以利用 黃金解題方法 – KJ 野外科學研究法 06 應用 - GPT 時代人肉如何碾壓 AI 創意工作高效流水化的方法 如何有源源不絕的靈感創作文章 非虛構類內容矩陣創作方式 書籍 Podcast 知識型 Youtube 劇本 論文產出 虛構類 小說、劇本黃金公式 利用卡片與 Excel 創作精彩又好看的故事 07　總結 08 ChatGPT 實戰 ","date":"0001-01-01","objectID":"/posts/note-hack/readme/:0:3","tags":null,"title":"","uri":"/posts/note-hack/readme/"},{"categories":null,"content":"密度函数平滑技术 当前的密度模型主要分为两类：（1）局部平滑和（2）全局平滑 ","date":"0001-01-01","objectID":"/posts/research/desity_modeling/:1:0","tags":null,"title":"","uri":"/posts/research/desity_modeling/"},{"categories":null,"content":"局部平滑 局部平滑函数用一个钟形的二次函数来替代原来的线性密度函数，只包含了局部的信息，可能会要消耗更多的迭代次数才能收敛。 ","date":"0001-01-01","objectID":"/posts/research/desity_modeling/:1:1","tags":null,"title":"","uri":"/posts/research/desity_modeling/"},{"categories":null,"content":"全局平滑 使用椭圆PDE去做平滑，现代非线性布局当中是主流的应用。全局信息的纳允许大规模的器件运动。在文献《T. F. Chan, J. Cong, J. R. Shinnerl, K. Sze, and M. Xie. mPL6: Enhanced Multilevel Mixed-Size Placement. In ISPD , pages 212–214, 2006.》中使用Helmholtz 方程来求密度如下： $$\\nabla\\psi(x,y)-\\epsilon\\psi(x,y)=\\rho(x,y),(x,y)\\in R$$ 其中$\\psi$表示平滑后的密度分布，当线性因子$\\epsilon \\gt 0$，有唯一解。 ","date":"0001-01-01","objectID":"/posts/research/desity_modeling/:1:2","tags":null,"title":"","uri":"/posts/research/desity_modeling/"}]